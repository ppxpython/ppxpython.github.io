{"meta":{"title":"SUM","subtitle":"会者定离，一期一祈， 感谢在这与你相遇","description":"","author":"Yang shuping","url":"https://ppxpython.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-09-27T00:44:38.000Z","updated":"2023-11-30T09:56:16.711Z","comments":false,"path":"categories/index.html","permalink":"https://ppxpython.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tages","date":"2020-09-27T00:44:38.000Z","updated":"2023-11-30T09:56:16.712Z","comments":false,"path":"tags/index.html","permalink":"https://ppxpython.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-09-27T00:44:38.000Z","updated":"2023-11-30T09:56:16.711Z","comments":true,"path":"about/index.html","permalink":"https://ppxpython.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"hexo博客 个性化优化设置","slug":"hexo博客-个性化优化设置","date":"2023-12-08T06:38:26.000Z","updated":"2023-12-08T06:38:26.916Z","comments":true,"path":"hexo博客-个性化优化设置/","link":"","permalink":"https://ppxpython.github.io/hexo%E5%8D%9A%E5%AE%A2-%E4%B8%AA%E6%80%A7%E5%8C%96%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-11-30T09:56:16.693Z","updated":"2023-11-30T09:56:16.694Z","comments":true,"path":"hello-world/","link":"","permalink":"https://ppxpython.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post h$ hexo new \"My New Post\"More info: Writing # Run server h$ hexo serverMore info: Server # Generate static files h$ hexo generateMore info: Generating # Deploy to remote sites h$ hexo deployMore info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"locust+prometheus+grafana压测","slug":"locust-prometheus-grafana压测","date":"2022-09-15T07:23:35.000Z","updated":"2023-11-30T09:56:16.696Z","comments":true,"path":"locust-prometheus-grafana压测/","link":"","permalink":"https://ppxpython.github.io/locust-prometheus-grafana%E5%8E%8B%E6%B5%8B/","excerpt":"","text":"# 了解压测 # 为什么要压测和目标 这个问题有很多答案，而每个人内心的答案可能都是不同的。 项目上线稳定后，对系统的评估 系统研发后期，对系统的检验 活动前，摸高压测，预估流量 线上出现性能问题 合作活动、系统，对方要求上线前压测 目标： 新服务，无预估目标，需要通过压测得到服务基准数据或找到系统瓶颈进行优化 有明确的压测目标，需要通过压测确定服务的各项指标是否达标 常态化压测，为后期性能优化指导方向或提供参考依据 # 压测的分类 # 压力测试指标 # 基础的关注点 # QPS 每秒处理的请求个数， “每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 单位是 request/s 。 每秒处理的请求数量 。 # TPS Transactions Per Second 的缩写，也就是事务数 / 秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。TPS &lt;= QPS # RPS Requests Per Second 的缩写，** 每秒能处理的请求数目。** 等效于 QPS 这三个过程，每秒能够完成 N 个这三个过程，Tps 也就是 N； Qps 基本类似于 Tps，但是不同的是， 对于一个页面的一次访问 ，形成一个 Tps；但 一次页面请求，可能产生多次对服务器的请求 ，服务器对这些请求，就可计入 “Qps” 之中。 例如：访问一个页面会请求服务器 3 次，一次放，产生一个 “T”，产生 3 个 “Q” # RT #响应时间 #，这个指标比较多，比如，最小响应时间、平均响应时间、最大响应时间等等，详细指标还有 P50 、 P95 、 P99 等等 响应时间 (RT) 是指用户从客户端发出请求到接收完服务器返回结果的整个过程所需花费的时间，包含网络传输时间以及服务器处理时间。 # VU 虚拟用户，系统模拟并发的用户。主要目的是最大程度的模拟用户操作，从而得到较为准确的压测数据，这个参数一般由压测人员制定，梯度递增。 阶段1: 50虚拟用户，压测1小时；阶段2: 100虚拟用户，压测1小时；阶段3: 150虚拟用户，压测1小时；阶段4: 200虚拟用户，压测1小时；阶段5: 250虚拟用户，压测1小时；一般在为达到最佳负载的情况下， QPS 会随着 VU 的数量等比递增。 比如， 50VU 下的 QPS 是 1000 ，那么 100VU 下的 QPS 会接近 2000 。 # 操作系统负载、外部系统等 压测期间，还需要关注下服务器的负载、网络 IO 情况，如果涉及到外围系统，比如 Mysql、Redis 等，那么也要纳入观察范围。所以也就需要运维同学查看监控的读写情况。 列举一些常用指标，并不一定都需要关注，根据业务考虑指标的细化粒度。 QPS：Query Per Second，每秒处理的请求个数 TPS：Transactions Per Second，每秒处理的事务数，TPS &lt;= QPS RT： Response Time，响应时间，等价于 Latency RT 分平均延时，Pct 延时（Percentile 分位数）。平均值不能反映服务真实响应延时，实际压测中一般参考 Pct90，Pct99 等指标 CPU 使用率：出于节点宕机后负载均衡的考虑，一般 CPU 使用率 &lt; 75% 比较合适 内存使用率：内存占用情况，一般观察内存是否有尖刺或泄露 # 学会观察 # 运行良好的特征 测试期间响应时间呈平稳趋势； 请求速率遵循与虚拟用户相同的斜坡（如果 VU 增加，则请求速率也会增加）； # 达到最大吞吐量的特征 随着虚拟用户数量的增加，活动的正在进行中的请求数量继续增加，而 QPS（完成的请求）却趋于平稳（甚至下降）。此时，系统过载，从而导致更长的响应时间。 HTTP 失败率增加 # 性能问题 / 瓶颈的特征 测试期间响应时间显著增加； 【ge: 在引擎鉴权测试时并发到达 2000 开始出现 TR 明显变长】 响应时间显著增加，然后迅速触底并保持平稳（HTTP 被降级了）； QPS 不会随着 VU 的增加而增加，并且响应时间开始增加，疑似达到最大吞吐量； # 发生故障的特征 高 HTTP 错误率 低 QPS 下的系统高负载 大概呈现的趋势为 除了前面说到的情况，肯定还有一些我们无法下手的三无接口，无参考、无预估、无历史数据，这时候只能一点一点来，慢慢把压力提上去的同时收集数据，最终得出接口的最优处理能力。 最佳并发用户数（The Optimum Number of Concurrent Users） 最大并发用户数（The Maximum Number of Concurrent Users） 资源的利用情况（Utilization，包括硬件资源和软件资源）、 吞吐量（Throughput，这里是指每秒事务数） 响应时间（Response Time） 坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。 资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长 蓝线表示 TPS，黄色表示响应时间 在 TPS 增加的过程中，响应时间一开始会处在较低的状态，也就是在 A 点之前。接着响应时间开始有些增加，直到业务可以承受的时间点 B，这时 TPS 仍然有增长的空间。再接着增加压力，达到 C 点时，达到最大 TPS。我们再接着增加压力，响应时间接着增加，但 TPS 会有下降。 # locust # locust 原理 # What is Locust？ 一个易于使用的分布式用户负载测试工具。它旨在对网站（或其他系统）进行负载测试，并确定一个系统可以处理多少并发用户。 Locust 是完全基于事件的，因此可以在单台机器中支持数以千计的用户在线。和其它基于事件的程序相比较，它是不需要使用回调的。相反，它通过 gevent 使用轻量级的进程。每一个 locust 测试你的网站时，实际上是真实的在内部运行它自己的进程 (或 greenlet 自行调度的微线程，准确的说)。这样就允许你不使用复杂的回调方法，而是使用 Python 编写复杂的场景。 Locust 在英文中是 蝗虫 的意思： 作者的想法是，在测试期间，放一大群 蝗虫 攻击您的网站。 # What is Gevent？ gevent 是一个基于协程的 Python 网络库，它使用 greenlet 在 libev 或 libuv 事件循环之上提供一个高级的同步 API 在Python中实现协程的第三方库。协程又叫微线程Corouine。使用gevent可以获取极高的并发能力 # 并发机制 ①Locust 的并发机制采用协程（gevent）的机制。 ②采用多线程来模拟多用户时，线程数会随着并发数的增加而增加，而线程之间的切换是需要占用资源的，IO 的阻塞和线程的 sleep 会不可避免的导致并发效率下降；正因如此，LoadRunner 和 Jmeter 这类采用进程和线程的测试工具，都很难在单机上模拟出较高的并发压力。 ③而协程和线程的区别在于：协程避免了系统级资源调度，由此大幅提高了性能。 ④正常情况下，单台普通配置的测试机可以生产数千并发压力，这是 LoadRunner 和 Jmeter 都无法实现的。 协程又称为微线程，纤程。英文名 Coroutine: 协程是一种用户态的轻量级线程 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复之前保存的寄存器上下文和栈 # 特点 ①、不需要编写笨重的 UI 或者臃肿的 XML 代码，基于协程而不是回调，脚本编写简单易读； ②、有一个基于 we 简洁的 HTML+JS 的 UI 用户界面，可以实时显示相关的测试结果； ③、支持分布式测试，用户界面基于网络，因此具有跨平台且易于扩展的特点； ④、所有繁琐的 I / O 和协同程序都被委托给 gevent，替代其他工具的局限性； 同样配置下，单台负载机可模拟的负载数远超 jmeter # Loucst 执行流程 具体流程如下： ①先执行 WebsiteTasks 中的 on_start（只执行一次），作为初始化； ②从 WebsiteTasks 中随机挑选（如果定义了任务间的权重关系，那么就按照权重关系随机挑选）一个任务执行； ③根据 Locust 类中 min_wait 和 max_wait 定义的间隔时间范围（如果 TaskSet 类中也定义了 min_wait 或者 max_wait，以 TaskSet 中的优先），在时间范围中随机取一个值，休眠等待； ④重复 2~3 步骤，直到测试任务终止。 # Locust 核心类介绍 # TaskSet() 定义了每个用户的任务集合，测试任务开始后，每个 Locust 用户会从 TaskSet 中随机挑选（如果定义了任务间的权重关系，那么就是按照权重关系随机挑选）一个任务执行，然后随机等待 Locust 类中定义的 min_wait 和 max_wait（如果 TaskSet 类中也定义了 min_wait 或者 max_wait，按照 TaskSet 中的为准）之间的一段时间，执行下一个任务。 # TaskSet 提供的常用方法 client # client 源码：return self.locust.client 返回 locust的client，用法与Request库类似 locust # 当任务集被实例化时，将引用根蝗虫类实例 parent # 任务集被实例化时，指向每个TaskSet所属的父类TaskSet （用于 TaskSet嵌套） client # 指向TaskSet所属的父HttpLocust类的client属性，self.client与self.locust.client效果是一样的。如果TaskSet所属的父类是个Locust类，则没有这个client属性 # HttpLocust() 继承了 Locust 类，表示将要生成的每一个虚拟的 HTTP 用户，用来发送请求到进行负载测试的系统 HttpLocust 继承 Locust -&gt; class HttpLocust(Locust): task_set # 定义locust执行任务行为的 任务集类 如：task_set = TestDemo host # 要测试的 目标服务地址 min_wait = 1000 # 单位为ms 最小等待时间 最新版本 已弃用 （当前版本:0.14.5） max_wait = 1000 # 单位为ms 最大等待时间 最新版本 已弃用 （当前版本:0.14.5） #between(min_wait, max_wait) wait_time = between(100, 1000) # 单位为ms 等待时间 任务执行间隔时间 随机从100~1000区间内取 # task 装饰器 可控制任务执行权重比 ，defautl：weight=1 如下 class ForumPage(TaskSet): @task(100) def read_thread(self): pass @task(7) def create_thread(self): pass # eg import jsonimport osfrom locust import HttpLocust, TaskSet, task, betweenclass Demo(TaskSet): @task def test_get(self): self.client.get(\"http://www.baidu.com\") @task def test_post(self): responses = self.client.post(url='url', headers='headers', data='body') # 对返回内容 进行断言 if responses.status_code == 200: rst = json.loads(responses.text, strict=False) if rst['code'] == '00000': responses.success() # Locust ResponseContextManager 类提供的 Report the response as successful else: responses.failure('code：%s ErrorMsg：%s' % (rst['code'], rst['errorMsg'])) else: responses.failure('status_code：%s' % responses.status_code)class WebsiteUser(HttpLocust): task_set = Demo host = 'http://www.baidu.com' # 目标服务地址 # min_wait = 1000 # 单位为 ms 最小等待时间 最新版本 已弃用 （当前版本：0.14.5） # max_wait = 1000 # 单位为 ms 最大等待时间 最新版本 已弃用 （当前版本：0.14.5） # between(min_wait, max_wait) wait_time = between(2, 5) # 单位为 s 等待时间 任务执行间隔时间# 以下 便于当前脚本 本地调试# 启动 当前脚本if __name__ == \"__main__\": cmd = 'locust -f locust_demo.py' os.system(cmd)# 核心 如果 Locust 类代表蝗虫群，则可以说 TaskSet 类代表蝗虫的大脑。每个 Locust 类必须设置一个 task_set 属性，该属性指向 TaskSet。 顾名思义，TaskSet 是任务的集合。这些任务是普通的 python 可调用对象。 TaskSet() 定义了每个用户的任务集合，测试任务开始后，每个 Locust 用户会从 TaskSet 中随机挑选（如果定义了任务间的权重关系，那么就是按照权重关系随机挑选）一个任务执行，然后随机等待 Locust 类中定义的 min_wait 和 max_wait（如果 TaskSet 类中也定义了 min_wait 或者 max_wait，按照 TaskSet 中的为准）之间的一段时间，执行下一个任务。 HttpLocust() 继承了 Locust 类，表示将要生成的每一个虚拟的 HTTP 用户，用来发送请求到进行负载测试的系统 taks 装饰器 可控制任务执行权重比，defautl：weight=1 如下： # IPT 流程 # 操作 输入接口，参数，账号，服务器 ip 们，内核数，返回结果，执行权重；输入模拟用户数模拟用户并发 # IPT 准备： 我们以校园版为例： 观察机：146 上为主环境代码 执行机：145，147，148，158 准备：测试账号数据：需要找开发邓锦明提供是否有现成代码，生成批量账号。 现需：教师账号：学生账号 1：50 数量：教师账号：70 个 学生 3500 - 个，一个教师对应 50 个学生 图形界面进行 逐步负载模式 前端主机配置 4g8c 找相应的开发去获取接口文档，接口参数。和并发量（需要与产品和开发确定） # IPT 部署环境 # 1. 登录远程服务器 配置 python3 环境 # 2. 刚申请时需要直接 pip3 install locust，不成功可能是因为没有安装 python 的 dev 包，yum install python3-devel 后重新输入 pip3 install locust # 3. 安装 ansible，在观察机上用于部署代码 安装 ansible yum -y install epel-release yum -y install ansible 配置 ansible 权限 vi /etc/ansible/ansible.cfg 在文件中进行搜索定位到 :/host_key_checking 修改后： #uncomment this to disable SSH key host checking host_key_checking = False # 4. 安装 locust # 安装依赖 1、支持的 python 版本：2.7、3.4、3.5、3.6； 2、 安装 locust ①、直接通过 pip install locustio 命令安装； ②、通过为 pyzmq、gevent 和 greenlet 安装预先构建的二进制包，然后在这里找到非官方的预制包，下载.whl 文件后，使用 pip install name-of-file**.whl** 命令安装； 安装成功后可以输入 pip show locust 命令查看是否安装成功，以及通过 locust -help 命令查看帮助信息。 pip3 install locust -i http://pypi.douban.com/simple --trusted-host pypi.douban.com Flask-BasicAuth psutil msgpack roundrobin gevent geventhttpclient-wheels # 5. pip3 install prometheus_client 用于采集数据 # 6. 将 IPT 项目进行拷贝 # 7. 安装 prometheus 用于收集 locust 监听的请求接口信息 将 #prometheus-2.36.2.linux-amd64.tar.gz# 文件进行解压，直接运行即可。 版本有要求：可视化观察 grafana-7.3.6 在 172.17.20.146 上，注意必须是要该版本或者以上否则主题面板数据可能不会显示，主题 12081 需要在 prometheus.yml 文件中配置一下监听 locust global: scrape_interval: 10s evaluation_interval: 10s scrape_configs: - job_name: prometheus static_configs: - targets: ['localhost:9090'] labels: instance: prometheus - job_name: locust metrics_path: '/export/prometheus' static_configs: - targets: ['localhost:8089'] # 地址修改为实际地址 labels: instance: locust 进入后运行./prometheus # 8. 将 test_locust.py 替换 # coding: utf8 import six from itertools import chain from flask import request, Response from locust import stats as locust_stats, runners as locust_runners from locust import User, task, events from prometheus_client import Metric, REGISTRY, exposition # This locustfile adds an external web endpoint to the locust master, and makes it serve as a prometheus exporter. # Runs it as a normal locustfile, then points prometheus to it. # locust -f prometheus_exporter.py --master # Lots of code taken from [mbolek's locust_exporter](https://github.com/mbolek/locust_exporter), thx mbolek! class LocustCollector(object): registry = REGISTRY def __init__(self, environment, runner): self.environment = environment self.runner = runner def collect(self): # collect metrics only when locust runner is spawning or running. runner = self.runner if runner and runner.state in (locust_runners.STATE_SPAWNING, locust_runners.STATE_RUNNING): stats = [] for s in chain(locust_stats.sort_stats(runner.stats.entries), [runner.stats.total]): stats.append({ \"method\": s.method, \"name\": s.name, \"num_requests\": s.num_requests, \"num_failures\": s.num_failures, \"avg_response_time\": s.avg_response_time, \"min_response_time\": s.min_response_time or 0, \"max_response_time\": s.max_response_time, \"current_rps\": s.current_rps, \"median_response_time\": s.median_response_time, \"ninetieth_response_time\": s.get_response_time_percentile(0.9), # only total stats can use current_response_time, so sad. #\"current_response_time_percentile_95\": s.get_current_response_time_percentile(0.95), \"avg_content_length\": s.avg_content_length, \"current_fail_per_sec\": s.current_fail_per_sec }) # perhaps StatsError.parse_error in e.to_dict only works in python slave, take notices! errors = [e.to_dict() for e in six.itervalues(runner.stats.errors)] metric = Metric('locust_user_count', 'Swarmed users', 'gauge') metric.add_sample('locust_user_count', value=runner.user_count, labels={}) yield metric metric = Metric('locust_errors', 'Locust requests errors', 'gauge') for err in errors: metric.add_sample('locust_errors', value=err['occurrences'], labels={'path': err['name'], 'method': err['method'], 'error': err['error']}) yield metric is_distributed = isinstance(runner, locust_runners.MasterRunner) if is_distributed: metric = Metric('locust_slave_count', 'Locust number of slaves', 'gauge') metric.add_sample('locust_slave_count', value=len(runner.clients.values()), labels={}) yield metric metric = Metric('locust_fail_ratio', 'Locust failure ratio', 'gauge') metric.add_sample('locust_fail_ratio', value=runner.stats.total.fail_ratio, labels={}) yield metric metric = Metric('locust_state', 'State of the locust swarm', 'gauge') metric.add_sample('locust_state', value=1, labels={'state': runner.state}) yield metric stats_metrics = ['avg_content_length', 'avg_response_time', 'current_rps', 'current_fail_per_sec', 'max_response_time', 'ninetieth_response_time', 'median_response_time', 'min_response_time', 'num_failures', 'num_requests'] for mtr in stats_metrics: mtype = 'gauge' if mtr in ['num_requests', 'num_failures']: mtype = 'counter' metric = Metric('locust_stats_' + mtr, 'Locust stats ' + mtr, mtype) for stat in stats: # Aggregated stat's method label is None, so name it as Aggregated # locust has changed name Total to Aggregated since 0.12.1 if 'Aggregated' != stat['name']: metric.add_sample('locust_stats_' + mtr, value=stat[mtr], labels={'path': stat['name'], 'method': stat['method']}) else: metric.add_sample('locust_stats_' + mtr, value=stat[mtr], labels={'path': stat['name'], 'method': 'Aggregated'}) yield metric @events.init.add_listener def locust_init(environment, runner, **kwargs): print(\"locust init event received\") if environment.web_ui and runner: @environment.web_ui.app.route(\"/export/prometheus\") def prometheus_exporter(): registry = REGISTRY encoder, content_type = exposition.choose_encoder(request.headers.get('Accept')) if 'name[]' in request.args: registry = REGISTRY.restricted_registry(request.args.get('name[]')) body = encoder(registry) return Response(body, content_type=content_type) REGISTRY.register(LocustCollector(environment, runner)) class Dummy(User): @task(20) def hello(self): pass 使用方式两种， a、直接修改改文件，将自己的压测类替换 Dummy 类，当启动压测，自动会启动 ip:/export/prometheus 的服务，该服务的数据就是我们需要收集的数据 b、以 master 启动该脚本，压测脚本以 worker 形式启动，指向 master 为启动该脚本的地址 b 优势在于，监听服务可以永远启动，第一种方式只有压测时才启动 # 9. 运行测试代码，保证与监控互通 运行 locust -f test_locust.py --worker --master-host=159.75.109.171 执行 locust --master -f prometheus_exporter.py 观察 在 159.75.109.171：8089 中访问进行并发请求 在访问 159.75.109.171:8089/export/prometheus 中保证监听 locust 程序正常执行 4. 访问 Prometheus Time Series Collection and Processing Server http://159.75.109.171:9090/graph http://159.75.109.171:9090/targets 保证promethus接收到locust请求的数据 5. 访问 Locust for Prometheus 全链路压测 - Grafana 6. http://172.17.20.147:3000/ 用账号admin admin访问grafana数据图表可视化 设置数据源将 至此我们的环境部署完毕，可以开始准备测试了 # # 测试流程 压测流程 完整的压测流程一般包含下面几个步骤 压测目标的制定 压测链路的梳理 压测环境的准备 压测数据的构造 发压测试 瓶颈定位及容量微调 压测总结 # 压测目标 性能测试中， 平均值的作用是十分有限的 ， 我们不应看最好的结果，相反地，应该控制最坏的结果 ， 总结一下，较为科学的评估方法应该将 指标-成功率-流量 三者挂钩在一起的： xx% 的响应在 xx 毫秒内返回，其中成功率为 xx%。 根据这个方针，可以得到一些测试思路： 在响应时间的限制下，系统最高的吞吐量（这里不对吞吐量做严格定义，当成是 QPS 或 TPS 即可） 在成功率 100% 的前提下，不考虑响应时间长短，系统能承受的吞吐量 容忍一定的失败率和慢响应，系统最高能承受的吞吐量（95% 成功率，前 95% 的请求响应时间为 xx 毫秒时的最大 QPS） 在上面的场景下还要考虑时间和资源，比如最高吞吐量持续 10 分钟和持续 1 小时是不一样的，不同的时间持续长度下，机器资源（cpu、内存、负载、句柄、线程数、IO、带宽）的占用是否合理 # 压测准备 # 压测场景 压测是有目的的压测，也就是说不是随便找些接口发一通压力，而压测全部的接口也是做不到的或者说无意义的，得有压测的优先级，所以梳理压测场景是很重要的。高优场景主要有下面几个： 高频业务场景 关键业务场景，使用频率低，一旦出问题就很严重（学生登录） 性能高消耗场景（上传答案） 曾经出现过问题的场景 压测有分单接口压测和场景化压测，前者会简单一些，后者一般是多个接口混合操作以组成一个业务场景，两者在方法上是相通的。 梳理场景时 QA 需要与 RD 对齐，确认不同接口的 RD 负责人、需要压测的接口、系统性能现状以及压测目标；在确定每个接口的压测目标时，要考虑到压测对象是单实例单机房还是集群；在细节上也要确认是单接口压测还是场景化压测，每个接口的流量占比以及优先级，需不需要发足够的压力来触发系统的自动扩容或降级等更进一步的运维能力。 # 压测环境 脏数据问题 如果是在独立的一套环境中操作，不存在该问题【eg：校园版压测会单独部署一套被压系统】 影子表：如果是在线上操作，一般将数据写入影子表（与原数据表在 schema 上一致的不同名表）而非原数据表，实现压测数据与线上数据隔离【eg：翼课网压测采用影子库】 白名单：指定测试 id 或者测试账号，在入库后通过统一 id 区分压测数据，统一处理 可以独立部署一套线下环境进行压测。在不影响线上环境的前提下，确保机房，网络，存储，上下游服务与线上保持一致，部署一套独立的环境进行测试，机器与线上隔离，机器出问题不会影响线上。这种方式压测只是针对较少的几个系统进行，因为很难把整个链路所有系统都独立再部署一套，所以应用范围有限。 # 压测监控体系 确认好压测流程的技术支持，确认压测链路的监控体系是否完整，一来方便在压测过程中及时发现问题，二来是为了积攒历史压测数据，三来顺便确认监控系统本身是否可靠且全部到位。一般监控项包括（也就是压测指标）： 核心接口和核心依赖的流量、响应耗时、成功率【eg：IPT 接入监控系统或日志查看】 消息队列、缓存、数据库【eg：由服务端观察队列和数据库的情况】 机器物理资源【eg：压测机器 qa 可查看机器负载情况】 # 压测总结 给出一个完整的压测过程例子： 确定本次的压测目标，预估各项指标的达标值 根据服务接口的优先级和使用场景，确认出需要压测的接口 梳理压测链路上的服务，确认链路完整性 针对压测链路设计的服务进行压测改造 准备压测数据，确认压测策略 开始压测，监控各项指标，多轮压测检验性能优化效果 压测环境清理 压测总结报告输出 压测最终应该输出一份报告总结，其实也就是把整个压测方案、过程、结论记录下来，写明压测目标、压测接口、压测数据、压测结论，给出发现的问题并提供优化方案。往往在压测报告完成时，性能问题已经基本被解决了，报告的意义在于梳理前面的整个流程，给后续的压测提供经验指导。 # 压测准备 # 确定压测范围 # 压测指标 # 压测前数据环境准备 # 压测中 # 日志结果分析 # 总结得出结论 调参，通过抓包分析各接口参数和接口之间参数对应关系 接口请求方式，接口请求方式一般分为 # application/x-www-form-urlencoded 数据发送过程中会对数据进行序列化处理，以键值对形式？key1=value1&amp;key2=value2 的方式发送到服务器。 数据被编码成以 '&amp;' 分隔的键 - 值对，同时以 '=' 分隔键和值。非字母或数字的字符会被 percent-encoding。传参时 urllib.parse.urlencode 需要对 dict 编码 优势：所有浏览器都兼容。 问题：在数据结构及其复杂时，服务端数据解析变得很难 # application/json 请求头中加入 content-type: application/jsonapplication/json ， 方便的提交复杂的结构化数据， ，告诉服务器请求的主体内容是 json 格式的字符串，服务器端会对 json 字符串进行解析，json 格式要支持比键值对复杂得多的结构化数据。这种方式的好处不需要关心数据结构的复杂度，只需要标准的 json 格式就能提交成功，传参时 json.dumps 需要转成 json 格式 优势：是前端不需要关心数据结构的复杂度，后端解析方便。 问题：少数浏览器不兼容 衡量指标，有时候开发会直接给出，但有时候我们需要自己去判定测试是否达标。 常见的方法 # 二八原则 日 PV=QPSx60x60x24 *//* 即 QPS 乘以一天的秒数 峰值 QPS=(日 PV80%)/(60x60x24x20%） // 通用公式每天 80% 的访问集中在 20% 的时间里，这 20% 时间叫做峰值时间 一天内 80% 的请求会在 20% 的时间内到达 每台服务器每秒处理请求的数量 =((80% 总 PV 量)/(24 小时 60 分 60 秒 40%)) / 服务器数量 通常测试过程中出现一些异常： 网络波动问题，可以让运维同事协助解决 (比如切换网段或选择内网压测)，或者等到网络较为稳定时候进行压测验证； 资源竞争问题：通过命令监控和服务梳理，找出压测时正在运行的其他服务，通过沟通协调停止该服务 (或者换个没资源竞争的服务节点重新压测也可以)； 高并发下大量报错 原因解析：出现该类问题，常见的原因有短连接导致的端口被完全占用以及线程池最大线程数配置较小及超时时间较短导致。 调优方案： 短连接问题：修改服务节点的tcp_tw_reuse参数为1，释放TIME_WAIT scoket用于新连接； 线程池问题：修改服务节点中容器的server.xml文件中的配置参数，主要修改如下几个参数： 最大线程数，即服务端可以同时响应处理的最大请求数 集群类系统，各服务节点负载不均衡 原因解析：出现这类问题的原因一般是 SLB 服务设置了会话保持，会导致请求只分发到其中一个节点。 调优方案：如果确认是如上原因，可通过修改 SLB 服务 (F5/HA/Nginx) 的会话保持参数为 None，然后再次压测验证； 并发数不断增加，TPS 上不去，CPU 使用率较低 原因解析：出现该类问题，常见的原因有：SQL 没有创建索引 / SQL 语句筛选条件不明确、代码中设有同步锁，高并发时出现锁等待； 数据清理 如果使用了影子表，可能收尾工作会简单一些，只需要下掉影子表即可。如果数据直接落到了线上数据库，可能一大堆压测数据要清理，压测时会对数据染色（比如指定测试账号或流量携带压测标记），逐层透传，最后根据标志识别删除。 举例一些可能会发现的典型问题： 存在多余的 http header，导致额外带宽占用；解决方式：去除多余参数，只带必填参数 spin_lock 对 RT 影响大，优化锁的方式（资源冲突）；解决方式：增加压测服务器性能或个数 调整 nginx worker 数量可提高性能 不恰当的长链接数，解决方式：调整代码进程连接时间和周期 代码实现上对象没有较好复用 解决方式：优化代码 业务流程上存在冗余 响应码 or 错误码可能要继续规范 内部系统对压测的限流，需要变更配置或者协商解除限制 解决方式：添加高并发 host # 参考资料 独家揭秘 | 阿里怎么做双 11 全链路压测？- 阿里云开发者社区 (aliyun.com) RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1 (ietf.org) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"连接池介绍","slug":"连接池介绍","date":"2022-07-26T01:37:16.000Z","updated":"2023-11-30T09:56:16.711Z","comments":true,"path":"连接池介绍/","link":"","permalink":"https://ppxpython.github.io/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"『动善时』JMeter 基础 — 41、使用 JMeter 连接数据库（MySQL） - 繁华似锦 Fighting - 博客园 (cnblogs.com) # 连接池 # 什么是连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。由程序动态地对池中的连接进行申请，使用，释放。 # 为什么要使用连接池 数据库连接是一种关键的有限的昂贵的资源， 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池 (简单说：在一个 “池” 里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 ———————————————— 版权声明：本文为 CSDN 博主「CrankZ」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/CrankZ/article/details/82874158 # 传统的连接机制与数据库连接池的运行机制区别 传统统链接：一般来说，Java 应用程序访问数据库的过程是： ①装载数据库驱动程序； ②通过 JDBC 建立数据库连接； ③访问数据库，执行 SQL 语句； ④断开数据库连接。 使用了数据库连接池的机制： （1） 程序初始化时创建连接池 （2） 使用时向连接池申请可用连接 （3） 使用完毕，将连接返还给连接池 （4） 程序退出时，断开所有连接，并释放资源 . 为何要使用数据库连接池 假设网站一天有很大的访问量，数据库服务器就需要为每次连接创建一次数据库连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。 数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现的尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正式针对这个问题提出来的. 数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个 。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数， 当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中. **数据库连接池的最小连接数和最大连接数的设置要考虑到以下几个因素:** 1, 最小连接数: 是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费. 2, 最大连接数：是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响以后的数据库操作 3, 如果最小连接数与最大连接数相差很大：那么最先连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，他将被 放到连接池中等待重复使用或是空间超时后被释放. # 二、使用数据库连接池的关键点 # 1、并发问题 为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。这个问题相对比较好解决，因为各个语言自身提供了对并发管理的支持像 java,c# 等等，使用 synchronized (java) lock (C#) 关键字即可确保线程是同步的。使用方法可以参考，相关文献。 # ２、事务处理 DB 连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。 我们知道，事务具有原子性，此时要求对数据库的操作符合 “ALL-ALL-NOTHING” 原则，即对于一组 SQL 语句要么全做，要么全不做。 我们知道当２个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。 # ３、连接池的分配与释放 连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他（如何能找到最合适的连接文章将在关键议题中指出）；如果没有就抛出一个异常给用户，List 中连接是否可以被分配由一个线程来专门管理捎后我会介绍这个线程的具体实现。 # ４、连接池的配置与维护 连接池中到底应该放置多少连接，才能使系统的性能最佳？ 系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接 。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。 如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接，以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。 # 三、使用数据库连接池的优势和其工作原理 # 1、连接池的优势 连接池用于创建和管理数据库连接的缓冲池技术，缓冲池中的连接可以被任何需要他们的线程使用。当一个线程需要用 JDBC 对一个数据库操作时，将从池中请求一个连接。当这个连接使用完毕后，将返回到连接池中，等待为其他的线程服务。 连接池的主要优点有以下三个方面。 第一、减少连接创建时间。连接池中的连接是已准备好的、可重复使用的，获取后可以直接访问数据库，因此减少了连接创建的次数和时间。 第二、简化的编程模式。当使用连接池时，每一个单独的线程能够像创建一个自己的 JDBC 连接一样操作，允许用户直接使用 JDBC 编程技术。 第三、控制资源的使用。如果不使用连接池，每次访问数据库都需要创建一个连接，这样系统的稳定性受系统连接需求影响很大，很容易产生资源浪费和高负载异常。连接池能够使性能最大化，将资源利用控制在一定的水平之下。连接池能控制池中的连接数量，增强了系统在大量用户应用时的稳定性。 # 2、连接池的工作原理 下面，简单的阐述下连接池的工作原理。 连接池技术的核心思想是连接复用，通过建立一个数据库连接池以及一套连接使用、分配和管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。 连接池的工作原理主要由三部分组成，分别为连接池的建立、连接池中连接的使用管理、连接池的关闭。 第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java 中提供了很多容器类可以方便的构建连接池，例如 Vector、Stack 等。 第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是： 当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。 该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。 第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。 3、常用的连接池： (1) dbcp dbcp 可能是使用最多的开源连接池，原因大概是因为配置方便，而且很多开源和 tomcat 应用例子都是使用的这个连接池吧。 这个连接池可以设置最大和最小连接，连接等待时间等，基本功能都有。这个连接池的配置参见附件压缩包中的:dbcp.xml 使用评价：在具体项目应用中，发现此连接池的持续运行的稳定性还是可以，不过速度稍慢，在大并发量的压力下稳定性 有所下降，此外不提供连接池监控 常用的参数 (阿里面试问常用的参数)： 我们来看 DBCP 的例子，然后根据例子来分析: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Jmeter 分享2","slug":"Jmeter-分享2","date":"2022-07-13T10:14:53.000Z","updated":"2023-11-30T09:56:16.636Z","comments":true,"path":"Jmeter-分享2/","link":"","permalink":"https://ppxpython.github.io/Jmeter-%E5%88%86%E4%BA%AB2/","excerpt":"","text":"# JMETER 分享 # 一、接口测试 注：接口参数可从附件 / 接口参数中拷贝 txt 文件内容，然后在 http 请求参数选择从剪切板复制添加 # 1、断言 响应断言 包括：响应内容包括需要匹配的内容即代表响应成功，支持正则表达式 匹配： 响应内容需要完全匹配需要匹配的内容即代表响应成功，不区分大小写，支持正则表达式 相等：响应内容要完全等于需要匹配的内容才代表成功，区分大小写，支持正则 字符串：返回结果包含指定结果的字符串，但是 Substring 不支持正则 否：不进行匹配 断言持续时间 在限定的时间内得到响应数据，超时同样为失败 JSON 断言 ![](https://pic.imgdb.cn/item/62df48edf54cd3f937a925da.png) # 2、用户参数 使用方法：前置处理器中添加，设置每次迭代更新一次，需要增加线程数才能起作用 作用：可以更新参数 # 3、函数助手 使用方法：在工具中添加 # 4、Bean shell 使用方法：在前置处理器中添加 作用：支持 JAVA 语言定义变量 例子： vars.put(\"user\",\"zj\") 在变量中 ${user} 即可使用 # 5、CSV 数据文件设置 文件名：C:/Users/Desktop/user_name.txt 变量名：username 忽略首行：False 是否允许带引号：False 遇到文件结束符再次循环：如果循环一百次，只有四个文件就 True 线程共享模式：看变量的生效区域 优先使用用户参数 &gt; CSV 数据 如需禁用，右键用户参数 &gt; 禁用 # 6、命令行启动 jmeter -n -t D:\\apache-jmeter-5.4.3\\TestCase\\数据库测试.jmx -l mt_test.jtl -e-n 以非 GUI 形式启动（命令行）启动 -t 测试脚本 -l 生成的文件名称 -e 执行完脚本后生成 html 报告 -o 测试报告存放的位置 (不加会默认生成到 bin\\report-output) 如果有 jtl 文件想生成 html 报告 (生成的 html 报告可能与聚合报告数据不一致，以聚合报告为准，再使用 jtl 报告生成 html 报告) jmeter -g test.jtl -o /path# -g：后跟 test.jtl 文件所在的路径# -o：后跟生成的 HTML 文件存放的路径报告数据项说明 Request-&gt;Label: 请求名称即采样器名称 Executions-&gt;#Samples：共请求多少次，请求的数量 (线程数 * 循环次数) Executions-&gt;KO：错误数量 Executions-&gt;Error%：错误率 Response Time（ms）：响应时间 Average：平均响应时间 Min：最小响应时间 Max：最大响应时间 90% Line：90% 线，90% 用户响应不超过该时间 95% Line：95% 线，95% 用户响应不超过该时间 99% Line：99% 线，99% 用户响应不超过该时间 Throughput：吞吐量，一般情况下可看做每秒完成请求数 (和 QPS 类似) 特别强调下 90th pct：这里指的是百分之九十的用户都不超过多少 ms，并不是多少指百分之九十的用户是多少 ms Network（KB/sec）：网络情况 Received：每秒从服务器端接收到的数据量 Sent：每秒从客户端发送的请求的数量 # 二、分布式部署 适用：压力测试 前提条件： 运行相同版本的 JMeter 使用相同的 java 版本 有基于 SSL 的 RMI 的有效密钥库，或者禁用 SSL。 都在一个网络 控制机：我们操作的机器，用于启动和传递测试任务，一般不执行测试任务（为了性能考虑） 执行机：用于执行控制机分发的测试任务，并上传测试数据到控制机 以多个 jmeter 运行在单机为例 控制机： 执行机： 控制机 &amp; 执行机： 启动顺序 1、先启动执行机下的 jmeter-server.bat，等待出现连接成功 2、执行控制机下的 jmeter.bat 注意： 1、任务并不是分发，而是拷贝 2、执行机下不需要有测试脚本 3、如果有用到CSV数据，则执行机下的相同路径也需要有csv配置文件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Jmeter 分享1","slug":"Jmeter-分享1","date":"2022-07-13T10:14:44.000Z","updated":"2023-11-30T09:56:16.636Z","comments":true,"path":"Jmeter-分享1/","link":"","permalink":"https://ppxpython.github.io/Jmeter-%E5%88%86%E4%BA%AB1/","excerpt":"","text":"# Jmeter 分享 # 一、简介 Apache JMeter 是 Apache 组织开发的基于 Java 的压力测试工具。用于对软件做压力测试，它最初被设计用于 Web 应用测试，但后来扩展到其他测试领域。 可以用于测试静态和动态资源，例如静态文件、CGI 脚本、Java 对象、数据库、FTP 服务器 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的 ** 负载，** 来自不同压力类别下测试它们的强度和分析整体性能。 # 二、安装 由于 Jmeter 是基于 java 开发，首先需要下载安装 JDK （目前 JMeter 只支持到 Java 8，尚不支持 Java 9）, 配置环境变量。 (1) 新增变量：JMETER_HOME：D:\\apache-jmeter-5.2.1 (2) 在 CLASSPATH 变量的最前面加入如下变量： % JMETER_HOME%\\lib\\ext\\ApacheJMeter_core.jar;% JMETER_HOME%\\lib\\jorphan.jar; (3) 在 PATH 变量的最前面加入如下变量：% JMETER_HOME%\\bin; (4) 进入 D:\\apache-jmeter-5.2.1\\bin，双击 jmeter.bat，或在 dos 窗口输入 jmeter 命令打开 jmeter 界面，安装成功。 官网下载地址：http://jmeter.apache.org/download_jmeter.cgi 下载完成后解压 zip 包 启动 JMeter，双击 JMeter 解压路径（apache-jmeter-3.3\\bin）bin 下面的 jmeter.bat 即可 Jmeter 是支持中文的，启动 Jmeter 后， 点击 Options -&gt; Choose Language 来选择语言 # 三、 jmeter 使用 # 1.jmeter 的主要元件 (1) 测试计划：是使用 JMeter 进行测试的起点，它是其它 JMeter 测试元件的容器 (2) 线程组：代表一定数量的用户，它可以用来模拟用户并发发送请求。实际的请求内容在 Sampler 中定义，它被线程组包含。 (3) 配置元件：维护 Sampler 需要的配置信息，并根据实际的需要修改请求的内容。 (4) 前置处理器：负责在请求之前工作，常用来修改请求的设置 (5) 定时器：负责定义请求之间的延迟间隔。 (6) 取样器 (Sampler)：是性能测试中向服务器发送请求，记录响应信息、响应时间的最小单元，如：HTTP Request Sampler、FTP Request Sample、TCP Request Sample、JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求。 (7) 后置处理器：负责在请求之后工作，常用获取返回的值。 (8) 断言：用来判断请求响应的结果是否如用户所期望的。 (9) 监听器：负责收集测试结果，同时确定结果显示的方式。 (10) 逻辑控制器：可以自定义 JMeter 发送请求的行为逻辑，它与 Sampler 结合使用可以模拟复杂的请求序列。 # 2. 常用操作 启动 jemter 后一般会默认生成一个测试计划，在测试计划下可以添加线程组，其中线程组有下面几种重要的参数。 线程数：虚拟用户数，用于并发测试。 Ramp-Up Period (in seconds) 准备时长：设置的虚拟用户数需要多长时间全部启动。如果线程数为 10，准备时长为 2，那么需要 2 秒钟启动 10 个线程，也就是每秒钟启动 5 个线程。 循环次数：每个线程发送请求的次数。如果线程数为 10，循环次数为 100，那么每个线程发送 100 次请求。总请求数为 10*100=1000 。如果勾选了 “永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。 在线程组下添加测试的请求类型，例如 http 请求、TCP 请求等，注意一些请求可能需要添加额外的插件才能实现（例如 UDP）。下面以常用的 http 请求为例。 协议：向目标服务器发送 HTTP 请求协议，可以是 HTTP 或 HTTPS，默认为 HTTP 。 服务器名称或 IP ：HTTP 请求发送的目标服务器名称或 IP 。 端口号：目标服务器的端口号，默认值为 80 。 方法：发送 HTTP 请求的方法，可用方法包括 GET、POST、HEAD、PUT、OPTIONS、TRACE、DELETE 等。 路径：目标 URL 路径（URL 中去掉服务器地址、端口及参数后剩余部分） Content encoding ：编码方式，默认为 ISO-8859-1 编码，这里配置为 utf-8。 前置处理器：主要用来对其覆盖范围内采样器请求和响应的内容进行修改或截获。url 的分配 setUP 线程组：在测试任务 ThreadGroup 运行前先被运行。通常用在运行测试任务前，做初始化工作。例如建立数据库连接初始分化工作、用户登录 tearDown 线程组：在测试任务线程组运行结束后被运行。通常用来做清理测试脏数据、登出、关闭资源等工作。例如关闭数据库连接 线程组： 执行核心任务 # 注： POST 和 GET 请求方法各有利弊，简单介绍一下 POST 和 GET 的请求方法的区别，POST 是把参数放在 body 里面，而 GET 的是把请求的参数放在 URL 里面，这样传递参数的长度会受到限制。 # 四、实例演示 # 1. 学生登录接口 # 1.1 接口的地址 https://mapi.ekwing.com/student/User/login （1）协议：https 服务器名称：mapi.ekwing.com 端口号：空 （2）请求方法：GET 路径：/student/User/login 内容编码：utf-8 注意：路径输入的时候，不能有空格。 （3）请求的参数 （4）请求头参数 {\"Accept-Language\": \"zh-Hans-CN;q=1\", \"Accept-Encoding\": \"utf-8\", \"Connection\": \"keep-alive\", \"Accept\": \"/\", \"User-Agent\": \"EKWStudent/3.8.8 (iPhone; iOS 13.2.3; Scale/2.00)\", \"Host\": \"mapi.ekwing.com\", \"Content-Type\": \"application/json\"} （5）点击运行 （6）察看结果树 # 2. 获取作业列表的接口 地址：https://mapi.ekwing.com/student/Hw/getlist （1）协议：https 服务器名称：mapi.ekwing.com 端口号：空 （2）请求方法：POST 路径：/student/Hw/getlist 内容编码：utf-8 注意：路径输入的时候，前面不能有空格。 （3）请求的参数 {\"driverType\": \"HMA-AL00\", \"is_http\": \"1\", \"uid\": \"uid\",\"sortField\":\"publishtimes\",\"driverCode\":\"3.9.0\",\"sortMethod\":\"desc\",\"osv\":\"10\",\"token\":\"{uid}\", \"sortField\": \"publish_times\", \"driverCode\": \"3.9.0\", \"sortMethod\": \"desc\", \"osv\": \"10\", \"token\": \"uid\",\"sortField\":\"publisht​imes\",\"driverCode\":\"3.9.0\",\"sortMethod\":\"desc\",\"osv\":\"10\",\"token\":\"{token}\", \"client\": \"student\", \"v\": \"3.7\", \"author_id\": \"${uid}\", \"os\": \"Android\", \"method\": \"unfinish\", \"deviceToken\": \"F4%3A63%3A1F%3A1D%3A45%3AFE\", \"page\": \"1\"} （4）请求头参数 {\"Accept-Language\": \"zh-Hans-CN;q=1\", \"Accept-Encoding\": \"utf-8\", \"Connection\": \"keep-alive\", \"Accept\": \"/\", \"User-Agent\": \"EKWStudent/3.8.8 (iPhone; iOS 13.2.3; Scale/2.00)\", \"Host\": \"mapi.ekwing.com\", \"Content-Type\": \"application/json\"} （5）点击运行 （6）察看结果树 因为获取作业列表接口的一些请求参数值是登录接口的返回参数值，也就是说获取作业列表接口和登录接口存在依赖的关系，下面重点了解一下如何使用 Jmeter 做多个接口的测试。 # 五、访问多个接口 # 1、什么是接口参数依赖 接口参数依赖又称作接口依赖，简单点说就是后面的接口要用到前面的接口产生的数据。 比如：我们一个接口 B 需要 A 接口返回的参数 token 作为自己的请求参数。常见的场景如：访问一个需要登录才能浏览的接口。 下面以获取作业列表的接口需要依赖登录接口为例，进行介绍。 # 2.json 提取器的使用 利用 Jmeter 进行接口参数依赖的测试，主要有两种方式，第一种利用正则表达式，第二种是 JSON 提取器，本次先介绍 JSON 提取器解决接口参数之间的依赖的方法。 （1）创建 Json 提取器 http 请求 --&gt; 右击 --&gt; 添加 --&gt; 后置处理器 --&gt;JSON 提取器 （2）填写参数值 需要填写数据的字段是 Names of created variables、JSON Path expressins、Match No.(0 for Random) Names of created variables 指的是登录接口中的参数名，如 token，uid JSON Path expressins 是对登录接口的参数 token 和 uid 进行提取，格式为.data.token,.data.token,.data.token,.data.uid Match No.(0 for Random) 是指匹配数字（0 代表随机，1 代表第一个，-1 代表所有），可为空即默认第一个 （3）保存 # ３. 学生的登录接口和获取作业列表接口之间的依赖关系 (1) 首先，如上述介绍成功访问了学生的登录接口，获得 token 值。 (2) 使用 Jmeter 工具中的 json 提取器，提取登录接口的 token 值，uid 值，author_id 值作为获取作业列表的接口的参数。 在第二个接口的察看结果树中的请求的 Request Body 能够看到 token、uid、author_id 值和登录接口的响应数据中的 Body 值是一样的，就说明提取成功了，然后在获取作业列表接口的 token、uid、author_id 的参数后加上值，格式分别是token,{token},token,{uid},$ (3) 点击运行 (4) 察看结果树 响应数据中的 Response Body 中 stasus 值为 0，代表获取作业列表接口请求成功了。 补充：这里将两个接口都放在一个线程组下，更为操作简单，也可以将两个接口都放在两个线程组下，操作起来相对复杂。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"vscode+GitHub+jsDelivr+PicGo绑定图床","slug":"vscode-GitHub-jsDelivr-PicGo绑定图床","date":"2022-04-14T02:07:04.000Z","updated":"2023-11-30T09:56:16.710Z","comments":true,"path":"vscode-GitHub-jsDelivr-PicGo绑定图床/","link":"","permalink":"https://ppxpython.github.io/vscode-GitHub-jsDelivr-PicGo%E7%BB%91%E5%AE%9A%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"新建 GitHub 仓库 登录 GitHub 帐号之后，选择 New Repository（新建仓库） https://pic.imgdb.cn/item/62579b35239250f7c5766d88.png 仓库名填 trmpblog，类型为 public（若设为 private，将无法正常使用），最后 Create repository（生成仓库）。 生成 Token 在右上方点击头像，然后选择 Settings（设置）。 选择左边列表最下方的 Developer settings（开发者设置）。 选择 Personal access tokens（个人访问密钥），再点击 Generate new token（生成新的密钥）。 填写 Note（说明），这个值随便填，方便自己以后查看即可，repo 栏，全部勾上。 密钥此时已经生成了，如图中红框处，此密钥值只会出现一次，务必在生成后保存到合适的地方，以后也无法查看。 配置 VS Code 在 vs code 扩展商店中，下载 PicGo 扩展。 配置 PicGo 扩展的选项，共需要配置 6 个设置。 图床类型，选择 github； 分支，推荐使用 main 分支即可（注意自己的主分支）； 自定义 Url，https://cdn.jsdelivr.net/gh/【你的 GitHub 用户名】/【你的仓库名】，不建议更改此处设置。另外注意，地址的最后千万不要留有斜杠 / ； 路径，使用 image/ 即可，注意格式，前面不要有 / ，后面必须有 / ； 仓库，【你的 GitHub 用户名】/【你的仓库名】，注意格式，前后都不要用 / ； 密钥，填入之前生成的访问密钥。 内容创作 一切就绪，现在可以进行图片内容的创作了，在 VS code 编辑器，使用以下快捷键即可选择图片文件并上传到 GitHub，之后可以看到生成的图片的 markdown 代码了。 在这我用到了一个 vscode 中 md 的显示插件 (非必要) 可视化：Clipboard github 中就成功上传了图片 参考链接： https://lovejy.blog.csdn.net/article/details/108156070?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2defaultCTRLISTRate-1.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2defaultCTRLISTRate-1.pc_relevant_paycolumn_v3&amp;utm_relevant_index=1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"感悟","slug":"感悟","date":"2022-02-21T10:39:40.000Z","updated":"2023-11-30T09:56:16.711Z","comments":true,"path":"感悟/","link":"","permalink":"https://ppxpython.github.io/%E6%84%9F%E6%82%9F/","excerpt":"","text":"最近看到少年天使，让我对世界多了一些感想。终于有人对网络暴力下手了。希望在不就的将来会有相关的法律诞生。 本身对于这篇文章就不是想和热点靠近，去对未知的事情揣测。只是处于身处同一个时代或者说更多的是佩服他来谈谈自己的感悟。 从这件事情发生到现在让我们由衷的为这位天使感伤但这个始终努力发光的又善良的人，世界对其太不公平了。沉浸在这悲伤中久久不能平静。 当第二天带着这份悲伤时，发现身边的人和世界依然和平运转似乎没有什么不同。当与人提及时好多人不知道这件事。这次时间虽然是第三方的角度发生，但由衷感觉看到了第二人称似的。可能是因为人生经历中遇到的有些人有些事和他的经历相楔合，但都发生在不同的人身上。果然世界上少了谁都不可能不运转，再悲壮的人生在悲惨的遭遇在他人的世界中都是故事，一听即过。本就如此，本就无感同身受。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"jmeter官网实例","slug":"jmeter官网实例","date":"2022-01-06T10:33:49.000Z","updated":"2023-11-30T09:56:16.696Z","comments":true,"path":"jmeter官网实例/","link":"","permalink":"https://ppxpython.github.io/jmeter%E5%AE%98%E7%BD%91%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"mysql安装教程","slug":"computer/app/mysql安装教程","date":"2022-01-06T02:16:34.000Z","updated":"2023-11-30T09:56:16.690Z","comments":true,"path":"computer/app/mysql安装教程/","link":"","permalink":"https://ppxpython.github.io/computer/app/mysql%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"mysql 安装教程 # 正文： 现在作为服务器操作系统的一般有三种，Windows Server，Linux，Unix，在这里我们只介绍在 windows 下和 linux 下安装 mysql，Unix 下安装应该和 linux 差不多。 # Windows 下安装 MySQL： 在浏览器中打开 https://www.mysql.com/，进入 MySQL 的官方网站，国内的网打开可能有点儿慢，稍微等待一下 在打开的网页中选择 downloads 标签，如下图： 在打开的标签页中，滑到页面的最下面，可以看到 MySQL Community Edition Community (GPL) Downloads » 的字样，点击 Community (GPL) Downloads »，如下图： 在之后打开的页面中，点击 MySQL Community Server (GPL)，如下图： 在之后打开的页面中就可以看到相关的下载项了，如下图： 在图中第一个红色框标注的地方就是选择操作系统，这里我们选择 Microsoft Windows，可以看到第二个红色框是 Recommended download，这里就要区分了，如果是新手建议点击这个，因为这个版本的 MySQL 不用自己配置，就是普通的安装文件，直接一路 next 就安装完了，如果想深入学习，那么点击 Other downloads 内容区的下载，可以看到前两个是正式版，后两个是 debug 版，一般选择前两个，根据自己的机器 32 位还是 64 位选择下载，下载下来是个 zip 文件，安装的自己配置，相对复杂 如果选择了 MySQL Installer 进去页面之后，如下： 选择第二个下载项进行下载，这里不管是新手还是老手，都会要求先登录再下载，如果没有账号可以注册一个，因为现在 MySQL 归 Oracle 所有了，不得不遵循这个规矩 # 为防止有的同学无法下载，这里贴出下载链接： MySQL Installer 5.7 ：http://cdn.mysql.com//Downloads/MySQLInstaller/mysql-installer-community-5.7.16.0.msi MySQL 5.7 Windows (x86, 32-bit), ZIP Archive ：http://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.16-win32.zip MySQL 5.7 Windows (x86, 64-bit), ZIP Archive ：http://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.16-winx64.zip MySQL Installer 只有 32 位的，没有 64 位的 # 如果下载的是 mysql installer，请看这里： 双击安装文件，可能会出现下面的画面： 意思就是 MySQL 需要.NET Framework4.0 才能继续安装，那我们就安装一下 用浏览器打开 http://www.microsoft.com/zh-cn/download/details.aspx?id=17718，点击下载，就可以很顺利的下载下来了，下载完直接安装 点击完成，然后再双击 MySQL 安装文件，这次就能正常安装了～ 接下来就是一些说明协议啥的 同意协议，打钩之后，点击 next，然后出现，选择安装选项的界面，一般选择第一个就行，这个选项包含了一些 MySQL 其它组件，像 MySQL Workbench，MySQL for Excel 等等，如果只安装 MySQL 数据库，选择第二项 Server only 就行，这里我选择了第一项 点击 next 出现检查必需项，如果电脑安装了 VC2013 运行库，Excel，VisualStudio 前三项就会自动打上勾，因为我是虚拟机演示的，所以没有装这些，点击 next 的时候会出现警告框，不去管它，直接点击是跳过 然后出现即将要安装的软件和插件 点击 execute 开始执行安装，等全部安装完之后，点击 next，图中第三项表示安装失败，不去管它，是一个 odbc 数据源，我们一般不用这个 之后出现配置界面 点击 next 之后开始配置，第一个配置的是 mysql 的运行模式和网络，其中 Config Type 表示运行模式，如果安装 mysql 是做开发用，就直接选择第一个默认的就行，第二个 Server Machine 表示运行模式为服务器模式，这些模式的不同会导致 MySQL 占用系统资源的不同，第二个配置的是网络相关，表示链接 MySQL 的时候使用 TCP/IP 协议，并指定端口号为 3306，这些如果没有特殊要求就不要去改 配置完成之后点击 next，需要填写 MySQL 中 root 用户的密码，长度最低为 4 位，第二栏中还可以添加普通用户，一般开发用不用再建立用户了，直接使用 root 就可以，所以我们填完密码之后点击 next 以下图片中需要配置的是 MySQL 的运行方式，第一个单选框表示是否将 MySQL 服务作为一个 windows 服务来运行，windows server name 表示 MySQL 服务在 windows server 中的名称，第二个单选框表示是否在系统启动时自动启动 MySQL， 第三个单选框表示 MySQL 服务以哪个账户运行，这一页的基本别动，直接 next 下面这个是关于 MySQL 的插件和扩展，直接 next 然后出现下面的界面，直接点击 execute 配置完之后点击 finish 然后再配置 MySQL 的实例，点击下图中的 next 之后点击下图中的 check，然后点击 next 点击下图中的 execute 执行完毕之后点击 finish，又回到了主程序，然后点击 next 然后点击下图中的 finish finally，配置完了～～～我们开始验证一下，在开始菜单找到 MySQL 5.7 Command Line Client 打开，之后提示输入密码，输入刚开始安装的时候你配置的密码，出现下图表示你安装成功了 # 下载 zip 安装包的看这里： 首先解压你下载的安装包，得到一个名为 mysql… 的文件夹 把这个文件夹移动到你想安装 mysql 的地方，也就是你移动到的目录就是安装 mysql 的目录，比如我的放在 C:\\Program Files 下面 打开我的电脑 -&gt; 属性 -&gt; 高级 -&gt; 环境变量，在系统变量里选择 PATH, 在其后面添加：你的 mysql bin 文件夹的路径 (如: C:\\Program Files\\mysql-5.7.16-winx64\\bin)，注意是追加，不是覆盖 ，然后确定 在 mysql 目录中新建文件夹 data，还需要修改一下配置文件，mysql 默认的配置文件是 mysql 目录中的 my-default.ini，比如我的是 C:\\Program Files\\mysql-5.7.16-winx64\\my-default.ini 用记事本打开在其中修改或添加配置，之后保存关闭 [mysqld] basedir= C:\\Program Files\\mysql-5.7.16-winx64（mysql 所在目录） datadir= C:\\Program Files\\mysql-5.7.16-winx64\\data（mysql 所在目录 \\data） 以管理员身份运行 cmd（一定要用管理员身份运行，不然权限不够），输入命令 cd C:\\Program Files\\mysql-5.7.16-winx64\\bin 回车 然后再输入 mysqld --initialize-insecure --user=mysql 回车 之后再输入 mysqld install 回车 输入 net start mysql 回车启动 mysql 服务 从上图看到 mysql 服务已经启动了，我们输入 mysql -u root -p 回车登录 mysql 数据库 要求输入密码，刚刚安装完是没有密码的，直接回车 看到已经进入了 mysql，我们输入 show databases; 回车可以看到数据库已经显示出来了，这个是不是比安装版的更简单 # Linux 下安装 mysql： 这个请看其他人写好的：http://jingyan.baidu.com/article/fec7a1e5f8d3201190b4e782.html http://www.cnblogs.com/shenliang123/p/3203546.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"}],"tags":[]},{"title":"mvn安装配置教程","slug":"computer/app/mvn安装配置教程","date":"2022-01-06T02:15:35.000Z","updated":"2023-11-30T09:56:16.690Z","comments":true,"path":"computer/app/mvn安装配置教程/","link":"","permalink":"https://ppxpython.github.io/computer/app/mvn%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"mvn 安装配置教程 # Maven 配置 Maven 项目对象模型 (POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 Maven 的配置却让一些初学者望而却步，这里我就把 Maven 的详细配置过程写下，希望能对你有所帮助。 # 文章目录 Maven 配置 Maven 的下载 Maven 常用配置 1. 环境变量配置 2. 修改配置文件 1. 本地仓库位置修改 2. 修改 maven 默认的 JDK 版本 3. 添加国内镜像源 常用 IDE 下配置 Maven IDEA 下配置 Maven Eclipse 下配置 Maven 附：完整的 Settings.xml 文件 # Maven 的下载 在 Maven 的官网即可下载，点击访问 Apache Maven。 下载后解压即可，解压后目录结构如下： # Maven 常用配置 在配置之前请将 JDK 安装好。 # 1. 环境变量配置 添加 M2_HOME : 对应 Maven 的解压目录即可。 编辑 Path 环境变量： 测试，在 cmd 窗口输入 mvn -v 查看 显示如下即配置成功： # 2. 修改配置文件 通常我们需要修改解压目录下 conf/settings.xml 文件，这样可以更好的适合我们的使用。 此处注意：所有的修改一定要在注释标签外面，不然修改无效。Maven 很多标签都是给的例子，都是注释掉的。 文章最后附上我的整个 Settings.xml 文件配置。 # 1. 本地仓库位置修改 在 &lt; localRepository &gt; 标签内添加自己的本地位置路径 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; # 2. 修改 maven 默认的 JDK 版本 在 &lt; profiles &gt; 标签下添加一个 &lt; profile &gt; 标签，修改 maven 默认的 JDK 版本。 &lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; # 3. 添加国内镜像源 添加 &lt; mirrors &gt; 标签下 &lt; mirror &gt;，添加国内镜像源，这样下载 jar 包速度很快。默认的中央仓库有时候甚至连接不通。一般使用阿里云镜像库即可。这里我就都加上了，Maven 会默认从这几个开始下载，没有的话就会去中央仓库了。 &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; # 常用 IDE 下配置 Maven 目前常用的开发工具如 idea，eclipse 都自身集成了一个版本的 Maven。但是通常我们使用自己已经配置好的 Maven。 # IDEA 下配置 Maven 1：此处修改为自己解压的 Maven 目录 2：勾选 Override ，修改为自己目录下的 settings.xml 目录 3：修改为自己的本地仓库地址，一般会自动识别。 此处勾选，当修改 pom 文件时，Maven 就能帮我们自动导包了。 # Eclipse 下配置 Maven 将 eclipse 使用的 Maven 修改为自己的。点击 add 后选择自己 Maven 的安装目录即可。添加好之后记得勾选。 将所有的 settings 修改为自己 Maven 目录下的 conf/settings.xml . 点击 Update Settings 按钮，下面的 Local Respository 会自动识别出来。 # 附：完整的 Settings.xml 文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in ${user.home}/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming they're all using the same Maven | installation). It's normally provided in | ${maven.conf}/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt; &lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; &lt;!-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; --&gt; &lt;!-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false &lt;offline&gt;false&lt;/offline&gt; --&gt; &lt;!-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like \"mvn prefix:goal\". Maven will automatically add the group identifiers | \"org.apache.maven.plugins\" and \"org.codehaus.mojo\" if these are not already contained in the list. |--&gt; &lt;pluginGroups&gt; &lt;!-- pluginGroup | Specifies a further group identifier to use for plugin lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt; &lt;/pluginGroups&gt; &lt;!-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |--&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;/proxies&gt; &lt;!-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |--&gt; &lt;servers&gt; &lt;!-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the 'id' attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | &lt;server&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; --&gt; &lt;!-- Another sample, using keys to authenticate. &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt; --&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of '1.4' might activate a profile when the build is executed on a JDK version of '1.4.2_07'. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |--&gt; &lt;profiles&gt; &lt;!-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt; | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as 'env-dev', 'env-test', 'env-production', 'user-jdcasey', 'user-brett', etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile id's for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. &lt;profile&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; --&gt; &lt;!-- | Here is another profile, activated by the system property 'target-env' with a value of 'dev', | which provides a specific path to the Tomcat instance. To use this, your plugin configuration | might hypothetically look like: | | ... | &lt;plugin&gt; | &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt; | &lt;artifactId&gt;myplugin&lt;/artifactId&gt; | | &lt;configuration&gt; | &lt;tomcatLocation&gt;${tomcatPath}&lt;/tomcatLocation&gt; | &lt;/configuration&gt; | &lt;/plugin&gt; | ... | | NOTE: If you just wanted to inject this configuration whenever someone set 'target-env' to | anything, you could just leave off the &lt;value/&gt; inside the activation-property. | &lt;profile&gt; &lt;id&gt;env-dev&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;target-env&lt;/name&gt; &lt;value&gt;dev&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;properties&gt; &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt; &lt;/properties&gt; &lt;/profile&gt; --&gt; &lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- activeProfiles | List of profiles that are active for all builds. | &lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; --&gt; &lt;/settings&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"}],"tags":[]},{"title":"java安装教程","slug":"computer/app/java安装教程","date":"2022-01-06T02:14:35.000Z","updated":"2023-11-30T09:56:16.689Z","comments":true,"path":"computer/app/java安装教程/","link":"","permalink":"https://ppxpython.github.io/computer/app/java%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"java 安装教程 # JAVA (windows) 安装教程 闲来无聊，把电脑给重装系统了，导致什么环境都没得；下面简单说下 windoes 系统下 jdk 的安装步骤 # 一、下载 首先点击地址进行下载：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 二、安装 # 1、双击下载的程序包，出现如图所示 2、点击下一步；这里我把路径给改成了（D 盘下的 jdk1.8） 3、继续下一步，会出现弹框，点击确定 4、点击确定，会出现安装 jre 的提示，点击下一步即可 5、等待安装完成 6、之后窗口左侧会有一个弹框，把它拉出来即可 # 7、点击关闭 三、接下来进行环境变量的配置 # 1、右键我的电脑，点击最下面的属性，之后再弹框里点击高级系统设置，再点击环境变量 2、点击新建 (1) 新建 -&gt; 变量名 \"JAVA_HOME\"，变量值 C:\\Java\\jdk1.8.0_05 （即 JDK 的安装路径） (2) 编辑 -&gt; 变量名 \"Path\"，在原变量值的最后面加上 %JAVA_HOME%\\bin 之后一路点击确定 # 四、接下来进行验证，看是否成功安装了 java # 1、打开 cmd 使用快捷键，** (win+r) ** ，输入 cmd # 2、输入 java 观察是否有输出，出现下面就说明这个命令是 OK 的 3、输入 java -version 观察；出现下面现象就表示 OK 4、输入 javac，观察 PPS： 上面的命令，如果输入完之后，没有出现相对应的界面，说明环境变量配置的有问题；仔细去检查即可 # 六、接下来验证，让我们来写一段 java 代码，并试着运行它 # 1、首先创建一个 java 后缀的文件 HelloWorld.java (文件名需与类名一致), # 代码如下 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World\"); } } # 2、编辑并保存文件，打开 cmd 控制台，进入 java 文件的目录 3、命令解析 以上我们使用了两个命令 javac 和 java。 javac 后面跟着的是 java 文件的文件名，例如 HelloWorld.java。 该命令用于将 java 源文件编译为 class 字节码文件，如： javac HelloWorld.java。 运行 javac 命令后，如果成功编译没有错误的话，会出现一个 HelloWorld.class 的文件。 java 后面跟着的是 java 文件中的类名，例如 HelloWorld 就是类名，如: java HelloWorld。 注意：java 命令后面不要加.class。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"}],"tags":[]},{"title":"Idea安装配置教程","slug":"computer/app/Idea安装配置教程","date":"2022-01-06T02:12:50.000Z","updated":"2023-11-30T09:56:16.687Z","comments":true,"path":"computer/app/Idea安装配置教程/","link":"","permalink":"https://ppxpython.github.io/computer/app/Idea%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"Idea 安装配置教程 IDEA 安装和使用_linshaolun0701 的博客 - CSDN 博客_idea 安装 IntelliJ Idea 下载与安装 (含注册码) IntelliJ IDEA 号称当前 Java 开发效率最高的 IDE 工具。 IntelliJ IDEA 有两个版本：社区版 (Community) 和旗舰版 (Ultimate)。 社区版 是免费的、开源的，但功能较少； 旗舰版 提供了较多的功能 # IntelliJ IDEA 官网：https://www.jetbrains.com/idea/ # 1. 打开官网 # 2. 选择终极版本，并下载安装程序 # 3. 下载之后双击，开始安装，点击 next # 4. 选择安装路径 # 5. 这里选择安装 64 位，点击 next # 6. 默认选择，点击 install # 7. 开始安装 # 8. 安装完成，勾选启动 # 9. 点击 OK # 10. 点击接受 # 11. 激活注册（打开激活网站：现用 http://idea.congm.in 可以激活） 或选择 Activation code，复制下方激活码到输入框 D87IQPUU3Q-eyJsaWNlbnNlSWQiOiJEODdJUVBVVTNRIiwibGljZW5zZWVOYW1lIjoiTnNzIEltIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDItMDcifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDItMDcifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wMi0wNyJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTAyLTA3In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDItMDcifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wMi0wNyJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTAyLTA3In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDItMDcifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wMi0wNyJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTAyLTA3In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTAyLTA3In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDItMDcifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wMi0wNyJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTAyLTA3In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDItMDcifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDItMDcifV0sImhhc2giOiI4MDI4NjgyLzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-iPLvfrIl0qTga/F9rnjf0Sz6yYvw+2FWgZpcLOFbvb3CllsE2ui4+bw8emxzcYr3GyxN4/4BhfcX6gmmI4EJaTSihP+m4Oa8jZApb5zGEHENJE+I8hewQWIyiekNE7+21meJ3swPCYiTWKkUXMIVUWNfieZhqHd96dHpD335dSRCmAImgQ31qpmzemMxztu1/FAIiaUrav1VU/M0waj9B9xuhDG77PU7deSxX363RQjbmRdWBorjH6gSyUpCXnyh6Crlhtj+lC+VndAdnT4HUXXsmpCw6uLotL5Gv/TM7/fAqIjSQghlnm4vpss4Pc7xI9n07KwQE9ok4fuF3HMRUA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 1 2 1 2 # 12. 注册完成之后选择主题，点击下一步 # 13. 这个界面是配置 idea 支持的功能 我们可以自行选择，因为如果使用它默认的有很多没用的插件，我们都用不着，会让你的 idea 特别卡，所以我们最好是按照自己的需求定制功能插件，首先我们点击 java Frameworks 下面的 Customize 来配置 Java 相关的 # 14. 点击 Customize 进入 # 15. 选择自己需要的，点击保存返回，继续选择其他的，都是以同样的方式点击 Customize 来配置 # 16. 这里选择构建工具 # 17. 配置 web 开放相关 # 18. 配置版本控制 # 19. 选择测试工具 # 20. 选择服务器 # 21. 选择云相关的 # 22. 如果想直接禁言某一个模块的所以功能插件，可以直接点击 Disable All # 23. 选择 UML # 24. 配置好之后点击 next，这里配置的功能，以后也可以修改，所以不用担心 # 25. 安装插件，以后再安装，点击开始使用 # 26. 启动界面，很炫 # 27. 这个界面就可以配置 # 28. 点击 Configure 下面的 Setting # 29. 这里是设置界面 根据自己需求配置，现在不配置也行，以后也可以再配置，这里我们不配置，点击下面的 Cancel 返回 # 30. 点击 Configure 下面的 Plugins 可以进入这个界面 这里就是前面配置的功能插件，在这里也可以配置，以后也可以配置，点击 Cancel 返回 # 31. 所有配置完成后，这里点击创建新项目 # 32. 选择 Java 项目就可以了 注意:java Enterprise 是 JavaEE 项目，我们先不管，先创建一个 Java 的简单项目，右边还要配置 JDK, 选择你 JDK 的安装目录 # 33. 点击 next # 34. 填上项目名和项目保存地址，点击完成 # 35. 点击 OK # 35. 双击 hello 这个项目就可以将项目展开 # 36. 在 src 下创建 package # 37. 在新建的 package 下面创建一个 class # 38. 这里你可以选择创建类，接口或者其他 # 39. 写上代码，右键运行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"}],"tags":[]},{"title":"Git安装教程","slug":"computer/app/Git安装教程","date":"2022-01-06T02:11:57.000Z","updated":"2023-11-30T09:56:16.687Z","comments":true,"path":"computer/app/Git安装教程/","link":"","permalink":"https://ppxpython.github.io/computer/app/Git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"Git 安装教程 # 获取 Git 安装程序 到 Git 官网下载，网站地址：https://git-scm.com/downloads，如下图： 因为我们是用 Windows 系统上的浏览器访问的，Git 官网自动之别到了我使用的操作系统，所以右侧直接显示下载使用 Windows 系统的最新版本（如果识别错误，可以在中间选择系统），点击即可下载。我下载的是 2.24.0 for Windows，文件名称是 “Git-2.24.0.2-64-bit.exe”。下载到电脑上之后，鼠标双击这个文件即可进入安装过程。 # Git 安装过程 双击看到的第一个界面如下图： # 01、使用许可声明 点击 “Next” 进入下图页面： # 02、选择安装路径 在输入框内输入想要安装到的本机路径，也就是实际文件夹位置，或点击 “Browse...” 选择已经存在的文件夹，然后点击 “Next” 按钮继续，进入下图界面： # 03、选择安装组件 上图红框内的选项是默认勾选的，建议不要动。绿色框 1 是决定是否在桌面创建快捷方式的。绿色框 2 是决定在所有控制台窗口中使用 TrueType 字体和是否每天检查 Git 是否有 Windows 更新的。这些根据自己需要选择。 点击 “Next” 按钮进入下图界面： # 04、选择开始菜单页 这个界面是创建开始菜单中的名称，不需要修改，直接点 “Next” 按钮继续到下图的界面： # 05、选择 Git 文件默认的编辑器 这个页面是在选择 Git 文件默认的编辑器，很少用到，所以默认 Vim 即可，直接点 “Next” 按钮继续到下图的界面： # 06、调整您的 PATH 环境 这个界面是调整您的 PATH 环境。 第一种配置是 “仅从 Git Bash 使用 Git”。这是最安全的选择，因为您的 PATH 根本不会被修改。您只能使用 Git Bash 的 Git 命令行工具。但是这将不能通过第三方软件使用。 第二种配置是 “从命令行以及第三方软件进行 Git”。该选项被认为是安全的，因为它仅向 PATH 添加了一些最小的 Git 包装器，以避免使用可选的 Unix 工具造成环境混乱。 您将能够从 Git Bash，命令提示符和 Windows PowerShell 以及在 PATH 中寻找 Git 的任何第三方软件中使用 Git。这也是推荐的选项。 第三种配置是 “从命令提示符使用 Git 和可选的 Unix 工具”。警告：这将覆盖 Windows 工具，如 “ find 和 sort ”。只有在了解其含义后才使用此选项。 我选择推荐的选项第二种配置，点击 “Next” 按钮继续到下图的界面： # 07、选择 HTTPS 后端传输 这个界面是选择 HTTPS 后端传输。 第一个选项是 “使用 OpenSSL 库”。服务器证书将使用 ca-bundle.crt 文件进行验证。这也是我们常用的选项。 第二个选项是 “使用本地 Windows 安全通道库”。服务器证书将使用 Windows 证书存储验证。此选项还允许您使用公司的内部根 CA 证书，例如通过 Active Directory Domain Services 。 我使用默认选项第一项，点击 “Next” 按钮继续到下图的界面： # 08、配置行尾符号转换 这个界面是配置行尾符号转换。 第一个选项是 “签出 Windows 风格，提交 Unix 风格的行尾”。签出文本文件时，Git 会将 LF 转换为 CRLF。提交文本文件时，CRLF 将转换为 LF。对于跨平台项目，这是 Windows 上的推荐设置（“ core.autocrlf” 设置为 “ true”） 第二个选项是 “按原样签出，提交 Unix 样式的行尾”。签出文本文件时，Git 不会执行任何转换。 提交文本文件时，CRLF 将转换为 LF。对于跨平台项目，这是 Unix 上的建议设置（“ core.autocrlf” 设置为 “ input”） 第三种选项是 “按原样签出，按原样提交”。当签出或提交文本文件时，Git 不会执行任何转换。不建议跨平台项目选择此选项（“ core.autocrlf” 设置为 “ false”） 我选择第一种选项，点击 “Next” 按钮继续到下图的界面： # 09、配置终端模拟器以与 Git Bash 一起使用 这个界面是配置终端模拟器以与 Git Bash 一起使用。 第一个选项是 “使用 MinTTY（MSYS2 的默认终端）”。Git Bash 将使用 MinTTY 作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选择和 Unicode 字体。Windows 控制台程序（例如交互式 Python）必须通过 “ winpty” 启动才能在 MinTTY 中运行。 第二个选项是 “使用 Windows 的默认控制台窗口”。Git 将使用 Windows 的默认控制台窗口（“cmd.exe”），该窗口可以与 Win32 控制台程序（如交互式 Python 或 node.js）一起使用，但默认的回滚非常有限，需要配置为使用 unicode 字体以正确显示非 ASCII 字符，并且在 Windows 10 之前，其窗口不能自由调整大小，并且只允许矩形文本选择。 我选择默认的第一种选项，点击 “Next” 按钮继续到下图的界面： # 10、配置配置额外的选项 这个界面是配置配置额外的选项。 第一个选项是 “启用文件系统缓存”。文件系统数据将被批量读取并缓存在内存中用于某些操作（“core.fscache” 设置为 “true”）。 这提供了显著的性能提升。 第二个选项是 “启用 Git 凭证管理器”。Windows 的 Git 凭证管理器为 Windows 提供安全的 Git 凭证存储，最显着的是对 Visual Studio Team Services 和 GitHub 的多因素身份验证支持。 （需要.NET Framework v4.5.1 或更高版本）。 第三个选项是 “启用符号链接”。启用符号链接（需要 SeCreateSymbolicLink 权限）。请注意，现有存储库不受此设置的影响。 我勾选默认的第一、第二选项，点击 “Next” 按钮继续到下图的界面： # 11、配置实验选项 这个界面是配置实验选项。 启用实验性的内置添加 -i /-p。（新！）使用实验性的内置交互式 add（“git add -i” 或 “ git add -p”）。这使其速度更快（尤其是启动！），但尚未被认为是可靠的。 默认不勾选，直接点击 “Next” 按钮继续到下图的安装进度界面： # 12、安装进度指示 安装进度结束之后，会出现下图的完成 Git 安装向导界面： # 13、安装完成 在这个界面，可以勾选是否启动启动 Git Bash 和是否查看发行说明，然后点 “Finish” 按钮退出安装界面。 # 14、启动测试 到此，Git 的安装完成，可以在开始菜单中看到 Git 的三个启动图标（Git Bash、Git CMD (Deprecated)、Git GUI）。 Git Bash，是 Git 配套的一个控制台，点击打开如下图： Git CMD (Deprecated)，是通过 CMD 使用 Git（不推荐使用），点击打开如下图： Git GUI，是 Git 的可视化操作工具，点击打开如下图： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"}],"tags":[]},{"title":"cmder使用配置教程","slug":"computer/app/cmder使用配置教程","date":"2022-01-06T02:10:56.000Z","updated":"2023-11-30T09:56:16.687Z","comments":true,"path":"computer/app/cmder使用配置教程/","link":"","permalink":"https://ppxpython.github.io/computer/app/cmder%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"cmder 使用配置教程 # 1. 安装 Cmder 打开 Cmder 官网（ https://cmder.net ），下拉页面找到 Download 项选择下载，下载的时候，两个版本，分别是 mini 与 full 版；唯一的差别在于有没有内建 git-for-windows 工具，这是 Git for Windows 的标准配备；全安装版 Cmder 自带了 msysgit，除了 git 本身这个命令之外， cmder 完全支持 Linux 命令行，里面可以使用大量的 linux 命令，比如 grep、curl (没有 wget)、vim、grep、tar、unzip、ssh、ls、bash、perl 等，而且可以多开，快捷键复制粘贴，分屏等，功能非常强大 这里选择 full 版本点击下载。下载的是 Cmder 的压缩包，解压即可以使用。 # 启动 Cmder Cmder 解压后，双击 Cmder.exe 即可运行。 如果每次都进入到 Cmder 解压目录双击 Cmder.exe 打开的方式很麻烦，可以使用下面几种方式很好的解决问题； 1、 把 Cmder 加到环境变量 。把 Cmder.exe 存放的目录添加到系统环境变量；加完之后，win+r 然后输入 cmder 即可。 2、 添加 cmder 到右键菜单。 添加后在任意文件夹中即可打开 Cmder，上一步的把 Cmder 加到环境变量就是为此服务的，在管理员权限的终端输入以下语句即可: Cmder.exe /REGISTER ALL 3、 为 Cmder.exe 创建快捷方式 ，右击 Cmder.exe 选择 \"创建快捷方式\" 点击即可，或者把创建的 ** 快捷方式 放到 ** C:\\Windows\\System32， 加完之后，win+r 然后输入 cmder 即可。 # Cmder 常用功能介绍 cmder 功能极为强大，这里就先说下常用的功能： 1. Cmder 常用快捷键 tab 自动路径补全； ctrl + t 建立新页签；ctrl + w 关闭页签;ctrl + tab 切换页签;ctrl + 1 快速切换到第1个页签ctrl + n 快速切换到第n个页签( n值无上限)alt + F4 关闭所有页签 ctr + r 历史命令搜索alt + enter 切换到全屏状态 alt + shift + 1 开启 cmd.exealt + shift + 2 开启 powershell.exealt + Shift + 3 开启 powershell.exe (系统管理员权限) 可在 视窗内 搜寻 画面上 出现过的任意关键字。 新增 页签 按钮。 切换 页签 按钮。 锁定 视窗 ，让视窗无法再输入。 切换 视窗 是否提供卷轴功能，启动时可查询之前显示过的内容。 按下滑鼠左键可开启系统选单，滑鼠右键可开启工具选项视窗。 Win+Alt+P ：开启 工具选项 视窗 cmder 分屏功能： ctrl + t 或者 点击 右下角 + 号 分屏功能 快捷键 设置： # Cmder 进阶功能 Cmder 增加了 alias 功能：可以给 超长又难以记忆的指令 起一个 别名 ， 输入 **alias ** 可以查看已有的 别名 。打开安装目录 config/user-aliases.cmd 文件，直接修改。自定义 aliases：打开 Cmder 目录下的 config 文件夹，里面的 aliases 文件就是我们可以配置的别名文件，直接修改。 这里将 ls 命令的别名按下列方式修改，添加至文件末尾，就可以在 ls 命令下显示中文，同时增强命令并添加颜色区分。 l=ls --show-control-chars la=ls -aF --show-control-chars ll=ls -alF --show-control-chars ls=ls --show-control-chars -F 主控台文字自动放大缩小功能，只要按下 Ctrl + 滑鼠滚轮 就可以办到，还有 up 向上翻历史命令。 鼠标选中自动复制到剪切板。直接 鼠标右键 即可 粘贴，或者使用 Ctrl + v 进行粘贴。 # 2. Cmder 设置 右下角 的 三杠 ，然后选择 **Settings ** ，或者 使用快捷键 Windows+Alt+p 打开 设置 # 解决文字重叠 ： Win + ALT + P 打开设置界面 monospce，去掉勾勾即可。 # 设置编码，解决中文乱码 ** 设置：set LC_ALL=zh_CN.UTF-8 ** 或者 set LANG=zh_CN.UTF-8 查看 git log 时乱码 在 Startup ---&gt; Environment 中添加下面的语句： set LANG=zh_CN.UTF-8 然后执行下面的命令，来配置 git log 的输出 git config --global i18n.logoutputencoding utf-8 或者在 .gitconfig 文件中配置 更多乱码问题见： cmder 中文乱码 - CSDN 博客 设置中文界面 ： 选择 **General ** ---&gt; Interface language ---&gt; zh: 简体中文 # 设置为默认终端 setting ---&gt; 集成 ---&gt; 默认终端 ---&gt; 强制使用 ConEmu 作为控制台应用程序的默认终端。如果允许某些程序出现错误，需要关闭此选项；比如 mkcert。 图中绿色设置可以强制将 cmder 注册成 Windows 的默认终端 设置此选项后，系统启动后就会生效，且，即使你打开的是 cmd，也会被放到 cmder 的窗口中执行 红色选项可以解决每次关闭控制台时，弹出确认关闭的弹窗 窗口位置大小记忆 ：勾选这两个设置，只需要设置一次，下次会自动记住上次终端在桌面出现的位置和窗口大小 # 设置 vi 模式下 ESC 键最小化窗口的问题 将图中红色改成除了总是的其他选项，否则使用 vi 时会出现无法切换模式的问题 勾选绿色的选项可以解决打开多个终端，任务栏显示多个窗口的问题 # 解决粘贴多行文本时的弹窗 例如在终端中执行多行 SQL 语句，总会弹出提示，勾选选项可以解决 # 将命令提示改成 $ 默认的命令提示符是 λ, 大家都知道 Linux 是 $，这里提供一下修改的方法，并不是必须的 首先在 cmder 的安装目录下，找到 vendor / 目录，然后找到 clink.lua 文件 打开后可以 Ctrl+F 查找下面的字段 local lambda = 将 local lambda =\"\" 的值替换成 $ 可以修改文件 ${CMDER_HOME}\\vendor\\clink.lua if env == nil then lambda = \"λ\" else lambda = \"(\"..env..\") λ\" end改成 if env == nil then lambda = \"$\" else lambda = \"(\"..env..\") $\" end # 将 Idea 的 Terminal 终端换成 cmder 在 idea 中打开其他设置界面，在 idea 中 settings 是对当前项目生效，Other Settings 是对所有项目生效 修改 shell Path 的路径，替换成下面的内容 注意将 cmder 安装目录换成你的安装目录 //这种方式比较可靠，避免了环境变量失效的问题\"cmd.exe\" /k \"\"你的cmder安装目录\\vendor\\init.bat\"\" //或者，这个需要有环境变量\"cmd.exe\" /k \"\"%环境变量配置的cmder home目录名称%\\vendor\\init.bat\"\" 再次打开 Terminal 终端就可以使用 Linux 命令了 # 将 vscode 的 Terminal 终端设置成 cmder 1) 打开设置 搜索 code save, 点击打开设置 json 文件 3) 将下面的代码粘贴到文件中，修改为自己需要的内容。注意：修改 cmder 的安装目录为自己的安装目录 // 设置终端为cmder\"terminal.integrated.shell.windows\": \"cmd.exe\",\"terminal.integrated.env.windows\": { //设置cmder的根目录 \"CMDER_ROOT\": \"cmder的根目录\" }, \"terminal.integrated.shellArgs.windows\": [ \"/k\", //设置启动初始化目录 \"cmder的根目录\\\\vendor\\\\init.bat\" ], //下面的设置可以不需要 //终端颜色配置 \"workbench.colorCustomizations\": { //可以将鼠标放到下面的色号上根据自己的偏好进行选择 \"terminal.foreground\": \"#37FF13\", \"terminal.background\": \"#2b2424\" }, \"terminal.integrated.cursorBlinking\": true, //设置terminal中的行高 \"terminal.integrated.lineHeight\": 1.1, \"terminal.integrated.letterSpacing\": 0.1, \"terminal.integrated.fontSize\": 12, //字体大小设置 \"terminal.integrated.fontFamily\": \"monaco\", //字体设置 \"terminal.integrated.shell.linux\": \"/bin/zsh\" Ctrl+J 打开终端，就可以使用了 # Cmder 启动选项 默认选择的启动项应该是 {cmd::Cmder} 这个命名任务，我们可以更改成其它的命令任务或者直接切换到其它的启动项。 默认的是 cmd，这里演示设置 PowerShell 的方法。也可使 设置 默认使用 bash，这个看个人需求。 # 自定义启动目录 下面就来克隆现有的 {cmd::Cmder} 添加一个设置自定义的启动目录的任务 (Task)： 任务参数：下面来看 \"Task parameters\" 命令参数，阅读实例可知参数 /icon 指定图标位置，/dir 指定启动目录，所以我们可以添加下面的参数：/icon \"% CMDER_ROOT%\\icons\\cmder.ico\" /dir \"C:\\Users\\Fan\" 记得在 startup 的 \"Specified named task\" 处选择 cmd::diy1 保存设置，退出，重新打开 cmder 查看效果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"}],"tags":[]},{"title":"win10上安装 Emscripten 安装","slug":"computer/app/win10上安装-Emscripten-安装","date":"2022-01-06T02:09:18.000Z","updated":"2023-11-30T09:56:16.691Z","comments":true,"path":"computer/app/win10上安装-Emscripten-安装/","link":"","permalink":"https://ppxpython.github.io/computer/app/win10%E4%B8%8A%E5%AE%89%E8%A3%85-Emscripten-%E5%AE%89%E8%A3%85/","excerpt":"","text":"背景 WebAssembly 的出现为 Web 开发者打开了一扇新的大门 。在去年，wasm 对你来说也许还仅是技术文章中的一个常见名词，你压根想不到他会在浏览器中得到怎样的应用，什么时候会被大公司真正用起来。 在今年，你很有可能已在不知不觉中成为 wasm 的使用者了 。目前国内外越来越多的团队基于 wasm 进行了业务实践 一、Emscripten 是什么？ Emscripten 编译器，是 WebAssembly 开发的重要工具之一，主要是通过 emcc（Emscripten Compiler Frontend）来工作的。这是个命令行工 二、安装步骤 1. 环境准备 git 2.32.0 python 3.7 2. 安装 创建文件夹 python mkdir d:\\WebAssemblyTestmkdir 进入目录🧐 python cd WebAssemblyTestmkdir\\ Emscripten 环境安装 python git clone https://github.com/emscripten-core/emsdk.git python cd emsdk 安装最新根据包 python emsdk install latest 激活 sdk python emsdk activate latest 执行环境变量 python emsdk_env.bat 安装完成 测试一下 python emcc -v 开始 helloworld 创建个文件夹 创建 hello_world.c 文件内容如下🧐 python #include &lt;stdio.h&gt; int main(int argc, char ** argv) { printf(\"Hello World\\n\"); } 运行一下 emcc 执行 c 文件路径 -s WASM=1 -o 目标文件名.html python emcc hello_world.c -s WASM=1 -o hello_world.html 文件 c 变成 启动 http 服务命令 python emrun --no_browser --port 8080 hello_world.html 访问网址🧐 http://localhost:8080/hello_world.html 参考链接 (19 条消息) Windows10 中 Emscripten 安装详解_cnds123 的专栏 - CSDN 博客_emscripten 安装 开发者引导 - WebAssembly 中文网 | Wasm 中文文档 在 Windows10 搭建 WebAssembly 开发环境 - kunger - 博客园 (cnblogs.com) 2021 年大前端技术趋势解读 - InfoQ win10 上安装 Emscripten 安装 背景 WebAssembly 的出现为 Web 开发者打开了一扇新的大门 。在去年，wasm 对你来说也许还仅是技术文章中的一个常见名词，你压根想不到他会在浏览器中得到怎样的应用，什么时候会被大公司真正用起来。 在今年，你很有可能已在不知不觉中成为 wasm 的使用者了 。目前国内外越来越多的团队基于 wasm 进行了业务实践 一、Emscripten 是什么？ Emscripten 编译器，是 WebAssembly 开发的重要工具之一，主要是通过 emcc（Emscripten Compiler Frontend）来工作的。这是个命令行工 二、安装步骤 1. 环境准备 git 2.32.0 python 3.7 2. 安装 创建文件夹 python mkdir d:\\WebAssemblyTestmkdir 进入目录🧐 python cd WebAssemblyTestmkdir\\ Emscripten 环境安装 python git clone https://github.com/emscripten-core/emsdk.git python cd emsdk 安装最新根据包 python emsdk install latest 激活 sdk python emsdk activate latest 执行环境变量 python emsdk_env.bat 安装完成 测试一下 python emcc -v 开始 helloworld 创建个文件夹 创建 hello_world.c 文件内容如下🧐 python #include &lt;stdio.h&gt; int main(int argc, char ** argv) { printf(\"Hello World\\n\"); } 运行一下 emcc 执行 c 文件路径 -s WASM=1 -o 目标文件名.html python emcc hello_world.c -s WASM=1 -o hello_world.html 文件 c 变成 启动 http 服务命令 python emrun --no_browser --port 8080 hello_world.html 访问网址🧐 http://localhost:8080/hello_world.html 参考链接 (19 条消息) Windows10 中 Emscripten 安装详解_cnds123 的专栏 - CSDN 博客_emscripten 安装 开发者引导 - WebAssembly 中文网 | Wasm 中文文档 在 Windows10 搭建 WebAssembly 开发环境 - kunger - 博客园 (cnblogs.com) 2021 年大前端技术趋势解读 - InfoQ win10 上安装 Emscripten 安装 背景 WebAssembly 的出现为 Web 开发者打开了一扇新的大门 。在去年，wasm 对你来说也许还仅是技术文章中的一个常见名词，你压根想不到他会在浏览器中得到怎样的应用，什么时候会被大公司真正用起来。 在今年，你很有可能已在不知不觉中成为 wasm 的使用者了 。目前国内外越来越多的团队基于 wasm 进行了业务实践 一、Emscripten 是什么？ Emscripten 编译器，是 WebAssembly 开发的重要工具之一，主要是通过 emcc（Emscripten Compiler Frontend）来工作的。这是个命令行工 二、安装步骤 1. 环境准备 git 2.32.0 python 3.7 2. 安装 创建文件夹 python mkdir d:\\WebAssemblyTestmkdir 进入目录🧐 python cd WebAssemblyTestmkdir\\ Emscripten 环境安装 python git clone https://github.com/emscripten-core/emsdk.git python cd emsdk 安装最新根据包 python emsdk install latest 激活 sdk python emsdk activate latest 执行环境变量 python emsdk_env.bat 安装完成 测试一下 python emcc -v 开始 helloworld 创建个文件夹 创建 hello_world.c 文件内容如下🧐 python #include &lt;stdio.h&gt; int main(int argc, char ** argv) { printf(\"Hello World\\n\"); } 运行一下 emcc 执行 c 文件路径 -s WASM=1 -o 目标文件名.html python emcc hello_world.c -s WASM=1 -o hello_world.html 文件 c 变成 启动 http 服务命令 python emrun --no_browser --port 8080 hello_world.html 访问网址🧐 http://localhost:8080/hello_world.html 参考链接 (19 条消息) Windows10 中 Emscripten 安装详解_cnds123 的专栏 - CSDN 博客_emscripten 安装 开发者引导 - WebAssembly 中文网 | Wasm 中文文档 在 Windows10 搭建 WebAssembly 开发环境 - kunger - 博客园 (cnblogs.com) 2021 年大前端技术趋势解读 - InfoQ win10 上安装 Emscripten 安装 背景 WebAssembly 的出现为 Web 开发者打开了一扇新的大门 。在去年，wasm 对你来说也许还仅是技术文章中的一个常见名词，你压根想不到他会在浏览器中得到怎样的应用，什么时候会被大公司真正用起来。 在今年，你很有可能已在不知不觉中成为 wasm 的使用者了 。目前国内外越来越多的团队基于 wasm 进行了业务实践 一、Emscripten 是什么？ Emscripten 编译器，是 WebAssembly 开发的重要工具之一，主要是通过 emcc（Emscripten Compiler Frontend）来工作的。这是个命令行工 二、安装步骤 1. 环境准备 git 2.32.0 python 3.7 2. 安装 创建文件夹 python mkdir d:\\WebAssemblyTestmkdir 进入目录🧐 python cd WebAssemblyTestmkdir\\ Emscripten 环境安装 python git clone https://github.com/emscripten-core/emsdk.git python cd emsdk 安装最新根据包 python emsdk install latest 激活 sdk python emsdk activate latest 执行环境变量 python emsdk_env.bat 安装完成 测试一下 python emcc -v 开始 helloworld 创建个文件夹 创建 hello_world.c 文件内容如下🧐 python #include &lt;stdio.h&gt; int main(int argc, char ** argv) { printf(\"Hello World\\n\"); } 运行一下 emcc 执行 c 文件路径 -s WASM=1 -o 目标文件名.html python emcc hello_world.c -s WASM=1 -o hello_world.html 文件 c 变成 启动 http 服务命令 python emrun --no_browser --port 8080 hello_world.html 访问网址🧐 http://localhost:8080/hello_world.html 参考链接 (19 条消息) Windows10 中 Emscripten 安装详解_cnds123 的专栏 - CSDN 博客_emscripten 安装 开发者引导 - WebAssembly 中文网 | Wasm 中文文档 在 Windows10 搭建 WebAssembly 开发环境 - kunger - 博客园 (cnblogs.com) 2021 年大前端技术趋势解读 - InfoQ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"}],"tags":[]},{"title":"MAC地址和IP地址的联系","slug":"computer/basics/networking/MAC地址和IP地址的联系","date":"2022-01-06T02:03:10.000Z","updated":"2023-11-30T09:56:16.691Z","comments":true,"path":"computer/basics/networking/MAC地址和IP地址的联系/","link":"","permalink":"https://ppxpython.github.io/computer/basics/networking/MAC%E5%9C%B0%E5%9D%80%E5%92%8CIP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%81%94%E7%B3%BB/","excerpt":"","text":"一、IP 地址 对于 IP 地址，相信大家都很熟悉，即指使用 TCP/IP 协议指定给主机的 32 位地址。IP 地址由用点分隔开的 4 个 8 八位组构成，如 192.168.0.1 就是一个 IP 地址，这种写法叫点分十进制格式。IP 地址由网络地址和主机地址两部分组成，分配给这两部分的位数随地址类（A 类、B 类、C 类等）的不同而不同。网络地址用于路由选择，而主机地址用于在网络或子网内部寻找一个单独的主机。一个 IP 地址使得将来自源地址的数据通过路由而传送到目的地址变为可能。 二、MAC 地址 对于 MAC 地址，由于我们不直接和它接触，所以大家不一定很熟悉。在 OSI（Open System Interconnection，开放系统互连）7 层网络协议（物理层，数据链路层，网络层，传输层，会话层，表示层，应用层）参考模型中，第二层为数据链路层（Data Link）。它包含两个子层，上一层是逻辑链路控制（LLC：Logical Link Control），下一层即是我们前面所提到的 MAC（Media Access Control）层，即介质访问控制层。所谓介质（Media），是指传输信号所通过的多种物理环境。常用网络介质包括电缆（如：双绞线，同轴电缆，光纤），还有微波、激光、红外线等，有时也称介质为物理介质。MAC 地址也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。这个地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，它都有相同的 MAC 地址，MAC 地址一般不可改变，不能由用户自己设定。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"计算机基础","slug":"computer/计算机基础","permalink":"https://ppxpython.github.io/categories/computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"网络基础","slug":"computer/计算机基础/networking","permalink":"https://ppxpython.github.io/categories/computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/networking/"}],"tags":[]},{"title":"shell学习","slug":"shell学习","date":"2022-01-05T09:12:55.000Z","updated":"2023-11-30T09:56:16.709Z","comments":true,"path":"shell学习/","link":"","permalink":"https://ppxpython.github.io/shell%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"# linux 基础 # 冯诺依曼体系结构 硬件，软件体系 # 运算器 # 控制器 # 存储器 # 输入设备 # 输出设备 内存：容量小，效率高，运行效率快，快速集成数据 硬盘：容量大，运行速度慢 # 硬盘的分类 所有的形式都是以二进制存取的 # 读取方式 1 个扇区 4kb, 等大 # shell 注意: 参数之间用空格隔开 区分大小写 # 常见命令: # 特殊字符 # . 指向 y 隐藏文件，当前目录 # .. 上一层目录 # $ 变量 通配符，所有 # ~ 家目录 超级管理员 root/ # / 目录 # - 参数 -- 参数 - 简写 -- 单词 # 文件系统 因为每个用户项目分区不一样 没有盘符：采用树 当存储空间不够的时候采用文件挂载增加内存，理论值：可挂在 65536 个硬盘 扩容 mount 挂载 bin 可执行文件，脚本 boot 引导分区 dev 设备信息 etc 配置文件 home 家 lib 内库 lib64 media 多媒体 mnt 硬盘挂载 U 盘 opt 默认安装目录 proc 进程信息 root 管理员家目录 run 运行时的系统常量，变量 sbin 管理员可执行的权限和命令 srv 服务启动之后需要提取额数据 sys 系统内核信息 tmp 临时存放信息，变量，重启后可能会清除 usr 共享文件 var 临时存放信息，变量，重启不清除 eg: 日志 # cd 改变文件路径 # ll 显示目录 # ls 显示目录 中 - 开头表示文件 d 开头表示文件夹 l 开头表示链接 [win 中叫快捷方式] # mkdir 创建目录 -p 创建多级目录 mkdir -p a mkdir -p haoduo {test1,test2,test3} 创建多个文件夹 {}: 类似 java 中数组的含义 # rmdir 删除目录 rmdir 要求文件时空文件夹 # cp 复制文件 cp 源文件 目标文件 -r 文件夹，目录时 # mv 文件和目录移动和改名 文件和目录 # rm 删除 -f 强制删除 -r 文件夹 # touch 创建文件 # stat 查看文件信息 # ln 链接 快捷方式 -s 软链接 # cat 查看内容 # tac 查看内容倒序 # more,less 查看内容分页 # head 查看取前几行 显示某一行 head -8 | tail -1 # tail 查看取后几行 -f -F 显示追加内容，监控到数据变动 # find 搜索文件 find / 表示全局搜索 -name 文件名 用法 find [命令选项] [路径] [表达式选项] 选项 选项 用法 - empty 查找空白文件或目录 - group 按组查找 - name 按文档名称查找 - iname 按文档名称查找，且不区分大小写 - mtime 按修改时间查找 - size 按容量大小查找 - type 按文档类型查找，文件（f）、目录 (d)、设备 (b，c)、链接 (l) 等 - user 按用户查找 - exec 对找到的档案执行特定的命令 - a 并且 - o 或者 举例 查找当前目录下名称为 hello.txt 的文档 [root@test ~]# find -name hello.txt 1 查找 /root 目录下所有名称以.log 结尾的文件 [root@test ~]# find /var/log/ -name \"*.log\" 1 不区分大小写查找文件 test [root@test ~]# find -iname \"test\" 1 查找系统中所有的空白文件 [root@test ~]# find / -empty 1 查找系统中所属组为 tom 的文件 [root@test ~]# find / -group tom 1 查找系统中所有 3 天内被修改过的文件 [root@test ~]# find / -mtime -3 1 查找系统中所有 4 天前被修改过的文件 [root@test ~]# find / -mtime +4 1 查找系统中 2 天前的当天被修改过的文件 [root@test ~]# find / -mtime 2 1 查找当前目录下大于 10MB 的文件 [root@test ~]# find ./ -size +10M 1 查找当前目录下的所有普通文件 [root@test ~]# find ./ -type f 1 查找计算中 tom 所拥有的所有文件 [root@test ~]# find / -user tom 1 查找当前目录下大于 1MB 的文件后列出文件的详细信息 [root@test ~]# find ./ -size +1M -exec ls -l {} ; 1 查找计算机中所有大于 1MB 的文件 [root@test ~]# find / -size +1M -a -type f 1 # sort 排序文件列表输出 语法：sort (选项)(参数) 1 选项： -b：忽略每行前面开始出的空格字符； -c：检查文件是否已经按照顺序排序； -d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； -f：排序时，将小写字母视为大写字母； -i：排序时，除了 040 至 176 之间的 ASCII 字符外，忽略其他的字符； -m：将几个排序号的文件进行合并； -M：将前面 3 个字母依照月份的缩写进行排序； -n：依照数值的大小排序； -o &lt;输出文件&gt;：将排序后的结果存入制定的文件； -r：以相反的顺序来排序； -t &lt;分隔字符&gt;：指定排序时所用的栏位分隔字符； +&lt;起始栏位&gt;-&lt; 结束栏位 &gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 -u 去重 # vi 编辑 # 打开文件 # 编辑模式 常用的 15gg: 进入第 15 行 shift+G 最后一行 dd 删除一行 3dd 删除 3 行 w 光标单词移动 dw 将后面的单词删除 3dw 删除后面 3 个单词 yy 复制 pp 粘贴 yw 复制一个单词 yp 粘贴一个单词 u 撤销 shift+6 行首 shift+4 行尾 shift ZZ r 替换 # 末行模式 wq 保存并退出 wq! w 保存 q 退出 q! 不保存退出 set nu 显示行数 / 关键字 查找 s / 关键字 / 替换字 /g 加了 g 后当前行全部替换 g / 关键字 / 替换字 /g vi 编写时间经常出现🧐 直接删除 # 计算机间数据传输 # rz 上传 # sz 下载 创建虚拟机后如何修改🧐 root 登录 hostname 名字 修改主机名 vi /etc/hostname 主机名 vi /etc/sysconfig/network-scripts/ifcfg-eth0 中修改 IPADDR=172.17.20.145IP 地址 systemtcl restart 重启 # scp 传递文件 # df 分区信息 -h 包含单位 # du 指定文件大小 du -h --max-depth=1 / # tar 解压和压缩 tar -zxvf Python-3.7.1 zx 解压 zc 压缩 v 过程 f 文件 tar -zcf 目标文件名 需要压缩文件 dir.tar.gz dir # zip 压缩 zip -r dir.zip dir # unzip 解压 unzip dir.zip # 网络相关 # ifconfig 网卡配置信息 # netstat 网络状态 端口 22: 默认 ssh 访问接口 -anp -r 核心路由表 = 命令 route # ping 地址连通 # telnet 端口联通 # curl 获取信息 curl -X GET http://www.baidu.com # 防火墙 发现 centos 使用 service 命令替代 systemctl 如启动服务 service httpd start 查看 httpd 服务状态 service httpd status # 日期和时间 # date 查看当前时间 集群时间同步策略 ntp # ntpdate 集群同步时间 cn.ntp.org.cn # 用户 - 组 - 权限 # useradd 添加用户 # passwd 修改用户密码 # userdel 删除用户 -r # su 切换用户 # groupadd 创建组 # groups 查看组 # groupdel 删除组 # groupmod -n 修改组 # 权限 r 读 x 执行 w 写 3 组 所属用户 所属组 其他 修改权限 chown 用户 文件 # 管道 | ps netstat -anp | grep 22 # | 管道 # A 重定向 # &gt; 替换 # 012 文件描述符 1 是标准输出（stdout） 2 是标准错误输出（stderr） 0 是标准输入（stdin） 1&gt; 两个符号连着一起，而且呢，1 和 &gt; 符号之间不能有空格 # &gt;&gt; 追加 # 进程 ps -ef uid: 用户 id pid: 进程 id ppid: 副进程 id # ps -ef 查看进程 linux 上进程有 5 种状态: 运行 (正在运行或在运行队列中等待) 中断 (休眠中，受阻，在等待某个条件的形成或接受到信号) 不可中断 (收到信号不唤醒和不可运行，进程必须等待直到有中断发生) 僵死 (进程已终止，但进程描述符存在，直到父进程调用 wait4 () 系统调用后释放) 停止 (进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行) 1）ps a 显示现行终端机下的所有程序，包括其他用户的程序。 2）ps -A 显示所有程序。 3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 4）ps -e 此参数的效果和指定 \"A\" 参数相同。 5）ps e 列出程序时，显示每个程序所使用的环境变量。 6）ps f 用 ASCII 字符显示树状结构，表达程序间的相互关系。 7）ps -H 显示树状结构，表示程序间的相互关系。 8）ps -N 显示所有的程序，除了执行 ps 指令终端机下的程序之外。 9）ps s 采用程序信号的格式显示程序状况。 10）ps S 列出程序时，包括已中断的子程序资料。 11）ps -t &lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。 12）ps u 以用户为主的格式来显示程序状况。 13）ps x 显示所有程序，不以终端机来区分。 14）ps -l 較長，較詳細的顯示該 PID 的信息 # jobs -l 查看后台进程 # nohup 防止进程被挂起 # kill 杀死进程 # 环境变量 # top 进程变化 cpu 负载情况 top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下： &lt;br /&gt; s – 改变画面更新频率 &lt;br /&gt; l – 关闭或开启第一部分第一行 top 信息的表示 &lt;br /&gt; t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示 &lt;br /&gt; m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示 &lt;br /&gt; N – 以 PID 的大小的顺序排列表示进程列表 &lt;br /&gt; P – 以 CPU 占用率大小的顺序排列进程列表 &lt;br /&gt; M – 以内存占用率大小的顺序排列进程列表 &lt;br /&gt; h – 显示帮助 &lt;br /&gt; n – 设置在进程列表所显示进程的数量 &lt;br /&gt; q – 退出 top &lt;br /&gt; s – 改变画面更新周期 序号 列名 含义 &lt;br /&gt; PID 进程 id &lt;br /&gt; PPID 父进程 id &lt;br /&gt; RUSER Real user name &lt;br /&gt; UID 进程所有者的用户 id &lt;br /&gt; USER 进程所有者的用户名 &lt;br /&gt; GROUP 进程所有者的组名 &lt;br /&gt; TTY 启动进程的终端名。不是从终端启动的进程则显示为？ &lt;br /&gt; PR 优先级 &lt;br /&gt; NI nice 值。负值表示高优先级，正值表示低优先级 0 &lt;br /&gt; P 最后使用的 CPU，仅在多 CPU 环境下有意义 &lt;br /&gt; % CPU 上次更新到现在的 CPU 时间占用百分比 &lt;br /&gt; TIME 进程使用的 CPU 时间总计，单位秒 &lt;br /&gt; TIME+ 进程使用的 CPU 时间总计，单位 1/100 秒 &lt;br /&gt; % MEM 进程使用的物理内存百分比 &lt;br /&gt; VIRT 进程使用的虚拟内存总量，单位 kb。VIRT=SWAP+RES &lt;br /&gt; SWAP 进程使用的虚拟内存中，被换出的大小，单位 kb。 &lt;br /&gt; RES 进程使用的、未被换出的物理内存大小，单位 kb。RES=CODE+DATA &lt;br /&gt; CODE 可执行代码占用的物理内存大小，单位 kb &lt;br /&gt; DATA 可执行代码以外的部分 (数据段 + 栈) 占用的物理内存大小，单位 kb &lt;br /&gt; SHR 共享内存大小，单位 kb &lt;br /&gt; nFLT 页面错误次数 &lt;br /&gt; nDRT 最后一次写入到现在，被修改过的页面数。 &lt;br /&gt; S 进程状态。（D = 不可中断的睡眠状态，R = 运行，S = 睡眠，T = 跟踪 / 停止，Z = 僵尸进程） &lt;br /&gt; COMMAND 命令名 / 命令行 &lt;br /&gt; WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 &lt;br /&gt; Flags 任务标志，参考 sched.h 默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、% CPU、% MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。 通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。 &lt;br /&gt; 按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。 &lt;br /&gt; 按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。 top 使用方法： 使用格式： top [-] [d] [p] [q] [c] [C] [S] [s] [n] &lt;br /&gt; 参数说明： d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用 s 交互命令来改变之。 p: 通过指定监控进程 ID 来仅仅监控某个进程的状态。 q: 该选项将使 top 没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么 top 将以尽可能高的优先级运行。 S：指定累计模式。 s：使 top 命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 i：使 top 不显示任何闲置或者僵死进程。 c: 显示整个命令行而不只是显示命令名。 常用命令说明： Ctrl+L：擦除并且重写屏幕 &lt;br /&gt; K：终止一个进程。系统将提示用户输入需要终止的进程 PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用 15 信号；如果不能正常结束那就使用信号 9 强制结束该进程。默认值是信号 15。在安全模式中此命令被屏蔽。 i：忽略闲置和僵死进程。这是一个开关式命令。 q：退出程序 r: 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程 PID 以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是 10。 S：切换到累计模式。 s：改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为 s。如果有小数，就换算成 m s。输入 0 值则系统将不断刷新，默认值是 5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 f 或者 F：从当前显示中添加或者删除项目。 &lt;br /&gt; o 或者 O：改变显示项目的顺序 &lt;br /&gt; l：切换显示平均负载和启动时间信息。 &lt;br /&gt; m: 切换显示内存信息。 t: 切换显示进程和 CPU 状态信息。 c: 切换显示命令名称和完整命令行。 M: 根据驻留内存大小进行排序。 P: 根据 CPU 使用百分比大小进行排序。 T: 根据时间 / 累计时间进行排序。 W: 将当前设置写入～/.toprc 文件中。 ** 查看多核 CPU 命令 &lt;br /&gt; **mpstat -P ALL 和 sar -P ALL # curl 请求接口 curl 是非常方便的 Rest 客户端，可以很方便的完成 Rest API 测试，利用 curl 对 http 协议发送 Get/Post/Delete/Put, 同时还可以携带 header 来满足 Rest API 需求的特定条件 curl 常用的参数 -X/--request [GET|POST|PUT|DELETE|…] 使用指定的 http method 发出 http request -H/--header 设定 request 里的 header -i/--include 显示 response 的 header -d/--data 设定 http parameters -v/--verbose 輸出比较多的信息 -u/--user 使用者账号 -b/--cookie cookie 文件路径 使用 cookie linux command line 的参数，同一个功能常会有两个完全相同的参数，一个是比较短的参数，另一个是比较长的参数 1、测试 get 请求 $ curl http://www.linuxidc.com/login.cgi?user=test001&amp;password=123456 2、测试 post 请求 $ curl -d \"user=nickwolfe&amp;password=12345\" http://www.linuxidc.com/login.cgi 方式一：发送磁盘上面的 xml 文件（推荐） root [ /apps ]$ curl -X POST -H 'content-type: application/xml' -d @/apps/myxmlfile.txt http://172.19.219.xx:8081/csp/faq/actDiaUserInfo.action ps：其中 myxmlfile.txt 为磁盘上面的 xml 文件，后面为请求路径 方式二：在命令行直接发送 xml 结构数据 root [ /apps ]$ curl -H 'content-type: application/xml' -X POST -d ' &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;userinfoReq&gt;``&lt;subsNumber&gt; 13814528620 &lt;/subsNumber&gt;&lt;type&gt; 3 &lt;/type&gt;&lt;/userinfoReq&gt; ' http://172.19.219.xx:8081/csp/faq/actDiaUserInfo.action 或者 root [ /apps ]$ echo ' &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;userinfoReq&gt;``&lt;subsNumber&gt; https://www.ekwing.com/home/classtop?class=443 https://www.ekwing.com/home/cityhw 请求 URL: https://passport.ekwing.com/index/getschooluser?callback=jQuery17208287960962547929_1634277562968&amp;uname = 翼小小 1&amp;pw=jSB5rGAv2seFjniqPD1Ic7AoGk9a6QfPMyvwJvDYjVxwaNDwY7cMhTV9Z90CSNUgdc2SGJ5cfRk9R0V0UUgNJc%2BQh9Ch90mZ%2BSUx8czho2gAU%2B9Qg6wFCYoKai3uhZ7UtT3MylPxytzccEQnpNAeaylQrqDGMrbJaRDD%2FwAu2Qc%3D&amp;encrypt_key=407ac0f7864098ba320af44dc0f38dad&amp;encrypt_type=rsa&amp;school_name = 励志学校 &amp; login_type=4&amp;code=&amp;code_token=&amp;_=1634277699157 # rpm 安装卸载 -ivh 安装 i[install ] v [查看信息] -qa 查询所有安装信息 -q -e 卸载 全称 # 三剑客 # cut 切分文件 # sort 排序 # wc 统计单词数 # grep 经常和 | 连用 ps -ef |grep find # set # awk # shell 编程 # 执行脚本文件 # ./hello.sh 方法一 # sh 或 bash hello.sh 方法二 # source 或. hello.sh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"python学习廖雪峰","slug":"python学习廖雪峰","date":"2022-01-05T03:47:31.000Z","updated":"2023-11-30T09:56:16.699Z","comments":true,"path":"python学习廖雪峰/","link":"","permalink":"https://ppxpython.github.io/python%E5%AD%A6%E4%B9%A0%E5%BB%96%E9%9B%AA%E5%B3%B0/","excerpt":"","text":"使用 dict 和 set - 廖雪峰的官方网站 (liaoxuefeng.com) 用于学习记录，后期便于复习，参考链接 python file 调用脚本时会先载入 pyhton 解释器，然后运行脚本 rpm：软件管理包 操作符优先级： 条件判断： Python 为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作 “内置电池（batteries included）”。用 Python 开发，许多功能不必从零编写，直接使用现成的即可。 语言定位： Python 的定位是 “优雅”、“明确”、“简单” Python 是解释型语言 # python # 数据类型 # int 整型 long int 长整型 int 整型 # float 浮点型 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时 双精度浮点型 e 浮点型 # String 字符串 字符串是以单引号 ' 或双引号 \" 括起来的任意文本 字符串是以 Unicode 编码 对于单个字符的编码，Python 提供了 ord() 函数获取字符的整数表示， chr() 函数把编码转换为对应的字符： # Bool 布尔 True Flase # None 空值 None， None 不能理解为 0 ，因为 0 是有意义的， Null 无意义 . &lt;iframe src=\"http://127.0.0.1:6806/widgets/brython-editor\" data-src=\"http://127.0.0.1:6806/widgets/brython-editor\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 1341px; height: 276px;\"&gt;&lt;/iframe&gt; # 变量 变量的概念基本上和初中代数的方程变量是一致的， 变量不仅可以是数字，还可以是任意数据类型。 变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头，字母或下划线开头 #变量类型a=1b='我是变量'c=Trued=12.2e3print(a,b,c,d)print(type(a),type(b),type(c),type(d)) int a=1 静态语言 此时已经分配的 int 分区之后不能更改变量类型【不支持，Java】 a=3 动态语言，可以赋值成任意类型 # 动态定义 # 静态定义 a = 'ABC'b = aa = 'XYZ'print(b)执行 a = 'ABC' ，解释器创建了字符串 'ABC' 和变量 a ，并把 a 指向 'ABC' ： 执行 b = a ，解释器创建了变量 b ，并把 b 指向 a 指向的字符串 'ABC' ： 执行 a = 'XYZ' ，解释器创建了字符串 'XYZ'，并把 a 的指向改为 'XYZ' ，但 b 并没有更改： # 常量 所谓常量就是不能变的变量，通常用全部大写的变量名表示常量： PI = 3.14159265359# list 列表 list 是一种有序的集合，可以随时添加和删除其中的元素。 list=['a','b','c']print(list)print(len(list)) # 切分 # append（）追加 str.append('a') # insert 插入指定位置 # pop（）删除末尾元素 要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置 替换元素直接赋值即可 列表可以嵌套 s = ['python', 'java', ['asp', 'php'], 'scheme']类型可以不同 L = ['Apple', 123, True]# 切片 list [:-1] 不包含最后一个元素 list [:] 全部列表 list [::] 全部列表 前 10 个数，每两个取一个 # 列表生成 list（range（1，11））生成 10 个数 1-10 print([m+n for m in '123' for n in 'yza'])k=[1,1,23,45,56,[1,12,3,467,[2,4,4,3,22]]]print([x for x in k if x==1 ]) # tuple 元组 tuple 一旦初始化就不能修改 但元组初始化后就不能进行更改了 b=(1)#定义的不是 tuple，是 1 这个数！# 这是因为括号 () 既可以表示 tuple，又可以表示数学公式中的小括号，# 这就产生了歧义，因此，Python 规定，# 这种情况下，按小括号进行计算，计算结果自然是 1print(b)print(type(b))c=(1,)print(c)print(type(c)) # dict 字典 其他语言叫 map，使用键 - 值（key-value）存储，具有极快的查找速度。dict 的 key 必须是不可变对象。key 计算位置的算法称为哈希算法（Hash）。 # 定义 d={'name':'ruanyifen','age':60,'happy':'write'}d['add']='Im add'd['name']='fix' # 取 value # dict['key'] # 'key' in dict # dict.get('key') print(type(d))print(d['name'])print('name' in d)#方法一判断是否有这个主键在字典 d 中print(d.get('name'))#方法二 取 # dict.pop ('key') 删除一个 key # dict.keys 返回字典中所有 key 列表 # dict.update () 将 a 字典新 key，value 内容加入 b 字典中 dicta={\"name\":'ruan','age':20}dictb={\"name\":'ruan2','age':40,'add':'w shi add'}dictb.update(dicta)print(dictb) # 内建函数使用 type（） cmp（） len（） hash（） 内建 cmp（）函数比较两个 dict 时，先比较长度，后比值，输出 1 或 - 1 # dict 特点 dict 有以下几个特点： 查找和插入的速度极快，不会随着 key 的增加而变慢； 需要占用大量的内存，内存浪费多。 而 list 相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 # set 集合 也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在 set 中，没有重复的 key。 重复元素在 set 中自动被过滤 # 定义 # set.add ('key') 添加元素 但重复元素不添加，自动去重 # set.remove ('key') 删除元素 set 可以看成数学意义上的无序和无重复元素的集合， 因此，两个 set 可以做数学意义上的交集、并集等操作： # &amp; 两个 set 交集 # | 两个 set 并集 # map () 的显示 打印 map 对象可以看到 map 对象返回的是一个地址，不是真实的数据 print(list(map对象))print([it for it in map对象])# 数据类型转换 # int（） # float（） # str（） # bool（） # 条件判断 # if if else a=100if a&gt;=0: print(a)else: print(-a) if if True: print('True') if elif elif else name='zhangsan'if name=='zhangsan': print('我是',name)elif name=='lisi': print('我是', name)elif name=='wangwu': print('我是', name)else: print('我谁的不是') # input（）输入输出 input () 返回的数据类型是 str print（） # 循环 迭代 list，tuple，dict 都可循环 Python 的 for 循环本质上就是通过不断调用 next() 函数实现的，计算是惰性的 dict 循环按照 value 时：for value in dict.values for value in d.values(): print(value)# for in sum=0for i in range(1,100): sum=sum+iprint(sum) # while sum2=0k=0while(k&lt;100): sum2=sum2+k k=k+1print(sum2) # break 如果要提前结束循环，可以用 break 语句 # continue 通过 continue 语句，跳过当前的这次循环，直接开始下一次循环 # 生成器 在 Python 中，这种一边循环一边计算的机制，称为生成器：generator。 包括生成器和带 yield 的 generator function。 g = (x * x for x in range(10)) 访问大文件 yield # isinstance（）迭代器 直接作用于 for 循环的对象统称为可迭代对象，都是迭代器 Iterable list 、 tuple 、 dict 、 set 、 str list 、 dict 、 str 虽然是 Iterable ，却不是 Iterator 。 list 、 dict 、 str 等 Iterable 变成 Iterator 可以使用 **iter ()** 函数 以直接作用于 for 循环的数据类型有以下几种： 一类是集合数据类型，如 list 、 tuple 、 dict 、 set 、 str 等； 一类是 generator ，包括生成器和带 yield 的 generator function。 可以使用 **isinstance ()** 判断一个对象是否是 Iterable 对象__iter__： 迭代对象 判断是不是可以迭代，用 Iterable from collections import Iterableisinstance({}, Iterable) --&gt; Trueisinstance((), Iterable) --&gt; Trueisinstance(100, Iterable) --&gt; False判断是不是迭代器，用 Iterator from collections import Iteratorisinstance({}, Iterator) --&gt; Falseisinstance((), Iterator) --&gt; Falseisinstance( (x for x in range(10)), Iterator) --&gt; TruePython 中 list，truple，str，dict 这些都可以被迭代，但他们并不是迭代器，为什么：：因为和迭代器相比有一个很大的不同，list/truple/map/dict 这些数据的大小是确定的，也就是说有多少事可知的。但迭代器不是，迭代器不知道要执行多少次，所以可以理解为不知道有多少个元素，每调用一次 next ()，就会往下走一步，是惰性的。 # 函数 抽象 将函数抽象成一个函数名称，不看内部结构直接调用方法 返回类型 函数名（输入参数）： 函数体 # 调用函数 要调用一个函数，需要知道函数的名称和参数 绝对值 abs # 定义函数 def myabs(x): if x&gt;0: return x if x&lt;0: return -xprint(myabs(-100)) # 空函数 def nufun(): passpass 可以用来作为占位符 # 函数 参数检查 def my_init_abs(x): if not isinstance(x,(int,float)): raise TypeError('no no no') else: if x&gt;0: print(x) if x&lt;0: print(-x)my_init_abs(-90) # 可返回多个值，函数 def return_much(): a='返回' b='我也返回' c='我也要返回' return a,b,cprint(return_much())print(type(return_much())) # 函数参数 *args 是可变参数，args 接收的是一个 tuple； **kw 是关键字参数，kw 接收的是一个 dict。 power(x) 函数，参数 x 就是一个位置参数，可单个变量，list，set，tuple power(*x) 函数，可传入单个变量，list，set，tuple，可以传入任意个参数或 0 个参数 power(**kw) 函数，字典 dict 可变参数允许你传入 0 个或任意个参数，这些可变参数在函数调用时自动组装为一个 tuple。 而关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict. power(x, n) ，用来计算 xn power(x, n) 函数有两个参数： x 和 n 默认参数，此时 age 和 city 为默认参数，可传值改变也可不变【不用传值】 power(L=None) 函数有 None 这个不变对象，可用 list def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city) # 必选参数 def a1(x): return xprint(a1(2))print(a1(12.1))print(a1('ruan'))print(a1(True))print(a1([1,2,3]))print(a1({1,2,3}))print(a1({\"key\":\"vleaue\",'name':'ruan','mun':23})) # = 默认参数 def a2(x=9): return xprint(a2())print(a2(2))print(a2(12.1))print(a2('ruan'))print(a2(True))print(a2([1,2,3]))print(a2({1,2,3}))print(a2({\"key\":\"vleaue\",'name':'ruan','mun':23})) # * 可变参数 def a3(*x): return xprint(a3())print(a3(2))print(a3(12.1))print(a3('ruan'))print(a3(True))print(a3([1,2,3]))print(a3({1,2,3}))print(a3({\"key\":\"vleaue\",'name':'ruan','mun':23})) # ** 关键字参数 def a3(**kw): return kwprint(a3())print(a3(kw=2))print(a3(kw=12.1))print(a3(kw='ruan'))print(a3(kw=True))print(a3(kw=[1,2,3]))print(type(a3(kw=[1,2,3])))print(a3(kw={1,2,3}))print(type(a3(kw={1,2,3})))print(a3(kw={\"key\":\"vleaue\",'name':'ruan','mun':23})) # 递归函数 在函数内部，可以调用其他函数。 一个函数在内部调用自身本身，这个函数就是递归函数。 使用递归函数需要注意防止栈溢出 #递归函数def funmyself(x): if x&gt;1: return x+funmyself(x-1) elif x==1: return 1print(funmyself(3)) 解决栈溢出方法： 尾递归优化，事实上尾递归和循环的效果是一样的 尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式 #尾递归def funmyself2(n): return funmyself2_it(n,1)def funmyself2_it(n,pro): if n==1: return pro else: return funmyself2(n-1)+nprint(funmyself2(100)) 此时 funmyself2 是尾递归函数 # 转义字符 \\ 转义字符 \\ 可以转义很多字符，比如 \\n 表示换行， \\t 表示制表符， 字符 \\ 本身也要转义，所以 \\\\ 表示的字符就是 \\ Python 还允许用 r'' 表示 '' 内部的字符串默认不转义 # 运算符 and、or 和 not 运算优先级：not&gt;or&gt;and # 除法 /// print(10/3)print(10//3)# 除法一 / 浮点数 # 除法二 // 地板除 整数 / 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： // ，称为地板除，两个整数的除法仍然是整数： # 取余 % print(10%1)print(10%3)print(4%7)print(2%20)#如果 a% b a&gt;b 则结果为 a # 字符编码 ASCII 编码 8 个比特（bit）作为一个字节（byte） 一个字节能表示的最大的整数就是 255（二进制 11111111 = 十进制 255） 两个字节可以表示的最大整数是 65535 ，4 个字节可以表示的最大整数是 4294967295 大写字母 A 的编码是 65 ，二进制的 01000001 ，小写字母 z 的编码是 122 Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题 ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节 ASCll 出现乱码问题引入 Unicode 编码存储空间多了一倍引入 UTF-8 编码 utf-8：将 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节， 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： # compile () 字符串编译为字节代码 # 编码转化 # ord ('A') 字母转字符 # chr (65) 字符转字母 a=ord('A')b=chr(65)print(a,b) # b'str' 转为字节类型 bytes bytes 类型的数据用带 b 前缀的单引号或双引号表示 x = b'ABC'要注意区分 'ABC' 和 b'ABC' ，前者是 str ，后者虽然内容显示得和前者一样，但 bytes 的每个字符都只占用一个字节。 # str.encode('ascii') str 变为 bytes ASCII UTF-8 # str.decode('utf-8') bytes 变为 str print(type(b'abc'))print(b'abc'.decode('utf-8'))print(type(b'abc'.decode('utf-8'))) len（str）计算字符数 函数计算的是 str 的字符数，如果换成 bytes ， len() 函数就计算字节数 print(len('abc'))print(len(b'abc'))print(len('中'))print(len('中'.encode('utf-8'))) # 特殊注释 #!/usr/bin/env python3# -*- coding: utf-8 -*-第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释； 第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 # 占位符 格式化 # 占位符 % s % d % f 格式化方式和 C 语言是一致 % 运算符就是用来格式化字符串的。 在字符串内部， %s 表示用字符串替换， %d 表示用整数替换， 有几个 %? 占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个 %? ，括号可以省略 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 转义： %% 来表示一个 % # format（）格式化字符串 # f-string 格式化字符串 {r} 被变量 r 的值替换， {s:.2f} 被变量 s 的值替换，并且 : 后面的 .2f 指定了格式化参数（即保留两位小数），因此， {s:.2f} 的替换结果是 19.62 # 函数式编程 函数是 Python 内建支持的一种封装，通过层层函数进行调用 #面向过程的程序设计 #：把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计 函数式和函数的区别： 对比例子：计算和计算器的区别 编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言 Python 不是纯函数式编程语言 函数式编程就是一种抽象程度很高的编程范式， 纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的 # 函数式编程特点： 纯函数式编程语言函数没有变量，输入输出确定 允许本身作为参数传入另一个函数，允许返回一个函数 # 高阶函数 参数中有函数 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回 # 变量可以指向函数 a = 函数 求绝对值的函数 abs() 为例 print(abs(-10))print(abs) abs（-10）是函数调用，abs 是函数本身 k=abs(-20)print(k)#函数本身也可以赋值给变量h=absprint(h)print(h(-100)) 结论：函数本身也可以赋值给变量，即：# 变量可以指向函数。# # 函数名也是变量 #函数名 #：其实就是指向函数的变量 a () 中 a 是指向函数 a（）的变量 # 传入函数 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 #高阶函数 #：一个函数就可以接收另一个函数作为参数 b() a(b) x=a def f(x): return abs(int(x))def a(a,b,f): return f(a)+f(b)if __name__ == '__main__': a1=input('a') a2=input('b') print(a(a1,a2,f)) 此时函数 a 为高阶函数，需要调用 f 函数作为参数 # map/reduce 内建函数 内建了 map() 和 reduce() 函数 高阶函数 # map（）函数处理生成新 Iterator 迭代器 两个参数，函数名【函数本身】，需要处理的编程式 iterator &lt;br /&gt; 创建一个迭代器，使用每个迭代器中的参数计算函数。当最短迭代用尽时停止。 map(func, *iterables) --&gt; map objectdef f(x): return x*xr=map(f,[1,2,3,4,4,4,4,4,4,4,4])print(r)print(type(r))print(list(r))print(type(list(r))) 运算规则抽象 # reduce（）函数作用在序列上 两个参数，函数名【函数本身】，需要处理的 #序列 #： sequence (序列) 是一组有顺序的元素的集合 序列基本样式 [下限：上限：步长] reduce 把结果继续和序列的下一个元素做累积计算 reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 # filter () 过滤序列 参数和 map（）相似 filter() 也接收一个函数和一个序列 # sorted（）排序 高阶函数 参数：排序对象，key = 函数 sorted([36, 5, -12, 9, -21], key=abs)排序的核心是比较两个元素的大小 print(sorted([1,2,353,6,3,234,43,435])) key 指定绝对值大小排序 print(sorted([1,2,353,6,3,234,43,435,-242,-34,34,35],key=abs)) # 返回函数 # 函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回 # 如果不需要立刻求和，而是在后面的代码中，# 根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：def zary_sum(a): def sum(): sum1=0 for i in a: sum1=sum1+i return sum1 return sumprint(type(zary_sum([1,2,3,4])))f=zary_sum([1,2,3,4])print(f()) 调用返回函数时，每次调用都会新生成一个函数 # 闭包 当一个函数的返回值是另外一个函数， 而返回的那个函数如果调用了其父函数内部的其它变量，如果 返回的这个函数在外部被执行，就产生了闭包 。 返回函数中，返回的函数调用父函数的内部变量 #返回函数def count(): fs=[] for i in range(1,4): def f(): return i*i fs.append(f) return fsf1,f2,f3=count()print(f1(),f2(),f3()) 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。 # lambda（）匿名函数 lambda 关键字 函数参数：函数表达式 传入函数时，有些时候，不需要显式地定义函数 Python 对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。 lambda x:x*x#等价于def f(x): return x*x关键字 lambda 表示匿名函数，冒号前面的 x 表示函数参数，只能一个表达式 不用写 return ，返回值就是该表达式的结果。 匿名函数也是一个函数对象 f=lamdba x:x*x判断奇数函数 原函数： def is_odd(n): return n % 2 == 1L = list(filter(is_odd, range(1, 20)))采用匿名函数修改 l=list(filter(lambda x:x%2==1,range(1,20)))print(l) # 装饰器 Decorator # 本质上，装饰器就是一个返回函数的高阶函数 @log 等价于 now = log(now)由于函数也是一个对象，而且函数对象可以被赋值给变量， 所以，通过变量也能调用该函数 def log(func): def wrapper(*args,**kwargs): print('call %s'% func.__name__) return func(*args,**kwargs) return wrapper()#func 为参数所以是高阶函数#return 函数所以是返回函数，#没有调用父函数中参数，所以不是闭包 场景注意： 无 @装饰器时函数不调用，需要参数才调用 当 @时会直接调用装饰器定义函数然后执行函数，不用调用函数 三层时，传入参数 def log1(text): def decorator(func): def wapper(*args,**kw): print('%s %s'%(text,func.__name__)) return func(*args,**kw) return wapper return decorator@log1('ruan')def now3(): print(\"hhh\")now3()相当于在返回高阶函数上还有一个函数，所以返回时应该还要调用一次 # @wraps 常用装饰器 当装饰器是个闭包时，装饰器调用变量会改变增加 @wraps 后装饰器内的变量不变 装饰器在装饰一个函数时，，原函数就成了一个新的函数，也 就是说其属性会发生变化，所以为了 不改变原函数的属性， 我们会调用 functools 中的 wraps 装饰器来保证原函数的属性不变 # 不加 wraps 时 @wraps(func)from functools import wrapsdef wrap(func): def b(): 'b' print('decorator:',b.__name__) print('funname',func.__name__) func() return b@wrapdef a(): 'a' print('name',a.__name__)a() 加装饰器 wraps 时 from functools import wrapsdef wrap(func): @wraps(func) def b(): 'b' print('decorator:',b.__name__) print('funname',func.__name__) func() return b@wrapdef a(): 'a' print('name',a.__name__)a() 闭包的概念：调用父函数中的变量的函数，为了保证数据安全。变量作用域只在函数内部，可在闭包中操作数据。 装饰器返回为什么是函数名（函数内存地址）而不直接执行函数？ 当有参数传入时，可直接与调用的函数中的值传入参数执行。 （）是运算符 f () 与 f.call () 等价：将 f 对象变成变成可调用的对象 # 偏函数（functools 模块） 属于 functools 模块 # 作用： 通过设定参数的默认值，降低函数调用的参数 int() 函数默认按十进制转换 print(int('100',base=8)) 经常调用于是重写一个函数 int2 def int2(x, base=8): print(int(x, base)) return int(x, base)print(int2('2334'))采用偏函数 import functoolsint3=functools.partial(int,base=8)print(int3('46'))print(int()) functools.partial 的作用是将函数的特定参数固定住（设定为默认值） 创建偏函数的时候也可以接收，函数对象，*args，**kw # 模块 python 包：作用区分相同名称的模块 模块相当于一个 py 文件 # 作用域 仅仅在模块内部使用。在 Python 中，是通过 _ 前缀来实现的。 # pubilc 公开 正常的函数和变量名是公开的（public） # private 非公开_,__ _xxx 和__xxx 这样的函数或变量就是非公开的（private） # 安装第三方模块 pip pip install 模块名 # 模块搜索路径 import sysprint(sys.path)两种方式： 添加搜索路径import syssys.path.append('/Users/michael/my_py_scripts') 设置环境变量 第二种方法是设置环境变量 PYTHONPATH # 面向对象编程 面向对象编程 ——Object Oriented Programming，简称 OOP，是一种程序设计思想 对象作为程序的基本单元， 一个对象包含了数据和操作数据的函数 数据封装、继承和多态是面向对象的三大特点 # 类和实例 面向对象最重要的概念就是类（Class）和实例（Instance） 类是抽象出来的模板 实例是根据类创建出的对象，每个对象可能有属性和方法 定义类是通过 class 关键字，类名通常是大写开头的单词 class Student(object): pass ！！！在类中定义函数有一点不同，定义佛如方法第一个参数永远是实例变量本身 self 仍然可以用默认参数、可变参数、关键字参数和命名关键字参数 # 数据封装 class Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' # 访问限制 # 作用： 确保了外部代码不能随意修改对象内部的状态 实例的变量名如果以 __ 开头，就变成了一个私有变量（private） 外部无法访问_name class Student(object): def __init__(self,name,age): self._name=name self.age=age def print_name(self): print(self._name) return self.age,self._namea=Student('ruan',23)h=a.print_name()print(h) 若是要获取，修改变量增加 get，set 方式即可 class Student(object): def __init__(self,name,age): self._name=name self.age=age def get_name(self): return self.name def set_name(self,name): self._name=namePython 本身没有任何机制阻止你干坏事，一切全靠自觉。 类外部无法访问 # 继承和多态 # 继承 # 多态 在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。 比如：动物是父类，狗和鱼是子类；鱼是鱼类，鱼是动物都成立。 判断一个变量是否是某个类型可以用 isinstance() 判断 # 鸭子类型 并不要求严格的继承体，一个对象只要 “看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 # 获取对象信息 # type（）判断对象类型 # isinstance () 对于继承关系，判断 class 的类型 # dir（）获取对象的所有属性和方法 # len（）对象长度 # lower（）返回小写的字符串 # getattr（）获取属性 a # setattr（）设置属性 a # hasattr（obj,'a'）判断是否有属性 a getattr(obj, 'z', 404) # 获取属性 'z'，如果不存在，返回默认值 404404# 实例属性和类属性 class Student(object): name='ruan' h=Student()h.name='hhh'类中的 name 是类属性， 创建 h 类对象即实例后赋值的是实例属性 name，但由于实例对象的优先级比类属性高，会屏蔽类中的 name 属性，即 h.name 的值为 hhh # 总结： 实例属性属于各个实例所有，互不干扰； 类属性属于类所有，所有实例共享一个属性； 不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误 # 面向对象高级编程 数据封装、继承和多态只是面向对象程序设计中最基础的 3 个概念 多重继承、定制类、元类 # _slots_使用 可以给创建的实例绑定属性和方法 给一个实例绑定的方法对另外一个实例对象是不起作用的 class A: def run(self): print(\"i im ferther runing....\")sun1=A()#给实例 sun1 设置 name 属性sun1.name='i im name'#创建实例对象 2sun2=A()#实例对象 sun1 的属性和 sun2 无关，即 sun2 没有 name 属性#给实例 sun1 绑定方法，方法和属性同理#定义方法def setAll(self,num): print(num)sun1.newfun=MethodType(setAll, sun1)sun1.newfun(37)#若所有实例都需要绑定方法则给类绑定方法A.setAll=setAll#给类绑定方法后，所有创建的实例的均可调用def set_age(self, age): # 定义一个函数作为实例方法 ... self.age = age ... &gt;&gt;&gt; from types import MethodType &gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法 &gt;&gt;&gt; s.set_age(25) # 调用实例方法 # 限制实例属性，定义一个特殊的 __slots__ 变量 class Student(object): __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称s=Student()s.name='ruan's.firstname='i im firstname'#输出的时候 firstname 的属性会报错，Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'firstaname'# 注意： _slots_使用时要注意，定义的属性只在当前的类的实例中，对于继承的子类是不起作用的 class People(object): __slots__ = ('name','age') def run(self): print('i im run people......')class Teacher(People): def say(self): print('i im teacher....')t=Teacher()t.tall='shouhua'print(t.tall)p=People()p.tall('shouhuap')print(p.tall) 只限制父类 People 的属性，而子类 Teacher 中不限制 # @property 在绑定属性时，如果我们直接把属性暴露出去，导致可以随意更改。通过 get，set 来获取更改属性值。 在 python 中直接调用装饰器将一个方法变成属性调用 class Student(object): @property #使用 get 方法是调用装饰器 @peoperty， # 同时自动创建了另一个装饰器 @属性.setter def score(self): return self.score @score.setter def score(self,value): self._score=value# 总结： - 权限限制只对类对象实际起作用，想要达到方法和属性强制访问权限，需要使用 @property 装饰器进行 get，set 方法 属性名与方法名一定要区分开，不然会进入死循环（self._age，def age ()） 实例化的对象使用属性时，不是调用属性（meizi._age），而是用的方法名（meizi.age） @property 其实就是实现了 getter 功能； @xxx.setter 实现的是 setter 功能；还有一个 @xxx.deleter 实现删除功能 定义方法的时候 @property 必须在 @xxx.setter 之前，且二者修饰的方法名相同（age ()） 如果只实现了 @property（而没有实现 @xxx.setter），那么该属性为 只读属性 #请利用 @property 给一个 Screen 对象加上 width 和 height 属性，# 以及一个只读属性 resolution：class Screen(object): __slots__ = ('_width','_height','_resolution') @property def width(self): return self._width # 方法名称和实例变量均为 width: @width.setter def width(self,widthValue): self._width=widthValue @property def height(self): return self._height @width.setter def height(self, height): self._height = height @property def resolution(self): return self._width * self._heights=Screen()s.width=23s.height=12print(s.resolution) s.score = 60 # OK，实际转化为 s.set_score (60)s.score # OK，实际转化为 s.get_score ()要特别注意：属性的方法名不要和实例变量重名。例如，以下的代码是错误的： class Student(object): # 方法名称和实例变量均为birth: @property def birth(self): return self.birth 出现递归调用错误 之前的例子中 width 和_width 不同所以可以运行 # 多重继承 python 可以支持多继承，即一个子类可以继承多个父类；但 java 是单继承，只能有一个父类 Tercher（Name，study，teach）即 Teacher 可以继承多个父类 # MixIn 在设计类的继承关系时，通常，主线都是单一继承下来的，例如， Teacher 继承自 Name。但是，如果需要 “混入” 额外的功能，通过多重继承就可以实现，比如 Teacher 除了继承自 Name 外，再同时继承 Teach 。这种设计通常称之为 MixIn Python 自带了 TCPServer 和 UDPServer 这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由 ForkingMixIn 和 ThreadingMixIn 提供。 # 多继承 多重继承这个名词一般用来形容继承链条可以很长，多个层次。 # 多重继承 多继承则指一个类可以有多个基类，相反则是单继承。任何面向对象编程语言都支持多重继承，但像 java 这种只能通过接口实现有限程度的多继承 问：多继承 如果多个类有共同得方法名 怎么区分是调得哪个类🤡 答：调用该方法的时候，会调用第一顺位继承父类的方法 # 总结： Python 允许使用多重继承，因此，MixIn 就是一种常见的设计 只允许单一继承的语言（如 Java）不能使用 MixIn 的设计 # 定制类 Python 的 class 中还有__xxx__有特殊用途的函数，可以帮助我们定制类 # str () 回用户看到的字符串 将对象 &lt;__main__.Student object at 0x109afb190&gt; 变成易读的数据 只在调用 print 时会调用__str__，交互界面时还是现实上方不易读的对象内容，此时用 # repr () 返回程序开发者看到的字符串 __str__() 返回用户看到的字符串，而 __repr__() 返回程序开发者看到的字符串， 也就是说， __repr__() 是为调试服务的 简写 def __str__(self): return 'xxx object (name=%s)' % self.name__repr__ = __str__# _iter () 返回一个迭代对象 需要用到 for in 迭代，需要转化为迭代对象 该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 __next__() 方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环 例子： class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.aa=Fib()for i in a: print(i) # getitem () 表现得像 list 那样按照下标取出元素 class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.a def __getitem__(self, item): a,b=1,1 for i in range(item): a,b=b,a+b return aa=Fib()print(a[3]) 以上是传入 int，切片功能实现，isinstance 判断类型 class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.a def __getitem__(self, item): if isinstance(item,int): a, b = 1, 1 for i in range(item): a, b = b, a + b return a if isinstance(item,slice): start=item.start stop=item.stop if start is None: start=0 a,b=1,1 L=[] for x in range(stop): L.append(a) a,b=b,a+b return La=Fib()print(a[3:12]) # getattr () 动态返回一个属性 调用类属性或方法时，先在__init__() 获取后，再从__getattr__() 获取，获取不到才报错 # call () 直接调用实例本身 与直接调用这个函数一样 class People(object): def __init__(self,name): self.name=name def __call__(self, *args, **kwargs): print('i im call %s'% self.name)p=People('ruan')p() # 使用枚举类 枚举类：在某些情况下，一个类的 实例对象 的数量是 有限且固定 的，如季节类，它的实例对象只有春、夏、秋、冬。 在 Java 中像这种对象实例有限且固定的类被称为枚举类；这样的枚举类型定义一个 class 类型，然后，每个常量都是 class 的一个唯一实例。Python 提供了 Enum 类来实现这个功能。 from enum import EnumM=Enum('a',('sun1','sun2','sun3','sun4'))print(M.sun1) 自定义枚举类 from enum import Enum,unique@uniqueclass Week(Enum): sun1=1 sun2=2 sun3=3day2=Week.sun2print(day2) from enum import Enum,unique@uniqueclass Gender(Enum): Male=0 Female=1class Student(object): def __init__(self,name,gender): self.name=name self.gender=gender# 测试:bart = Student('Bart', Gender.Male)if bart.gender == Gender.Male: print('测试通过!')else: print('测试失败!') # 使用元类 [创建类] 实例对象是类创建 类是元类创建 创建类的方式 # 方式一：type（） type() 函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过 type() 函数创建出 Hello 类 from class1104 import *h=Hello()print(type(h))print(type(Hello)) Hello = type('Hello', (object,), dict(hello=fn))要创建一个 class 对象， type() 函数依次传入 3 个参数： class 的名称； 继承的父类集合，注意 Python 支持多重继承，如果只有一个父类，别忘了 tuple 的单元素写法； class 的方法名称与函数绑定，这里我们把函数 fn 绑定到方法名 hello 上 # 方式二：元类 metaclass 先定义 metaclass，然后创建类。 先定义类，然后创建实例。 metaclass 是 Python 面向对象里最难理解，也是最难使用的魔术代码。 按照默认习惯，metaclass 的类名总是以 Metaclass 结尾，以便清楚地表示这是一个 metaclass # metaclass 采用 type 创建类 ，metaclass 是类的模板，所以必须从 `type` 类型派生class ListMetaclass(type): def __new__(cls, name,bases,attrs): attrs['add']=lambda self, value:self.append(value) return type.__new__(cls,name,bases,attrs)class MyList(list,metaclass=ListMetaclass): passmylist=MyList()mylist.add(1)print(mylist) __new__() 方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法集合 # 应用场景 ORM 全称 “Object Relational Mapping”，即对象 - 关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作 SQL 语句。 要编写一个 ORM 框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。 # 错误处理 try try: print('try...') r = 10 / 0 print('result:', r)except ValueError as e: print('ValueError:', e)except ZeroDivisionError as e: print('ZeroDivisionError:', e)e)finally: print('finally...')print('END')Python 的错误其实也是 class，所有的错误类型都继承自 BaseException UnicodeError 是 ValueError 的子类🤡 Built-in Exceptions — Python 3.10.0 documentation # 调用栈 让 Python 解释器来打印出错误堆栈 # 记录错误 logging 可将 logging 生成一个 txt 方便查看 try: xxx except Exception as e: logging.exception(e)# 抛出错误 raise except ValueError as e: print('ValueError!') raise在 bar() 函数中，我们明明已经捕获了错误，但是，打印一个 ValueError! 后，又把错误通过 raise 语句抛出去了，这不有病么？ 其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。 # 调试方法 # 1. print（） # 2. 断言 assert assert n != 0, 'n is zero!'assert 的意思是，表达式 n != 0 应该是 True ，否则，根据程序运行的逻辑，后面的代码肯定会出错。 采用断言的好处： 启动 Python 解释器时可以用 -O 参数来关闭 assert ： $ python -O err.py 关闭后，你可以把所有的 assert 语句当成 pass 来看 # 3. logging import loggings = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)# 4.pbd 单步执行 启动 Python 的调试器 pdb，让程序以单步方式运行，可以随时查看运行状态。 python -m pdb xxx.py(Pbd) 1#查看第一行代码，单步执行第一行代码# 5. pdb.set_trace() 这个方法也是用 pdb，但是不需要单步执行，我们只需要 import pdb ，然后，在可能出错的地方放一个 pdb.set_trace() ，就可以设置一个断点： import pdbs = '0'n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n)可以用命令 p 查看变量，或者用命令 c 继续运行： # 6.IDE 工具 vscode,pycharm.... # 单元测试 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 # 文档测试 doctest 非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含 doctest 的注释提取出来。用户看文档的时候，同时也看到了 doctest。 Python 内置的 “文档测试”（doctest）模块可以直接提取注释中的代码并执行测试. class Dict(dict): \"\"\"\" 这一段就是文档测试 Simple dict but also support access as x.y style. &gt;&gt;&gt; d1 = Dict() &gt;&gt;&gt; d1['x'] = 100 &gt;&gt;&gt; d1.x 100 &gt;&gt;&gt; d1.y = 200 &gt;&gt;&gt; d1['y'] 200 &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3') &gt;&gt;&gt; d2.c '3' &gt;&gt;&gt; d2['empty'] Traceback (most recent call last): ... KeyError: 'empty' &gt;&gt;&gt; d2.empty Traceback (most recent call last): ... AttributeError: 'Dict' object has no attribute 'empty' \"\"\" def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key) def __setattr__(self, key, value): self[key] = valueif __name__ == '__main__': import doctest doctest.testmod()将其中一个函数注释，运行让它报错 # IO 编程 程序和运行时的数据在内存中驻留 涉及到数据交换的地方，通常是磁盘、网络等，就需要 IO 接口 通常，程序完成 IO 操作会有 Input 和 Output 两个数据流 Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。 在 IO 编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把 100M 的数据写入磁盘，CPU 输出 100M 的数据只需要 0.01 秒，可是磁盘要接收这 100M 数据可能需要 10 秒，怎么办呢？有两种办法： # 同步 IO 第一种是 CPU 等着，也就是程序暂停执行后续代码，等 100M 的数据在 10 秒后写入磁盘，再接着往下执行，这种模式称为同步 IO； # 异步 IO 另一种方法是 CPU 不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步 IO。 如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步 IO 的复杂度远远高于同步 IO。 # 文件读写 # 读文件 open（） 传入文件名，标示符 参数：'rb' 二进制 encoding='gbk' 字符编码 f = open('/Users/michael/test.txt', 'r')# read () 一次读取全部内容 f.read()'Hello, world!'# f.close（）关闭文件 简化方法 # with open('filepath', 'r') as f: print(f.read()) Python 引入了 with 语句来自动帮我们调用 close() 方法，并且不必调用 f.close() 方法 with open('/path/to/file', 'r') as f: print(f.read())如果文件很小， read() 一次性读取最方便； 如果不能确定文件大小，反复调用 read(size) 比较保险； 如果是配置文件，调用 readlines() 最方便 for line in f.readlines(): print(line.strip()) # 把末尾的 '\\n' 删掉file 和缓存时 = 是 file-like Object 对象，不要求从特定类继承，只要写个 read() 方法就行 # f.write () 写文件 f = open('/Users/michael/test.txt', 'w')f.write('Hello, world!')f.close()或 with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!')使用 with 语句操作文件 IO 是个好习惯 # StringIO 和 BytesIO # StringIO StringIO 顾名思义就是在内存中读写 str from io import StringIO f = StringIO()f.write('hello')getvalue() 方法用于获得写入后的 str from io import StringIO&gt;&gt;&gt; f = StringIO('Hello!\\nHi!\\nGoodbye!')&gt;&gt;&gt; while True:... s = f.readline()... if s == '':... break... print(s.strip())# BytesIO 操作二进制数据，就需要使用 BytesIO &gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'# os 模块 # os.name 操作系统类型 # os.uname () 详细系统信息 # os.enciron 环境变量 要获取某个环境变量的值，可以调用 os.environ.get('key') # 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath('.')'/Users/michael'# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')'/Users/michael/testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')通过 os.path.join() 函数，这样可以正确处理不同操作系统的路径分隔符 # os.path.join( ) 连接路径 # os.path.split() 拆分路径 # os.path.splitext() 文件扩展名 # 对文件重命名:&gt;&gt;&gt; os.rename('test.txt', 'test.py')# 删掉文件:&gt;&gt;&gt; os.remove('test.py')shutil 模块提供了 copyfile() 的函数，它们可以看做是 os 模块的补充 最后看看如何利用 Python 的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码： &gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)] ['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...] 要列出所有的 .py 文件，也只需一行代码： &gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py'] ['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py'] # 序列化 pickle 模块 变量从内存中变成可存储或传输的过程称之为序列化，Python 中叫 pickling 变量内容从序列化的对象重新读到内存里称之为反序列化，即 unpickling # pickle.dumps () 对象 -》字节 [序列化] pickle.dumps() 方法把任意对象序列化成一个 bytes pickle.dumps() 方法把任意对象序列化成一个 bytes , 并写入文件中 import pickled=dict(name='ruan',age=34,freand='woman')# print(pickle.dumps(d))f = open('timezone.txt', 'wb')pickle.dump(d, f)f.close()# pickle.load () 字节 -》对象【反序列化】 import picklef=open(r'C:\\Users\\yangs\\PycharmProjects\\python_study\\fun\\timezone.txt','rb')d=pickle.load(f)f.close()print(d) # json 模块 json 模块的 dumps() 和 loads() 函数是定义得非常好的接口的典范。 # json.dumps (python 对象) python 对象 -》json 对象 dumps() 方法返回一个 str ，内容就是标准的 JSON # json.loads (json 对象) json 对象 -》python 对象 json.``dump (obj,&nbsp;fp,&nbsp;,&nbsp;skipkeys=False,&nbsp;ensure_ascii=True,&nbsp;check_circular=True,&nbsp;allow_nan=True,&nbsp;cls=None,&nbsp;indent=None,&nbsp;separators=None,&nbsp;default=None,&nbsp;sort_keys=False,&nbsp;kw)* # 类变为字典并序列化 json.dumps(s, default=lambda obj: obj.__dict__)# 进程和线程 Python 的标准库提供了两个模块： _thread 和 threading ， _thread 是低级模块， threading 是高级模块 线程是最小的执行单元，而进程由至少一个线程组成 操作系统轮流让各个任务交替执行 真正的并行执行多任务只能在多核 CPU 上实现 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程 Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个 “子任务”，我们把进程内的这些 “子任务” 称为线程（Thread） 多进程模式； 多线程模式； 多进程 + 多线程模式。 # 多进程 Unix/Linux 操作系统提供了一个 fork() 系统调用，普通的函数调用，调用一次，返回一次，但是 fork() 调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 创建子进程 from multiprocessing import Processimport osdef run_pro(name): print('开始运行子进程%s，%s'%(name,os.getpid()))if __name__ == '__main__': print('开始运行进程%s' % (os.getpid())) p=Process(target=run_pro,args=('test',)) p.start() p.join() print('end') # 启动大量子进程 pool 进程池 import time, threading# 新线程执行的代码:def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name)# 模块总结 # doctest 文档测试 # os.path 文件路径 # pickle 序列化 # json 使用 dict 和 set - 廖雪峰的官方网站 (liaoxuefeng.com) 用于学习记录，后期便于复习，参考链接 python file 调用脚本时会先载入 pyhton 解释器，然后运行脚本 rpm：软件管理包 操作符优先级： 条件判断： Python 为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作 “内置电池（batteries included）”。用 Python 开发，许多功能不必从零编写，直接使用现成的即可。 语言定位： Python 的定位是 “优雅”、“明确”、“简单” Python 是解释型语言 # python # 数据类型 # int 整型 long int 长整型 int 整型 # float 浮点型 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时 双精度浮点型 e 浮点型 # String 字符串 字符串是以单引号 ' 或双引号 \" 括起来的任意文本 字符串是以 Unicode 编码 对于单个字符的编码，Python 提供了 ord() 函数获取字符的整数表示， chr() 函数把编码转换为对应的字符： # Bool 布尔 True Flase # None 空值 None， None 不能理解为 0 ，因为 0 是有意义的， Null 无意义 . &lt;iframe src=\"http://127.0.0.1:6806/widgets/brython-editor\" data-src=\"http://127.0.0.1:6806/widgets/brython-editor\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 1341px; height: 276px;\"&gt;&lt;/iframe&gt; # 变量 变量的概念基本上和初中代数的方程变量是一致的， 变量不仅可以是数字，还可以是任意数据类型。 变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头，字母或下划线开头 #变量类型a=1b='我是变量'c=Trued=12.2e3print(a,b,c,d)print(type(a),type(b),type(c),type(d)) int a=1 静态语言 此时已经分配的 int 分区之后不能更改变量类型【不支持，Java】 a=3 动态语言，可以赋值成任意类型 # 动态定义 # 静态定义 a = 'ABC'b = aa = 'XYZ'print(b)执行 a = 'ABC' ，解释器创建了字符串 'ABC' 和变量 a ，并把 a 指向 'ABC' ： 执行 b = a ，解释器创建了变量 b ，并把 b 指向 a 指向的字符串 'ABC' ： 执行 a = 'XYZ' ，解释器创建了字符串 'XYZ'，并把 a 的指向改为 'XYZ' ，但 b 并没有更改： # 常量 所谓常量就是不能变的变量，通常用全部大写的变量名表示常量： PI = 3.14159265359# list 列表 list 是一种有序的集合，可以随时添加和删除其中的元素。 list=['a','b','c']print(list)print(len(list)) # 切分 # append（）追加 str.append('a') # insert 插入指定位置 # pop（）删除末尾元素 要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置 替换元素直接赋值即可 列表可以嵌套 s = ['python', 'java', ['asp', 'php'], 'scheme']类型可以不同 L = ['Apple', 123, True]# 切片 list [:-1] 不包含最后一个元素 list [:] 全部列表 list [::] 全部列表 前 10 个数，每两个取一个 # 列表生成 list（range（1，11））生成 10 个数 1-10 print([m+n for m in '123' for n in 'yza'])k=[1,1,23,45,56,[1,12,3,467,[2,4,4,3,22]]]print([x for x in k if x==1 ]) # tuple 元组 tuple 一旦初始化就不能修改 但元组初始化后就不能进行更改了 b=(1)#定义的不是 tuple，是 1 这个数！# 这是因为括号 () 既可以表示 tuple，又可以表示数学公式中的小括号，# 这就产生了歧义，因此，Python 规定，# 这种情况下，按小括号进行计算，计算结果自然是 1print(b)print(type(b))c=(1,)print(c)print(type(c)) # dict 字典 其他语言叫 map，使用键 - 值（key-value）存储，具有极快的查找速度。dict 的 key 必须是不可变对象。key 计算位置的算法称为哈希算法（Hash）。 # 定义 d={'name':'ruanyifen','age':60,'happy':'write'}d['add']='Im add'd['name']='fix' # 取 value # dict['key'] # 'key' in dict # dict.get('key') print(type(d))print(d['name'])print('name' in d)#方法一判断是否有这个主键在字典 d 中print(d.get('name'))#方法二 取 # dict.pop ('key') 删除一个 key # dict.keys 返回字典中所有 key 列表 # dict.update () 将 a 字典新 key，value 内容加入 b 字典中 dicta={\"name\":'ruan','age':20}dictb={\"name\":'ruan2','age':40,'add':'w shi add'}dictb.update(dicta)print(dictb) # 内建函数使用 type（） cmp（） len（） hash（） 内建 cmp（）函数比较两个 dict 时，先比较长度，后比值，输出 1 或 - 1 # dict 特点 dict 有以下几个特点： 查找和插入的速度极快，不会随着 key 的增加而变慢； 需要占用大量的内存，内存浪费多。 而 list 相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 # set 集合 也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在 set 中，没有重复的 key。 重复元素在 set 中自动被过滤 # 定义 # set.add ('key') 添加元素 但重复元素不添加，自动去重 # set.remove ('key') 删除元素 set 可以看成数学意义上的无序和无重复元素的集合， 因此，两个 set 可以做数学意义上的交集、并集等操作： # &amp; 两个 set 交集 # | 两个 set 并集 # map () 的显示 打印 map 对象可以看到 map 对象返回的是一个地址，不是真实的数据 print(list(map对象))print([it for it in map对象])# 数据类型转换 # int（） # float（） # str（） # bool（） # 条件判断 # if if else a=100if a&gt;=0: print(a)else: print(-a) if if True: print('True') if elif elif else name='zhangsan'if name=='zhangsan': print('我是',name)elif name=='lisi': print('我是', name)elif name=='wangwu': print('我是', name)else: print('我谁的不是') # input（）输入输出 input () 返回的数据类型是 str print（） # 循环 迭代 list，tuple，dict 都可循环 Python 的 for 循环本质上就是通过不断调用 next() 函数实现的，计算是惰性的 dict 循环按照 value 时：for value in dict.values for value in d.values(): print(value)# for in sum=0for i in range(1,100): sum=sum+iprint(sum) # while sum2=0k=0while(k&lt;100): sum2=sum2+k k=k+1print(sum2) # break 如果要提前结束循环，可以用 break 语句 # continue 通过 continue 语句，跳过当前的这次循环，直接开始下一次循环 # 生成器 在 Python 中，这种一边循环一边计算的机制，称为生成器：generator。 包括生成器和带 yield 的 generator function。 g = (x * x for x in range(10)) 访问大文件 yield # isinstance（）迭代器 直接作用于 for 循环的对象统称为可迭代对象，都是迭代器 Iterable list 、 tuple 、 dict 、 set 、 str list 、 dict 、 str 虽然是 Iterable ，却不是 Iterator 。 list 、 dict 、 str 等 Iterable 变成 Iterator 可以使用 **iter ()** 函数 以直接作用于 for 循环的数据类型有以下几种： 一类是集合数据类型，如 list 、 tuple 、 dict 、 set 、 str 等； 一类是 generator ，包括生成器和带 yield 的 generator function。 可以使用 **isinstance ()** 判断一个对象是否是 Iterable 对象__iter__： 迭代对象 判断是不是可以迭代，用 Iterable from collections import Iterableisinstance({}, Iterable) --&gt; Trueisinstance((), Iterable) --&gt; Trueisinstance(100, Iterable) --&gt; False判断是不是迭代器，用 Iterator from collections import Iteratorisinstance({}, Iterator) --&gt; Falseisinstance((), Iterator) --&gt; Falseisinstance( (x for x in range(10)), Iterator) --&gt; TruePython 中 list，truple，str，dict 这些都可以被迭代，但他们并不是迭代器，为什么：：因为和迭代器相比有一个很大的不同，list/truple/map/dict 这些数据的大小是确定的，也就是说有多少事可知的。但迭代器不是，迭代器不知道要执行多少次，所以可以理解为不知道有多少个元素，每调用一次 next ()，就会往下走一步，是惰性的。 # 函数 抽象 将函数抽象成一个函数名称，不看内部结构直接调用方法 返回类型 函数名（输入参数）： 函数体 # 调用函数 要调用一个函数，需要知道函数的名称和参数 绝对值 abs # 定义函数 def myabs(x): if x&gt;0: return x if x&lt;0: return -xprint(myabs(-100)) # 空函数 def nufun(): passpass 可以用来作为占位符 # 函数 参数检查 def my_init_abs(x): if not isinstance(x,(int,float)): raise TypeError('no no no') else: if x&gt;0: print(x) if x&lt;0: print(-x)my_init_abs(-90) # 可返回多个值，函数 def return_much(): a='返回' b='我也返回' c='我也要返回' return a,b,cprint(return_much())print(type(return_much())) # 函数参数 *args 是可变参数，args 接收的是一个 tuple； **kw 是关键字参数，kw 接收的是一个 dict。 power(x) 函数，参数 x 就是一个位置参数，可单个变量，list，set，tuple power(*x) 函数，可传入单个变量，list，set，tuple，可以传入任意个参数或 0 个参数 power(**kw) 函数，字典 dict 可变参数允许你传入 0 个或任意个参数，这些可变参数在函数调用时自动组装为一个 tuple。 而关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict. power(x, n) ，用来计算 xn power(x, n) 函数有两个参数： x 和 n 默认参数，此时 age 和 city 为默认参数，可传值改变也可不变【不用传值】 power(L=None) 函数有 None 这个不变对象，可用 list def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city) # 必选参数 def a1(x): return xprint(a1(2))print(a1(12.1))print(a1('ruan'))print(a1(True))print(a1([1,2,3]))print(a1({1,2,3}))print(a1({\"key\":\"vleaue\",'name':'ruan','mun':23})) # = 默认参数 def a2(x=9): return xprint(a2())print(a2(2))print(a2(12.1))print(a2('ruan'))print(a2(True))print(a2([1,2,3]))print(a2({1,2,3}))print(a2({\"key\":\"vleaue\",'name':'ruan','mun':23})) # * 可变参数 def a3(*x): return xprint(a3())print(a3(2))print(a3(12.1))print(a3('ruan'))print(a3(True))print(a3([1,2,3]))print(a3({1,2,3}))print(a3({\"key\":\"vleaue\",'name':'ruan','mun':23})) # ** 关键字参数 def a3(**kw): return kwprint(a3())print(a3(kw=2))print(a3(kw=12.1))print(a3(kw='ruan'))print(a3(kw=True))print(a3(kw=[1,2,3]))print(type(a3(kw=[1,2,3])))print(a3(kw={1,2,3}))print(type(a3(kw={1,2,3})))print(a3(kw={\"key\":\"vleaue\",'name':'ruan','mun':23})) # 递归函数 在函数内部，可以调用其他函数。 一个函数在内部调用自身本身，这个函数就是递归函数。 使用递归函数需要注意防止栈溢出 #递归函数def funmyself(x): if x&gt;1: return x+funmyself(x-1) elif x==1: return 1print(funmyself(3)) 解决栈溢出方法： 尾递归优化，事实上尾递归和循环的效果是一样的 尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式 #尾递归def funmyself2(n): return funmyself2_it(n,1)def funmyself2_it(n,pro): if n==1: return pro else: return funmyself2(n-1)+nprint(funmyself2(100)) 此时 funmyself2 是尾递归函数 # 转义字符 \\ 转义字符 \\ 可以转义很多字符，比如 \\n 表示换行， \\t 表示制表符， 字符 \\ 本身也要转义，所以 \\\\ 表示的字符就是 \\ Python 还允许用 r'' 表示 '' 内部的字符串默认不转义 # 运算符 and、or 和 not 运算优先级：not&gt;or&gt;and # 除法 /// print(10/3)print(10//3)# 除法一 / 浮点数 # 除法二 // 地板除 整数 / 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： // ，称为地板除，两个整数的除法仍然是整数： # 取余 % print(10%1)print(10%3)print(4%7)print(2%20)#如果 a% b a&gt;b 则结果为 a # 字符编码 ASCII 编码 8 个比特（bit）作为一个字节（byte） 一个字节能表示的最大的整数就是 255（二进制 11111111 = 十进制 255） 两个字节可以表示的最大整数是 65535 ，4 个字节可以表示的最大整数是 4294967295 大写字母 A 的编码是 65 ，二进制的 01000001 ，小写字母 z 的编码是 122 Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题 ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节 ASCll 出现乱码问题引入 Unicode 编码存储空间多了一倍引入 UTF-8 编码 utf-8：将 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节， 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： # compile () 字符串编译为字节代码 # 编码转化 # ord ('A') 字母转字符 # chr (65) 字符转字母 a=ord('A')b=chr(65)print(a,b) # b'str' 转为字节类型 bytes bytes 类型的数据用带 b 前缀的单引号或双引号表示 x = b'ABC'要注意区分 'ABC' 和 b'ABC' ，前者是 str ，后者虽然内容显示得和前者一样，但 bytes 的每个字符都只占用一个字节。 # str.encode('ascii') str 变为 bytes ASCII UTF-8 # str.decode('utf-8') bytes 变为 str print(type(b'abc'))print(b'abc'.decode('utf-8'))print(type(b'abc'.decode('utf-8'))) len（str）计算字符数 函数计算的是 str 的字符数，如果换成 bytes ， len() 函数就计算字节数 print(len('abc'))print(len(b'abc'))print(len('中'))print(len('中'.encode('utf-8'))) # 特殊注释 #!/usr/bin/env python3# -*- coding: utf-8 -*-第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释； 第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 # 占位符 格式化 # 占位符 % s % d % f 格式化方式和 C 语言是一致 % 运算符就是用来格式化字符串的。 在字符串内部， %s 表示用字符串替换， %d 表示用整数替换， 有几个 %? 占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个 %? ，括号可以省略 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 转义： %% 来表示一个 % # format（）格式化字符串 # f-string 格式化字符串 {r} 被变量 r 的值替换， {s:.2f} 被变量 s 的值替换，并且 : 后面的 .2f 指定了格式化参数（即保留两位小数），因此， {s:.2f} 的替换结果是 19.62 # 函数式编程 函数是 Python 内建支持的一种封装，通过层层函数进行调用 #面向过程的程序设计 #：把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计 函数式和函数的区别： 对比例子：计算和计算器的区别 编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言 Python 不是纯函数式编程语言 函数式编程就是一种抽象程度很高的编程范式， 纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的 # 函数式编程特点： 纯函数式编程语言函数没有变量，输入输出确定 允许本身作为参数传入另一个函数，允许返回一个函数 # 高阶函数 参数中有函数 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回 # 变量可以指向函数 a = 函数 求绝对值的函数 abs() 为例 print(abs(-10))print(abs) abs（-10）是函数调用，abs 是函数本身 k=abs(-20)print(k)#函数本身也可以赋值给变量h=absprint(h)print(h(-100)) 结论：函数本身也可以赋值给变量，即：# 变量可以指向函数。# # 函数名也是变量 #函数名 #：其实就是指向函数的变量 a () 中 a 是指向函数 a（）的变量 # 传入函数 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 #高阶函数 #：一个函数就可以接收另一个函数作为参数 b() a(b) x=a def f(x): return abs(int(x))def a(a,b,f): return f(a)+f(b)if __name__ == '__main__': a1=input('a') a2=input('b') print(a(a1,a2,f)) 此时函数 a 为高阶函数，需要调用 f 函数作为参数 # map/reduce 内建函数 内建了 map() 和 reduce() 函数 高阶函数 # map（）函数处理生成新 Iterator 迭代器 两个参数，函数名【函数本身】，需要处理的编程式 iterator &lt;br /&gt; 创建一个迭代器，使用每个迭代器中的参数计算函数。当最短迭代用尽时停止。 map(func, *iterables) --&gt; map objectdef f(x): return x*xr=map(f,[1,2,3,4,4,4,4,4,4,4,4])print(r)print(type(r))print(list(r))print(type(list(r))) 运算规则抽象 # reduce（）函数作用在序列上 两个参数，函数名【函数本身】，需要处理的 #序列 #： sequence (序列) 是一组有顺序的元素的集合 序列基本样式 [下限：上限：步长] reduce 把结果继续和序列的下一个元素做累积计算 reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 # filter () 过滤序列 参数和 map（）相似 filter() 也接收一个函数和一个序列 # sorted（）排序 高阶函数 参数：排序对象，key = 函数 sorted([36, 5, -12, 9, -21], key=abs)排序的核心是比较两个元素的大小 print(sorted([1,2,353,6,3,234,43,435])) key 指定绝对值大小排序 print(sorted([1,2,353,6,3,234,43,435,-242,-34,34,35],key=abs)) # 返回函数 # 函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回 # 如果不需要立刻求和，而是在后面的代码中，# 根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：def zary_sum(a): def sum(): sum1=0 for i in a: sum1=sum1+i return sum1 return sumprint(type(zary_sum([1,2,3,4])))f=zary_sum([1,2,3,4])print(f()) 调用返回函数时，每次调用都会新生成一个函数 # 闭包 当一个函数的返回值是另外一个函数， 而返回的那个函数如果调用了其父函数内部的其它变量，如果 返回的这个函数在外部被执行，就产生了闭包 。 返回函数中，返回的函数调用父函数的内部变量 #返回函数def count(): fs=[] for i in range(1,4): def f(): return i*i fs.append(f) return fsf1,f2,f3=count()print(f1(),f2(),f3()) 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。 # lambda（）匿名函数 lambda 关键字 函数参数：函数表达式 传入函数时，有些时候，不需要显式地定义函数 Python 对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。 lambda x:x*x#等价于def f(x): return x*x关键字 lambda 表示匿名函数，冒号前面的 x 表示函数参数，只能一个表达式 不用写 return ，返回值就是该表达式的结果。 匿名函数也是一个函数对象 f=lamdba x:x*x判断奇数函数 原函数： def is_odd(n): return n % 2 == 1L = list(filter(is_odd, range(1, 20)))采用匿名函数修改 l=list(filter(lambda x:x%2==1,range(1,20)))print(l) # 装饰器 Decorator # 本质上，装饰器就是一个返回函数的高阶函数 @log 等价于 now = log(now)由于函数也是一个对象，而且函数对象可以被赋值给变量， 所以，通过变量也能调用该函数 def log(func): def wrapper(*args,**kwargs): print('call %s'% func.__name__) return func(*args,**kwargs) return wrapper()#func 为参数所以是高阶函数#return 函数所以是返回函数，#没有调用父函数中参数，所以不是闭包 场景注意： 无 @装饰器时函数不调用，需要参数才调用 当 @时会直接调用装饰器定义函数然后执行函数，不用调用函数 三层时，传入参数 def log1(text): def decorator(func): def wapper(*args,**kw): print('%s %s'%(text,func.__name__)) return func(*args,**kw) return wapper return decorator@log1('ruan')def now3(): print(\"hhh\")now3()相当于在返回高阶函数上还有一个函数，所以返回时应该还要调用一次 # @wraps 常用装饰器 当装饰器是个闭包时，装饰器调用变量会改变增加 @wraps 后装饰器内的变量不变 装饰器在装饰一个函数时，，原函数就成了一个新的函数，也 就是说其属性会发生变化，所以为了 不改变原函数的属性， 我们会调用 functools 中的 wraps 装饰器来保证原函数的属性不变 # 不加 wraps 时 @wraps(func)from functools import wrapsdef wrap(func): def b(): 'b' print('decorator:',b.__name__) print('funname',func.__name__) func() return b@wrapdef a(): 'a' print('name',a.__name__)a() 加装饰器 wraps 时 from functools import wrapsdef wrap(func): @wraps(func) def b(): 'b' print('decorator:',b.__name__) print('funname',func.__name__) func() return b@wrapdef a(): 'a' print('name',a.__name__)a() 闭包的概念：调用父函数中的变量的函数，为了保证数据安全。变量作用域只在函数内部，可在闭包中操作数据。 装饰器返回为什么是函数名（函数内存地址）而不直接执行函数？ 当有参数传入时，可直接与调用的函数中的值传入参数执行。 （）是运算符 f () 与 f.call () 等价：将 f 对象变成变成可调用的对象 # 偏函数（functools 模块） 属于 functools 模块 # 作用： 通过设定参数的默认值，降低函数调用的参数 int() 函数默认按十进制转换 print(int('100',base=8)) 经常调用于是重写一个函数 int2 def int2(x, base=8): print(int(x, base)) return int(x, base)print(int2('2334'))采用偏函数 import functoolsint3=functools.partial(int,base=8)print(int3('46'))print(int()) functools.partial 的作用是将函数的特定参数固定住（设定为默认值） 创建偏函数的时候也可以接收，函数对象，*args，**kw # 模块 python 包：作用区分相同名称的模块 模块相当于一个 py 文件 # 作用域 仅仅在模块内部使用。在 Python 中，是通过 _ 前缀来实现的。 # pubilc 公开 正常的函数和变量名是公开的（public） # private 非公开_,__ _xxx 和__xxx 这样的函数或变量就是非公开的（private） # 安装第三方模块 pip pip install 模块名 # 模块搜索路径 import sysprint(sys.path)两种方式： 添加搜索路径import syssys.path.append('/Users/michael/my_py_scripts') 设置环境变量 第二种方法是设置环境变量 PYTHONPATH # 面向对象编程 面向对象编程 ——Object Oriented Programming，简称 OOP，是一种程序设计思想 对象作为程序的基本单元， 一个对象包含了数据和操作数据的函数 数据封装、继承和多态是面向对象的三大特点 # 类和实例 面向对象最重要的概念就是类（Class）和实例（Instance） 类是抽象出来的模板 实例是根据类创建出的对象，每个对象可能有属性和方法 定义类是通过 class 关键字，类名通常是大写开头的单词 class Student(object): pass ！！！在类中定义函数有一点不同，定义佛如方法第一个参数永远是实例变量本身 self 仍然可以用默认参数、可变参数、关键字参数和命名关键字参数 # 数据封装 class Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' # 访问限制 # 作用： 确保了外部代码不能随意修改对象内部的状态 实例的变量名如果以 __ 开头，就变成了一个私有变量（private） 外部无法访问_name class Student(object): def __init__(self,name,age): self._name=name self.age=age def print_name(self): print(self._name) return self.age,self._namea=Student('ruan',23)h=a.print_name()print(h) 若是要获取，修改变量增加 get，set 方式即可 class Student(object): def __init__(self,name,age): self._name=name self.age=age def get_name(self): return self.name def set_name(self,name): self._name=namePython 本身没有任何机制阻止你干坏事，一切全靠自觉。 类外部无法访问 # 继承和多态 # 继承 # 多态 在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。 比如：动物是父类，狗和鱼是子类；鱼是鱼类，鱼是动物都成立。 判断一个变量是否是某个类型可以用 isinstance() 判断 # 鸭子类型 并不要求严格的继承体，一个对象只要 “看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 # 获取对象信息 # type（）判断对象类型 # isinstance () 对于继承关系，判断 class 的类型 # dir（）获取对象的所有属性和方法 # len（）对象长度 # lower（）返回小写的字符串 # getattr（）获取属性 a # setattr（）设置属性 a # hasattr（obj,'a'）判断是否有属性 a getattr(obj, 'z', 404) # 获取属性 'z'，如果不存在，返回默认值 404404# 实例属性和类属性 class Student(object): name='ruan' h=Student()h.name='hhh'类中的 name 是类属性， 创建 h 类对象即实例后赋值的是实例属性 name，但由于实例对象的优先级比类属性高，会屏蔽类中的 name 属性，即 h.name 的值为 hhh # 总结： 实例属性属于各个实例所有，互不干扰； 类属性属于类所有，所有实例共享一个属性； 不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误 # 面向对象高级编程 数据封装、继承和多态只是面向对象程序设计中最基础的 3 个概念 多重继承、定制类、元类 # _slots_使用 可以给创建的实例绑定属性和方法 给一个实例绑定的方法对另外一个实例对象是不起作用的 class A: def run(self): print(\"i im ferther runing....\")sun1=A()#给实例 sun1 设置 name 属性sun1.name='i im name'#创建实例对象 2sun2=A()#实例对象 sun1 的属性和 sun2 无关，即 sun2 没有 name 属性#给实例 sun1 绑定方法，方法和属性同理#定义方法def setAll(self,num): print(num)sun1.newfun=MethodType(setAll, sun1)sun1.newfun(37)#若所有实例都需要绑定方法则给类绑定方法A.setAll=setAll#给类绑定方法后，所有创建的实例的均可调用def set_age(self, age): # 定义一个函数作为实例方法 ... self.age = age ... &gt;&gt;&gt; from types import MethodType &gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法 &gt;&gt;&gt; s.set_age(25) # 调用实例方法 # 限制实例属性，定义一个特殊的 __slots__ 变量 class Student(object): __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称s=Student()s.name='ruan's.firstname='i im firstname'#输出的时候 firstname 的属性会报错，Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'firstaname'# 注意： _slots_使用时要注意，定义的属性只在当前的类的实例中，对于继承的子类是不起作用的 class People(object): __slots__ = ('name','age') def run(self): print('i im run people......')class Teacher(People): def say(self): print('i im teacher....')t=Teacher()t.tall='shouhua'print(t.tall)p=People()p.tall('shouhuap')print(p.tall) 只限制父类 People 的属性，而子类 Teacher 中不限制 # @property 在绑定属性时，如果我们直接把属性暴露出去，导致可以随意更改。通过 get，set 来获取更改属性值。 在 python 中直接调用装饰器将一个方法变成属性调用 class Student(object): @property #使用 get 方法是调用装饰器 @peoperty， # 同时自动创建了另一个装饰器 @属性.setter def score(self): return self.score @score.setter def score(self,value): self._score=value# 总结： - 权限限制只对类对象实际起作用，想要达到方法和属性强制访问权限，需要使用 @property 装饰器进行 get，set 方法 属性名与方法名一定要区分开，不然会进入死循环（self._age，def age ()） 实例化的对象使用属性时，不是调用属性（meizi._age），而是用的方法名（meizi.age） @property 其实就是实现了 getter 功能； @xxx.setter 实现的是 setter 功能；还有一个 @xxx.deleter 实现删除功能 定义方法的时候 @property 必须在 @xxx.setter 之前，且二者修饰的方法名相同（age ()） 如果只实现了 @property（而没有实现 @xxx.setter），那么该属性为 只读属性 #请利用 @property 给一个 Screen 对象加上 width 和 height 属性，# 以及一个只读属性 resolution：class Screen(object): __slots__ = ('_width','_height','_resolution') @property def width(self): return self._width # 方法名称和实例变量均为 width: @width.setter def width(self,widthValue): self._width=widthValue @property def height(self): return self._height @width.setter def height(self, height): self._height = height @property def resolution(self): return self._width * self._heights=Screen()s.width=23s.height=12print(s.resolution) s.score = 60 # OK，实际转化为 s.set_score (60)s.score # OK，实际转化为 s.get_score ()要特别注意：属性的方法名不要和实例变量重名。例如，以下的代码是错误的： class Student(object): # 方法名称和实例变量均为birth: @property def birth(self): return self.birth 出现递归调用错误 之前的例子中 width 和_width 不同所以可以运行 # 多重继承 python 可以支持多继承，即一个子类可以继承多个父类；但 java 是单继承，只能有一个父类 Tercher（Name，study，teach）即 Teacher 可以继承多个父类 # MixIn 在设计类的继承关系时，通常，主线都是单一继承下来的，例如， Teacher 继承自 Name。但是，如果需要 “混入” 额外的功能，通过多重继承就可以实现，比如 Teacher 除了继承自 Name 外，再同时继承 Teach 。这种设计通常称之为 MixIn Python 自带了 TCPServer 和 UDPServer 这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由 ForkingMixIn 和 ThreadingMixIn 提供。 # 多继承 多重继承这个名词一般用来形容继承链条可以很长，多个层次。 # 多重继承 多继承则指一个类可以有多个基类，相反则是单继承。任何面向对象编程语言都支持多重继承，但像 java 这种只能通过接口实现有限程度的多继承 问：多继承 如果多个类有共同得方法名 怎么区分是调得哪个类🤡 答：调用该方法的时候，会调用第一顺位继承父类的方法 # 总结： Python 允许使用多重继承，因此，MixIn 就是一种常见的设计 只允许单一继承的语言（如 Java）不能使用 MixIn 的设计 # 定制类 Python 的 class 中还有__xxx__有特殊用途的函数，可以帮助我们定制类 # str () 回用户看到的字符串 将对象 &lt;__main__.Student object at 0x109afb190&gt; 变成易读的数据 只在调用 print 时会调用__str__，交互界面时还是现实上方不易读的对象内容，此时用 # repr () 返回程序开发者看到的字符串 __str__() 返回用户看到的字符串，而 __repr__() 返回程序开发者看到的字符串， 也就是说， __repr__() 是为调试服务的 简写 def __str__(self): return 'xxx object (name=%s)' % self.name__repr__ = __str__# _iter () 返回一个迭代对象 需要用到 for in 迭代，需要转化为迭代对象 该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 __next__() 方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环 例子： class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.aa=Fib()for i in a: print(i) # getitem () 表现得像 list 那样按照下标取出元素 class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.a def __getitem__(self, item): a,b=1,1 for i in range(item): a,b=b,a+b return aa=Fib()print(a[3]) 以上是传入 int，切片功能实现，isinstance 判断类型 class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.a def __getitem__(self, item): if isinstance(item,int): a, b = 1, 1 for i in range(item): a, b = b, a + b return a if isinstance(item,slice): start=item.start stop=item.stop if start is None: start=0 a,b=1,1 L=[] for x in range(stop): L.append(a) a,b=b,a+b return La=Fib()print(a[3:12]) # getattr () 动态返回一个属性 调用类属性或方法时，先在__init__() 获取后，再从__getattr__() 获取，获取不到才报错 # call () 直接调用实例本身 与直接调用这个函数一样 class People(object): def __init__(self,name): self.name=name def __call__(self, *args, **kwargs): print('i im call %s'% self.name)p=People('ruan')p() # 使用枚举类 枚举类：在某些情况下，一个类的 实例对象 的数量是 有限且固定 的，如季节类，它的实例对象只有春、夏、秋、冬。 在 Java 中像这种对象实例有限且固定的类被称为枚举类；这样的枚举类型定义一个 class 类型，然后，每个常量都是 class 的一个唯一实例。Python 提供了 Enum 类来实现这个功能。 from enum import EnumM=Enum('a',('sun1','sun2','sun3','sun4'))print(M.sun1) 自定义枚举类 from enum import Enum,unique@uniqueclass Week(Enum): sun1=1 sun2=2 sun3=3day2=Week.sun2print(day2) from enum import Enum,unique@uniqueclass Gender(Enum): Male=0 Female=1class Student(object): def __init__(self,name,gender): self.name=name self.gender=gender# 测试:bart = Student('Bart', Gender.Male)if bart.gender == Gender.Male: print('测试通过!')else: print('测试失败!') # 使用元类 [创建类] 实例对象是类创建 类是元类创建 创建类的方式 # 方式一：type（） type() 函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过 type() 函数创建出 Hello 类 from class1104 import *h=Hello()print(type(h))print(type(Hello)) Hello = type('Hello', (object,), dict(hello=fn))要创建一个 class 对象， type() 函数依次传入 3 个参数： class 的名称； 继承的父类集合，注意 Python 支持多重继承，如果只有一个父类，别忘了 tuple 的单元素写法； class 的方法名称与函数绑定，这里我们把函数 fn 绑定到方法名 hello 上 # 方式二：元类 metaclass 先定义 metaclass，然后创建类。 先定义类，然后创建实例。 metaclass 是 Python 面向对象里最难理解，也是最难使用的魔术代码。 按照默认习惯，metaclass 的类名总是以 Metaclass 结尾，以便清楚地表示这是一个 metaclass # metaclass 采用 type 创建类 ，metaclass 是类的模板，所以必须从 `type` 类型派生class ListMetaclass(type): def __new__(cls, name,bases,attrs): attrs['add']=lambda self, value:self.append(value) return type.__new__(cls,name,bases,attrs)class MyList(list,metaclass=ListMetaclass): passmylist=MyList()mylist.add(1)print(mylist) __new__() 方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法集合 # 应用场景 ORM 全称 “Object Relational Mapping”，即对象 - 关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作 SQL 语句。 要编写一个 ORM 框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。 # 错误处理 try try: print('try...') r = 10 / 0 print('result:', r)except ValueError as e: print('ValueError:', e)except ZeroDivisionError as e: print('ZeroDivisionError:', e)e)finally: print('finally...')print('END')Python 的错误其实也是 class，所有的错误类型都继承自 BaseException UnicodeError 是 ValueError 的子类🤡 Built-in Exceptions — Python 3.10.0 documentation # 调用栈 让 Python 解释器来打印出错误堆栈 # 记录错误 logging 可将 logging 生成一个 txt 方便查看 try: xxx except Exception as e: logging.exception(e)# 抛出错误 raise except ValueError as e: print('ValueError!') raise在 bar() 函数中，我们明明已经捕获了错误，但是，打印一个 ValueError! 后，又把错误通过 raise 语句抛出去了，这不有病么？ 其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。 # 调试方法 # 1. print（） # 2. 断言 assert assert n != 0, 'n is zero!'assert 的意思是，表达式 n != 0 应该是 True ，否则，根据程序运行的逻辑，后面的代码肯定会出错。 采用断言的好处： 启动 Python 解释器时可以用 -O 参数来关闭 assert ： $ python -O err.py 关闭后，你可以把所有的 assert 语句当成 pass 来看 # 3. logging import loggings = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)# 4.pbd 单步执行 启动 Python 的调试器 pdb，让程序以单步方式运行，可以随时查看运行状态。 python -m pdb xxx.py(Pbd) 1#查看第一行代码，单步执行第一行代码# 5. pdb.set_trace() 这个方法也是用 pdb，但是不需要单步执行，我们只需要 import pdb ，然后，在可能出错的地方放一个 pdb.set_trace() ，就可以设置一个断点： import pdbs = '0'n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n)可以用命令 p 查看变量，或者用命令 c 继续运行： # 6.IDE 工具 vscode,pycharm.... # 单元测试 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 # 文档测试 doctest 非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含 doctest 的注释提取出来。用户看文档的时候，同时也看到了 doctest。 Python 内置的 “文档测试”（doctest）模块可以直接提取注释中的代码并执行测试. class Dict(dict): \"\"\"\" 这一段就是文档测试 Simple dict but also support access as x.y style. &gt;&gt;&gt; d1 = Dict() &gt;&gt;&gt; d1['x'] = 100 &gt;&gt;&gt; d1.x 100 &gt;&gt;&gt; d1.y = 200 &gt;&gt;&gt; d1['y'] 200 &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3') &gt;&gt;&gt; d2.c '3' &gt;&gt;&gt; d2['empty'] Traceback (most recent call last): ... KeyError: 'empty' &gt;&gt;&gt; d2.empty Traceback (most recent call last): ... AttributeError: 'Dict' object has no attribute 'empty' \"\"\" def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key) def __setattr__(self, key, value): self[key] = valueif __name__ == '__main__': import doctest doctest.testmod()将其中一个函数注释，运行让它报错 # IO 编程 程序和运行时的数据在内存中驻留 涉及到数据交换的地方，通常是磁盘、网络等，就需要 IO 接口 通常，程序完成 IO 操作会有 Input 和 Output 两个数据流 Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。 在 IO 编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把 100M 的数据写入磁盘，CPU 输出 100M 的数据只需要 0.01 秒，可是磁盘要接收这 100M 数据可能需要 10 秒，怎么办呢？有两种办法： # 同步 IO 第一种是 CPU 等着，也就是程序暂停执行后续代码，等 100M 的数据在 10 秒后写入磁盘，再接着往下执行，这种模式称为同步 IO； # 异步 IO 另一种方法是 CPU 不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步 IO。 如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步 IO 的复杂度远远高于同步 IO。 # 文件读写 # 读文件 open（） 传入文件名，标示符 参数：'rb' 二进制 encoding='gbk' 字符编码 f = open('/Users/michael/test.txt', 'r')# read () 一次读取全部内容 f.read()'Hello, world!'# f.close（）关闭文件 简化方法 # with open('filepath', 'r') as f: print(f.read()) Python 引入了 with 语句来自动帮我们调用 close() 方法，并且不必调用 f.close() 方法 with open('/path/to/file', 'r') as f: print(f.read())如果文件很小， read() 一次性读取最方便； 如果不能确定文件大小，反复调用 read(size) 比较保险； 如果是配置文件，调用 readlines() 最方便 for line in f.readlines(): print(line.strip()) # 把末尾的 '\\n' 删掉file 和缓存时 = 是 file-like Object 对象，不要求从特定类继承，只要写个 read() 方法就行 # f.write () 写文件 f = open('/Users/michael/test.txt', 'w')f.write('Hello, world!')f.close()或 with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!')使用 with 语句操作文件 IO 是个好习惯 # StringIO 和 BytesIO # StringIO StringIO 顾名思义就是在内存中读写 str from io import StringIO f = StringIO()f.write('hello')getvalue() 方法用于获得写入后的 str from io import StringIO&gt;&gt;&gt; f = StringIO('Hello!\\nHi!\\nGoodbye!')&gt;&gt;&gt; while True:... s = f.readline()... if s == '':... break... print(s.strip())# BytesIO 操作二进制数据，就需要使用 BytesIO &gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'# os 模块 # os.name 操作系统类型 # os.uname () 详细系统信息 # os.enciron 环境变量 要获取某个环境变量的值，可以调用 os.environ.get('key') # 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath('.')'/Users/michael'# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')'/Users/michael/testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')通过 os.path.join() 函数，这样可以正确处理不同操作系统的路径分隔符 # os.path.join( ) 连接路径 # os.path.split() 拆分路径 # os.path.splitext() 文件扩展名 # 对文件重命名:&gt;&gt;&gt; os.rename('test.txt', 'test.py')# 删掉文件:&gt;&gt;&gt; os.remove('test.py')shutil 模块提供了 copyfile() 的函数，它们可以看做是 os 模块的补充 最后看看如何利用 Python 的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码： &gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)] ['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...] 要列出所有的 .py 文件，也只需一行代码： &gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py'] ['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py'] # 序列化 pickle 模块 变量从内存中变成可存储或传输的过程称之为序列化，Python 中叫 pickling 变量内容从序列化的对象重新读到内存里称之为反序列化，即 unpickling # pickle.dumps () 对象 -》字节 [序列化] pickle.dumps() 方法把任意对象序列化成一个 bytes pickle.dumps() 方法把任意对象序列化成一个 bytes , 并写入文件中 import pickled=dict(name='ruan',age=34,freand='woman')# print(pickle.dumps(d))f = open('timezone.txt', 'wb')pickle.dump(d, f)f.close()# pickle.load () 字节 -》对象【反序列化】 import picklef=open(r'C:\\Users\\yangs\\PycharmProjects\\python_study\\fun\\timezone.txt','rb')d=pickle.load(f)f.close()print(d) # json 模块 json 模块的 dumps() 和 loads() 函数是定义得非常好的接口的典范。 # json.dumps (python 对象) python 对象 -》json 对象 dumps() 方法返回一个 str ，内容就是标准的 JSON # json.loads (json 对象) json 对象 -》python 对象 json.``dump (obj,&nbsp;fp,&nbsp;,&nbsp;skipkeys=False,&nbsp;ensure_ascii=True,&nbsp;check_circular=True,&nbsp;allow_nan=True,&nbsp;cls=None,&nbsp;indent=None,&nbsp;separators=None,&nbsp;default=None,&nbsp;sort_keys=False,&nbsp;kw)* # 类变为字典并序列化 json.dumps(s, default=lambda obj: obj.__dict__)# 进程和线程 Python 的标准库提供了两个模块： _thread 和 threading ， _thread 是低级模块， threading 是高级模块 线程是最小的执行单元，而进程由至少一个线程组成 操作系统轮流让各个任务交替执行 真正的并行执行多任务只能在多核 CPU 上实现 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程 Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个 “子任务”，我们把进程内的这些 “子任务” 称为线程（Thread） 多进程模式； 多线程模式； 多进程 + 多线程模式。 # 多进程 Unix/Linux 操作系统提供了一个 fork() 系统调用，普通的函数调用，调用一次，返回一次，但是 fork() 调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 创建子进程 from multiprocessing import Processimport osdef run_pro(name): print('开始运行子进程%s，%s'%(name,os.getpid()))if __name__ == '__main__': print('开始运行进程%s' % (os.getpid())) p=Process(target=run_pro,args=('test',)) p.start() p.join() print('end') # 启动大量子进程 pool 进程池 import time, threading# 新线程执行的代码:def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name)# 模块总结 # doctest 文档测试 # os.path 文件路径 # pickle 序列化 # json 使用 dict 和 set - 廖雪峰的官方网站 (liaoxuefeng.com) 用于学习记录，后期便于复习，参考链接 python file 调用脚本时会先载入 pyhton 解释器，然后运行脚本 rpm：软件管理包 操作符优先级： 条件判断： Python 为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作 “内置电池（batteries included）”。用 Python 开发，许多功能不必从零编写，直接使用现成的即可。 语言定位： Python 的定位是 “优雅”、“明确”、“简单” Python 是解释型语言 # python # 数据类型 # int 整型 long int 长整型 int 整型 # float 浮点型 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时 双精度浮点型 e 浮点型 # String 字符串 字符串是以单引号 ' 或双引号 \" 括起来的任意文本 字符串是以 Unicode 编码 对于单个字符的编码，Python 提供了 ord() 函数获取字符的整数表示， chr() 函数把编码转换为对应的字符： # Bool 布尔 True Flase # None 空值 None， None 不能理解为 0 ，因为 0 是有意义的， Null 无意义 . &lt;iframe src=\"http://127.0.0.1:6806/widgets/brython-editor\" data-src=\"http://127.0.0.1:6806/widgets/brython-editor\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 1341px; height: 276px;\"&gt;&lt;/iframe&gt; # 变量 变量的概念基本上和初中代数的方程变量是一致的， 变量不仅可以是数字，还可以是任意数据类型。 变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头，字母或下划线开头 #变量类型a=1b='我是变量'c=Trued=12.2e3print(a,b,c,d)print(type(a),type(b),type(c),type(d)) int a=1 静态语言 此时已经分配的 int 分区之后不能更改变量类型【不支持，Java】 a=3 动态语言，可以赋值成任意类型 # 动态定义 # 静态定义 a = 'ABC'b = aa = 'XYZ'print(b)执行 a = 'ABC' ，解释器创建了字符串 'ABC' 和变量 a ，并把 a 指向 'ABC' ： 执行 b = a ，解释器创建了变量 b ，并把 b 指向 a 指向的字符串 'ABC' ： 执行 a = 'XYZ' ，解释器创建了字符串 'XYZ'，并把 a 的指向改为 'XYZ' ，但 b 并没有更改： # 常量 所谓常量就是不能变的变量，通常用全部大写的变量名表示常量： PI = 3.14159265359# list 列表 list 是一种有序的集合，可以随时添加和删除其中的元素。 list=['a','b','c']print(list)print(len(list)) # 切分 # append（）追加 str.append('a') # insert 插入指定位置 # pop（）删除末尾元素 要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置 替换元素直接赋值即可 列表可以嵌套 s = ['python', 'java', ['asp', 'php'], 'scheme']类型可以不同 L = ['Apple', 123, True]# 切片 list [:-1] 不包含最后一个元素 list [:] 全部列表 list [::] 全部列表 前 10 个数，每两个取一个 # 列表生成 list（range（1，11））生成 10 个数 1-10 print([m+n for m in '123' for n in 'yza'])k=[1,1,23,45,56,[1,12,3,467,[2,4,4,3,22]]]print([x for x in k if x==1 ]) # tuple 元组 tuple 一旦初始化就不能修改 但元组初始化后就不能进行更改了 b=(1)#定义的不是 tuple，是 1 这个数！# 这是因为括号 () 既可以表示 tuple，又可以表示数学公式中的小括号，# 这就产生了歧义，因此，Python 规定，# 这种情况下，按小括号进行计算，计算结果自然是 1print(b)print(type(b))c=(1,)print(c)print(type(c)) # dict 字典 其他语言叫 map，使用键 - 值（key-value）存储，具有极快的查找速度。dict 的 key 必须是不可变对象。key 计算位置的算法称为哈希算法（Hash）。 # 定义 d={'name':'ruanyifen','age':60,'happy':'write'}d['add']='Im add'd['name']='fix' # 取 value # dict['key'] # 'key' in dict # dict.get('key') print(type(d))print(d['name'])print('name' in d)#方法一判断是否有这个主键在字典 d 中print(d.get('name'))#方法二 取 # dict.pop ('key') 删除一个 key # dict.keys 返回字典中所有 key 列表 # dict.update () 将 a 字典新 key，value 内容加入 b 字典中 dicta={\"name\":'ruan','age':20}dictb={\"name\":'ruan2','age':40,'add':'w shi add'}dictb.update(dicta)print(dictb) # 内建函数使用 type（） cmp（） len（） hash（） 内建 cmp（）函数比较两个 dict 时，先比较长度，后比值，输出 1 或 - 1 # dict 特点 dict 有以下几个特点： 查找和插入的速度极快，不会随着 key 的增加而变慢； 需要占用大量的内存，内存浪费多。 而 list 相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 # set 集合 也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在 set 中，没有重复的 key。 重复元素在 set 中自动被过滤 # 定义 # set.add ('key') 添加元素 但重复元素不添加，自动去重 # set.remove ('key') 删除元素 set 可以看成数学意义上的无序和无重复元素的集合， 因此，两个 set 可以做数学意义上的交集、并集等操作： # &amp; 两个 set 交集 # | 两个 set 并集 # map () 的显示 打印 map 对象可以看到 map 对象返回的是一个地址，不是真实的数据 print(list(map对象))print([it for it in map对象])# 数据类型转换 # int（） # float（） # str（） # bool（） # 条件判断 # if if else a=100if a&gt;=0: print(a)else: print(-a) if if True: print('True') if elif elif else name='zhangsan'if name=='zhangsan': print('我是',name)elif name=='lisi': print('我是', name)elif name=='wangwu': print('我是', name)else: print('我谁的不是') # input（）输入输出 input () 返回的数据类型是 str print（） # 循环 迭代 list，tuple，dict 都可循环 Python 的 for 循环本质上就是通过不断调用 next() 函数实现的，计算是惰性的 dict 循环按照 value 时：for value in dict.values for value in d.values(): print(value)# for in sum=0for i in range(1,100): sum=sum+iprint(sum) # while sum2=0k=0while(k&lt;100): sum2=sum2+k k=k+1print(sum2) # break 如果要提前结束循环，可以用 break 语句 # continue 通过 continue 语句，跳过当前的这次循环，直接开始下一次循环 # 生成器 在 Python 中，这种一边循环一边计算的机制，称为生成器：generator。 包括生成器和带 yield 的 generator function。 g = (x * x for x in range(10)) 访问大文件 yield # isinstance（）迭代器 直接作用于 for 循环的对象统称为可迭代对象，都是迭代器 Iterable list 、 tuple 、 dict 、 set 、 str list 、 dict 、 str 虽然是 Iterable ，却不是 Iterator 。 list 、 dict 、 str 等 Iterable 变成 Iterator 可以使用 **iter ()** 函数 以直接作用于 for 循环的数据类型有以下几种： 一类是集合数据类型，如 list 、 tuple 、 dict 、 set 、 str 等； 一类是 generator ，包括生成器和带 yield 的 generator function。 可以使用 **isinstance ()** 判断一个对象是否是 Iterable 对象__iter__： 迭代对象 判断是不是可以迭代，用 Iterable from collections import Iterableisinstance({}, Iterable) --&gt; Trueisinstance((), Iterable) --&gt; Trueisinstance(100, Iterable) --&gt; False判断是不是迭代器，用 Iterator from collections import Iteratorisinstance({}, Iterator) --&gt; Falseisinstance((), Iterator) --&gt; Falseisinstance( (x for x in range(10)), Iterator) --&gt; TruePython 中 list，truple，str，dict 这些都可以被迭代，但他们并不是迭代器，为什么：：因为和迭代器相比有一个很大的不同，list/truple/map/dict 这些数据的大小是确定的，也就是说有多少事可知的。但迭代器不是，迭代器不知道要执行多少次，所以可以理解为不知道有多少个元素，每调用一次 next ()，就会往下走一步，是惰性的。 # 函数 抽象 将函数抽象成一个函数名称，不看内部结构直接调用方法 返回类型 函数名（输入参数）： 函数体 # 调用函数 要调用一个函数，需要知道函数的名称和参数 绝对值 abs # 定义函数 def myabs(x): if x&gt;0: return x if x&lt;0: return -xprint(myabs(-100)) # 空函数 def nufun(): passpass 可以用来作为占位符 # 函数 参数检查 def my_init_abs(x): if not isinstance(x,(int,float)): raise TypeError('no no no') else: if x&gt;0: print(x) if x&lt;0: print(-x)my_init_abs(-90) # 可返回多个值，函数 def return_much(): a='返回' b='我也返回' c='我也要返回' return a,b,cprint(return_much())print(type(return_much())) # 函数参数 *args 是可变参数，args 接收的是一个 tuple； **kw 是关键字参数，kw 接收的是一个 dict。 power(x) 函数，参数 x 就是一个位置参数，可单个变量，list，set，tuple power(*x) 函数，可传入单个变量，list，set，tuple，可以传入任意个参数或 0 个参数 power(**kw) 函数，字典 dict 可变参数允许你传入 0 个或任意个参数，这些可变参数在函数调用时自动组装为一个 tuple。 而关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict. power(x, n) ，用来计算 xn power(x, n) 函数有两个参数： x 和 n 默认参数，此时 age 和 city 为默认参数，可传值改变也可不变【不用传值】 power(L=None) 函数有 None 这个不变对象，可用 list def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city) # 必选参数 def a1(x): return xprint(a1(2))print(a1(12.1))print(a1('ruan'))print(a1(True))print(a1([1,2,3]))print(a1({1,2,3}))print(a1({\"key\":\"vleaue\",'name':'ruan','mun':23})) # = 默认参数 def a2(x=9): return xprint(a2())print(a2(2))print(a2(12.1))print(a2('ruan'))print(a2(True))print(a2([1,2,3]))print(a2({1,2,3}))print(a2({\"key\":\"vleaue\",'name':'ruan','mun':23})) # * 可变参数 def a3(*x): return xprint(a3())print(a3(2))print(a3(12.1))print(a3('ruan'))print(a3(True))print(a3([1,2,3]))print(a3({1,2,3}))print(a3({\"key\":\"vleaue\",'name':'ruan','mun':23})) # ** 关键字参数 def a3(**kw): return kwprint(a3())print(a3(kw=2))print(a3(kw=12.1))print(a3(kw='ruan'))print(a3(kw=True))print(a3(kw=[1,2,3]))print(type(a3(kw=[1,2,3])))print(a3(kw={1,2,3}))print(type(a3(kw={1,2,3})))print(a3(kw={\"key\":\"vleaue\",'name':'ruan','mun':23})) # 递归函数 在函数内部，可以调用其他函数。 一个函数在内部调用自身本身，这个函数就是递归函数。 使用递归函数需要注意防止栈溢出 #递归函数def funmyself(x): if x&gt;1: return x+funmyself(x-1) elif x==1: return 1print(funmyself(3)) 解决栈溢出方法： 尾递归优化，事实上尾递归和循环的效果是一样的 尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式 #尾递归def funmyself2(n): return funmyself2_it(n,1)def funmyself2_it(n,pro): if n==1: return pro else: return funmyself2(n-1)+nprint(funmyself2(100)) 此时 funmyself2 是尾递归函数 # 转义字符 \\ 转义字符 \\ 可以转义很多字符，比如 \\n 表示换行， \\t 表示制表符， 字符 \\ 本身也要转义，所以 \\\\ 表示的字符就是 \\ Python 还允许用 r'' 表示 '' 内部的字符串默认不转义 # 运算符 and、or 和 not 运算优先级：not&gt;or&gt;and # 除法 /// print(10/3)print(10//3)# 除法一 / 浮点数 # 除法二 // 地板除 整数 / 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： // ，称为地板除，两个整数的除法仍然是整数： # 取余 % print(10%1)print(10%3)print(4%7)print(2%20)#如果 a% b a&gt;b 则结果为 a # 字符编码 ASCII 编码 8 个比特（bit）作为一个字节（byte） 一个字节能表示的最大的整数就是 255（二进制 11111111 = 十进制 255） 两个字节可以表示的最大整数是 65535 ，4 个字节可以表示的最大整数是 4294967295 大写字母 A 的编码是 65 ，二进制的 01000001 ，小写字母 z 的编码是 122 Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题 ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节 ASCll 出现乱码问题引入 Unicode 编码存储空间多了一倍引入 UTF-8 编码 utf-8：将 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节， 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： # compile () 字符串编译为字节代码 # 编码转化 # ord ('A') 字母转字符 # chr (65) 字符转字母 a=ord('A')b=chr(65)print(a,b) # b'str' 转为字节类型 bytes bytes 类型的数据用带 b 前缀的单引号或双引号表示 x = b'ABC'要注意区分 'ABC' 和 b'ABC' ，前者是 str ，后者虽然内容显示得和前者一样，但 bytes 的每个字符都只占用一个字节。 # str.encode('ascii') str 变为 bytes ASCII UTF-8 # str.decode('utf-8') bytes 变为 str print(type(b'abc'))print(b'abc'.decode('utf-8'))print(type(b'abc'.decode('utf-8'))) len（str）计算字符数 函数计算的是 str 的字符数，如果换成 bytes ， len() 函数就计算字节数 print(len('abc'))print(len(b'abc'))print(len('中'))print(len('中'.encode('utf-8'))) # 特殊注释 #!/usr/bin/env python3# -*- coding: utf-8 -*-第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释； 第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 # 占位符 格式化 # 占位符 % s % d % f 格式化方式和 C 语言是一致 % 运算符就是用来格式化字符串的。 在字符串内部， %s 表示用字符串替换， %d 表示用整数替换， 有几个 %? 占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个 %? ，括号可以省略 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 转义： %% 来表示一个 % # format（）格式化字符串 # f-string 格式化字符串 {r} 被变量 r 的值替换， {s:.2f} 被变量 s 的值替换，并且 : 后面的 .2f 指定了格式化参数（即保留两位小数），因此， {s:.2f} 的替换结果是 19.62 # 函数式编程 函数是 Python 内建支持的一种封装，通过层层函数进行调用 #面向过程的程序设计 #：把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计 函数式和函数的区别： 对比例子：计算和计算器的区别 编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言 Python 不是纯函数式编程语言 函数式编程就是一种抽象程度很高的编程范式， 纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的 # 函数式编程特点： 纯函数式编程语言函数没有变量，输入输出确定 允许本身作为参数传入另一个函数，允许返回一个函数 # 高阶函数 参数中有函数 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回 # 变量可以指向函数 a = 函数 求绝对值的函数 abs() 为例 print(abs(-10))print(abs) abs（-10）是函数调用，abs 是函数本身 k=abs(-20)print(k)#函数本身也可以赋值给变量h=absprint(h)print(h(-100)) 结论：函数本身也可以赋值给变量，即：# 变量可以指向函数。# # 函数名也是变量 #函数名 #：其实就是指向函数的变量 a () 中 a 是指向函数 a（）的变量 # 传入函数 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 #高阶函数 #：一个函数就可以接收另一个函数作为参数 b() a(b) x=a def f(x): return abs(int(x))def a(a,b,f): return f(a)+f(b)if __name__ == '__main__': a1=input('a') a2=input('b') print(a(a1,a2,f)) 此时函数 a 为高阶函数，需要调用 f 函数作为参数 # map/reduce 内建函数 内建了 map() 和 reduce() 函数 高阶函数 # map（）函数处理生成新 Iterator 迭代器 两个参数，函数名【函数本身】，需要处理的编程式 iterator &lt;br /&gt; 创建一个迭代器，使用每个迭代器中的参数计算函数。当最短迭代用尽时停止。 map(func, *iterables) --&gt; map objectdef f(x): return x*xr=map(f,[1,2,3,4,4,4,4,4,4,4,4])print(r)print(type(r))print(list(r))print(type(list(r))) 运算规则抽象 # reduce（）函数作用在序列上 两个参数，函数名【函数本身】，需要处理的 #序列 #： sequence (序列) 是一组有顺序的元素的集合 序列基本样式 [下限：上限：步长] reduce 把结果继续和序列的下一个元素做累积计算 reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 # filter () 过滤序列 参数和 map（）相似 filter() 也接收一个函数和一个序列 # sorted（）排序 高阶函数 参数：排序对象，key = 函数 sorted([36, 5, -12, 9, -21], key=abs)排序的核心是比较两个元素的大小 print(sorted([1,2,353,6,3,234,43,435])) key 指定绝对值大小排序 print(sorted([1,2,353,6,3,234,43,435,-242,-34,34,35],key=abs)) # 返回函数 # 函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回 # 如果不需要立刻求和，而是在后面的代码中，# 根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：def zary_sum(a): def sum(): sum1=0 for i in a: sum1=sum1+i return sum1 return sumprint(type(zary_sum([1,2,3,4])))f=zary_sum([1,2,3,4])print(f()) 调用返回函数时，每次调用都会新生成一个函数 # 闭包 当一个函数的返回值是另外一个函数， 而返回的那个函数如果调用了其父函数内部的其它变量，如果 返回的这个函数在外部被执行，就产生了闭包 。 返回函数中，返回的函数调用父函数的内部变量 #返回函数def count(): fs=[] for i in range(1,4): def f(): return i*i fs.append(f) return fsf1,f2,f3=count()print(f1(),f2(),f3()) 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。 # lambda（）匿名函数 lambda 关键字 函数参数：函数表达式 传入函数时，有些时候，不需要显式地定义函数 Python 对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。 lambda x:x*x#等价于def f(x): return x*x关键字 lambda 表示匿名函数，冒号前面的 x 表示函数参数，只能一个表达式 不用写 return ，返回值就是该表达式的结果。 匿名函数也是一个函数对象 f=lamdba x:x*x判断奇数函数 原函数： def is_odd(n): return n % 2 == 1L = list(filter(is_odd, range(1, 20)))采用匿名函数修改 l=list(filter(lambda x:x%2==1,range(1,20)))print(l) # 装饰器 Decorator # 本质上，装饰器就是一个返回函数的高阶函数 @log 等价于 now = log(now)由于函数也是一个对象，而且函数对象可以被赋值给变量， 所以，通过变量也能调用该函数 def log(func): def wrapper(*args,**kwargs): print('call %s'% func.__name__) return func(*args,**kwargs) return wrapper()#func 为参数所以是高阶函数#return 函数所以是返回函数，#没有调用父函数中参数，所以不是闭包 场景注意： 无 @装饰器时函数不调用，需要参数才调用 当 @时会直接调用装饰器定义函数然后执行函数，不用调用函数 三层时，传入参数 def log1(text): def decorator(func): def wapper(*args,**kw): print('%s %s'%(text,func.__name__)) return func(*args,**kw) return wapper return decorator@log1('ruan')def now3(): print(\"hhh\")now3()相当于在返回高阶函数上还有一个函数，所以返回时应该还要调用一次 # @wraps 常用装饰器 当装饰器是个闭包时，装饰器调用变量会改变增加 @wraps 后装饰器内的变量不变 装饰器在装饰一个函数时，，原函数就成了一个新的函数，也 就是说其属性会发生变化，所以为了 不改变原函数的属性， 我们会调用 functools 中的 wraps 装饰器来保证原函数的属性不变 # 不加 wraps 时 @wraps(func)from functools import wrapsdef wrap(func): def b(): 'b' print('decorator:',b.__name__) print('funname',func.__name__) func() return b@wrapdef a(): 'a' print('name',a.__name__)a() 加装饰器 wraps 时 from functools import wrapsdef wrap(func): @wraps(func) def b(): 'b' print('decorator:',b.__name__) print('funname',func.__name__) func() return b@wrapdef a(): 'a' print('name',a.__name__)a() 闭包的概念：调用父函数中的变量的函数，为了保证数据安全。变量作用域只在函数内部，可在闭包中操作数据。 装饰器返回为什么是函数名（函数内存地址）而不直接执行函数？ 当有参数传入时，可直接与调用的函数中的值传入参数执行。 （）是运算符 f () 与 f.call () 等价：将 f 对象变成变成可调用的对象 # 偏函数（functools 模块） 属于 functools 模块 # 作用： 通过设定参数的默认值，降低函数调用的参数 int() 函数默认按十进制转换 print(int('100',base=8)) 经常调用于是重写一个函数 int2 def int2(x, base=8): print(int(x, base)) return int(x, base)print(int2('2334'))采用偏函数 import functoolsint3=functools.partial(int,base=8)print(int3('46'))print(int()) functools.partial 的作用是将函数的特定参数固定住（设定为默认值） 创建偏函数的时候也可以接收，函数对象，*args，**kw # 模块 python 包：作用区分相同名称的模块 模块相当于一个 py 文件 # 作用域 仅仅在模块内部使用。在 Python 中，是通过 _ 前缀来实现的。 # pubilc 公开 正常的函数和变量名是公开的（public） # private 非公开_,__ _xxx 和__xxx 这样的函数或变量就是非公开的（private） # 安装第三方模块 pip pip install 模块名 # 模块搜索路径 import sysprint(sys.path)两种方式： 添加搜索路径import syssys.path.append('/Users/michael/my_py_scripts') 设置环境变量 第二种方法是设置环境变量 PYTHONPATH # 面向对象编程 面向对象编程 ——Object Oriented Programming，简称 OOP，是一种程序设计思想 对象作为程序的基本单元， 一个对象包含了数据和操作数据的函数 数据封装、继承和多态是面向对象的三大特点 # 类和实例 面向对象最重要的概念就是类（Class）和实例（Instance） 类是抽象出来的模板 实例是根据类创建出的对象，每个对象可能有属性和方法 定义类是通过 class 关键字，类名通常是大写开头的单词 class Student(object): pass ！！！在类中定义函数有一点不同，定义佛如方法第一个参数永远是实例变量本身 self 仍然可以用默认参数、可变参数、关键字参数和命名关键字参数 # 数据封装 class Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' # 访问限制 # 作用： 确保了外部代码不能随意修改对象内部的状态 实例的变量名如果以 __ 开头，就变成了一个私有变量（private） 外部无法访问_name class Student(object): def __init__(self,name,age): self._name=name self.age=age def print_name(self): print(self._name) return self.age,self._namea=Student('ruan',23)h=a.print_name()print(h) 若是要获取，修改变量增加 get，set 方式即可 class Student(object): def __init__(self,name,age): self._name=name self.age=age def get_name(self): return self.name def set_name(self,name): self._name=namePython 本身没有任何机制阻止你干坏事，一切全靠自觉。 类外部无法访问 # 继承和多态 # 继承 # 多态 在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。 比如：动物是父类，狗和鱼是子类；鱼是鱼类，鱼是动物都成立。 判断一个变量是否是某个类型可以用 isinstance() 判断 # 鸭子类型 并不要求严格的继承体，一个对象只要 “看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 # 获取对象信息 # type（）判断对象类型 # isinstance () 对于继承关系，判断 class 的类型 # dir（）获取对象的所有属性和方法 # len（）对象长度 # lower（）返回小写的字符串 # getattr（）获取属性 a # setattr（）设置属性 a # hasattr（obj,'a'）判断是否有属性 a getattr(obj, 'z', 404) # 获取属性 'z'，如果不存在，返回默认值 404404# 实例属性和类属性 class Student(object): name='ruan' h=Student()h.name='hhh'类中的 name 是类属性， 创建 h 类对象即实例后赋值的是实例属性 name，但由于实例对象的优先级比类属性高，会屏蔽类中的 name 属性，即 h.name 的值为 hhh # 总结： 实例属性属于各个实例所有，互不干扰； 类属性属于类所有，所有实例共享一个属性； 不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误 # 面向对象高级编程 数据封装、继承和多态只是面向对象程序设计中最基础的 3 个概念 多重继承、定制类、元类 # _slots_使用 可以给创建的实例绑定属性和方法 给一个实例绑定的方法对另外一个实例对象是不起作用的 class A: def run(self): print(\"i im ferther runing....\")sun1=A()#给实例 sun1 设置 name 属性sun1.name='i im name'#创建实例对象 2sun2=A()#实例对象 sun1 的属性和 sun2 无关，即 sun2 没有 name 属性#给实例 sun1 绑定方法，方法和属性同理#定义方法def setAll(self,num): print(num)sun1.newfun=MethodType(setAll, sun1)sun1.newfun(37)#若所有实例都需要绑定方法则给类绑定方法A.setAll=setAll#给类绑定方法后，所有创建的实例的均可调用def set_age(self, age): # 定义一个函数作为实例方法 ... self.age = age ... &gt;&gt;&gt; from types import MethodType &gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法 &gt;&gt;&gt; s.set_age(25) # 调用实例方法 # 限制实例属性，定义一个特殊的 __slots__ 变量 class Student(object): __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称s=Student()s.name='ruan's.firstname='i im firstname'#输出的时候 firstname 的属性会报错，Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'firstaname'# 注意： _slots_使用时要注意，定义的属性只在当前的类的实例中，对于继承的子类是不起作用的 class People(object): __slots__ = ('name','age') def run(self): print('i im run people......')class Teacher(People): def say(self): print('i im teacher....')t=Teacher()t.tall='shouhua'print(t.tall)p=People()p.tall('shouhuap')print(p.tall) 只限制父类 People 的属性，而子类 Teacher 中不限制 # @property 在绑定属性时，如果我们直接把属性暴露出去，导致可以随意更改。通过 get，set 来获取更改属性值。 在 python 中直接调用装饰器将一个方法变成属性调用 class Student(object): @property #使用 get 方法是调用装饰器 @peoperty， # 同时自动创建了另一个装饰器 @属性.setter def score(self): return self.score @score.setter def score(self,value): self._score=value# 总结： - 权限限制只对类对象实际起作用，想要达到方法和属性强制访问权限，需要使用 @property 装饰器进行 get，set 方法 属性名与方法名一定要区分开，不然会进入死循环（self._age，def age ()） 实例化的对象使用属性时，不是调用属性（meizi._age），而是用的方法名（meizi.age） @property 其实就是实现了 getter 功能； @xxx.setter 实现的是 setter 功能；还有一个 @xxx.deleter 实现删除功能 定义方法的时候 @property 必须在 @xxx.setter 之前，且二者修饰的方法名相同（age ()） 如果只实现了 @property（而没有实现 @xxx.setter），那么该属性为 只读属性 #请利用 @property 给一个 Screen 对象加上 width 和 height 属性，# 以及一个只读属性 resolution：class Screen(object): __slots__ = ('_width','_height','_resolution') @property def width(self): return self._width # 方法名称和实例变量均为 width: @width.setter def width(self,widthValue): self._width=widthValue @property def height(self): return self._height @width.setter def height(self, height): self._height = height @property def resolution(self): return self._width * self._heights=Screen()s.width=23s.height=12print(s.resolution) s.score = 60 # OK，实际转化为 s.set_score (60)s.score # OK，实际转化为 s.get_score ()要特别注意：属性的方法名不要和实例变量重名。例如，以下的代码是错误的： class Student(object): # 方法名称和实例变量均为birth: @property def birth(self): return self.birth 出现递归调用错误 之前的例子中 width 和_width 不同所以可以运行 # 多重继承 python 可以支持多继承，即一个子类可以继承多个父类；但 java 是单继承，只能有一个父类 Tercher（Name，study，teach）即 Teacher 可以继承多个父类 # MixIn 在设计类的继承关系时，通常，主线都是单一继承下来的，例如， Teacher 继承自 Name。但是，如果需要 “混入” 额外的功能，通过多重继承就可以实现，比如 Teacher 除了继承自 Name 外，再同时继承 Teach 。这种设计通常称之为 MixIn Python 自带了 TCPServer 和 UDPServer 这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由 ForkingMixIn 和 ThreadingMixIn 提供。 # 多继承 多重继承这个名词一般用来形容继承链条可以很长，多个层次。 # 多重继承 多继承则指一个类可以有多个基类，相反则是单继承。任何面向对象编程语言都支持多重继承，但像 java 这种只能通过接口实现有限程度的多继承 问：多继承 如果多个类有共同得方法名 怎么区分是调得哪个类🤡 答：调用该方法的时候，会调用第一顺位继承父类的方法 # 总结： Python 允许使用多重继承，因此，MixIn 就是一种常见的设计 只允许单一继承的语言（如 Java）不能使用 MixIn 的设计 # 定制类 Python 的 class 中还有__xxx__有特殊用途的函数，可以帮助我们定制类 # str () 回用户看到的字符串 将对象 &lt;__main__.Student object at 0x109afb190&gt; 变成易读的数据 只在调用 print 时会调用__str__，交互界面时还是现实上方不易读的对象内容，此时用 # repr () 返回程序开发者看到的字符串 __str__() 返回用户看到的字符串，而 __repr__() 返回程序开发者看到的字符串， 也就是说， __repr__() 是为调试服务的 简写 def __str__(self): return 'xxx object (name=%s)' % self.name__repr__ = __str__# _iter () 返回一个迭代对象 需要用到 for in 迭代，需要转化为迭代对象 该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 __next__() 方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环 例子： class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.aa=Fib()for i in a: print(i) # getitem () 表现得像 list 那样按照下标取出元素 class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.a def __getitem__(self, item): a,b=1,1 for i in range(item): a,b=b,a+b return aa=Fib()print(a[3]) 以上是传入 int，切片功能实现，isinstance 判断类型 class Fib(object): def __init__(self): self.a,self.b=0,1 def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;1000: raise StopIteration return self.a def __getitem__(self, item): if isinstance(item,int): a, b = 1, 1 for i in range(item): a, b = b, a + b return a if isinstance(item,slice): start=item.start stop=item.stop if start is None: start=0 a,b=1,1 L=[] for x in range(stop): L.append(a) a,b=b,a+b return La=Fib()print(a[3:12]) # getattr () 动态返回一个属性 调用类属性或方法时，先在__init__() 获取后，再从__getattr__() 获取，获取不到才报错 # call () 直接调用实例本身 与直接调用这个函数一样 class People(object): def __init__(self,name): self.name=name def __call__(self, *args, **kwargs): print('i im call %s'% self.name)p=People('ruan')p() # 使用枚举类 枚举类：在某些情况下，一个类的 实例对象 的数量是 有限且固定 的，如季节类，它的实例对象只有春、夏、秋、冬。 在 Java 中像这种对象实例有限且固定的类被称为枚举类；这样的枚举类型定义一个 class 类型，然后，每个常量都是 class 的一个唯一实例。Python 提供了 Enum 类来实现这个功能。 from enum import EnumM=Enum('a',('sun1','sun2','sun3','sun4'))print(M.sun1) 自定义枚举类 from enum import Enum,unique@uniqueclass Week(Enum): sun1=1 sun2=2 sun3=3day2=Week.sun2print(day2) from enum import Enum,unique@uniqueclass Gender(Enum): Male=0 Female=1class Student(object): def __init__(self,name,gender): self.name=name self.gender=gender# 测试:bart = Student('Bart', Gender.Male)if bart.gender == Gender.Male: print('测试通过!')else: print('测试失败!') # 使用元类 [创建类] 实例对象是类创建 类是元类创建 创建类的方式 # 方式一：type（） type() 函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过 type() 函数创建出 Hello 类 from class1104 import *h=Hello()print(type(h))print(type(Hello)) Hello = type('Hello', (object,), dict(hello=fn))要创建一个 class 对象， type() 函数依次传入 3 个参数： class 的名称； 继承的父类集合，注意 Python 支持多重继承，如果只有一个父类，别忘了 tuple 的单元素写法； class 的方法名称与函数绑定，这里我们把函数 fn 绑定到方法名 hello 上 # 方式二：元类 metaclass 先定义 metaclass，然后创建类。 先定义类，然后创建实例。 metaclass 是 Python 面向对象里最难理解，也是最难使用的魔术代码。 按照默认习惯，metaclass 的类名总是以 Metaclass 结尾，以便清楚地表示这是一个 metaclass # metaclass 采用 type 创建类 ，metaclass 是类的模板，所以必须从 `type` 类型派生class ListMetaclass(type): def __new__(cls, name,bases,attrs): attrs['add']=lambda self, value:self.append(value) return type.__new__(cls,name,bases,attrs)class MyList(list,metaclass=ListMetaclass): passmylist=MyList()mylist.add(1)print(mylist) __new__() 方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法集合 # 应用场景 ORM 全称 “Object Relational Mapping”，即对象 - 关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作 SQL 语句。 要编写一个 ORM 框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。 # 错误处理 try try: print('try...') r = 10 / 0 print('result:', r)except ValueError as e: print('ValueError:', e)except ZeroDivisionError as e: print('ZeroDivisionError:', e)e)finally: print('finally...')print('END')Python 的错误其实也是 class，所有的错误类型都继承自 BaseException UnicodeError 是 ValueError 的子类🤡 Built-in Exceptions — Python 3.10.0 documentation # 调用栈 让 Python 解释器来打印出错误堆栈 # 记录错误 logging 可将 logging 生成一个 txt 方便查看 try: xxx except Exception as e: logging.exception(e)# 抛出错误 raise except ValueError as e: print('ValueError!') raise在 bar() 函数中，我们明明已经捕获了错误，但是，打印一个 ValueError! 后，又把错误通过 raise 语句抛出去了，这不有病么？ 其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。 # 调试方法 # 1. print（） # 2. 断言 assert assert n != 0, 'n is zero!'assert 的意思是，表达式 n != 0 应该是 True ，否则，根据程序运行的逻辑，后面的代码肯定会出错。 采用断言的好处： 启动 Python 解释器时可以用 -O 参数来关闭 assert ： $ python -O err.py 关闭后，你可以把所有的 assert 语句当成 pass 来看 # 3. logging import loggings = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)# 4.pbd 单步执行 启动 Python 的调试器 pdb，让程序以单步方式运行，可以随时查看运行状态。 python -m pdb xxx.py(Pbd) 1#查看第一行代码，单步执行第一行代码# 5. pdb.set_trace() 这个方法也是用 pdb，但是不需要单步执行，我们只需要 import pdb ，然后，在可能出错的地方放一个 pdb.set_trace() ，就可以设置一个断点： import pdbs = '0'n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n)可以用命令 p 查看变量，或者用命令 c 继续运行： # 6.IDE 工具 vscode,pycharm.... # 单元测试 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 # 文档测试 doctest 非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含 doctest 的注释提取出来。用户看文档的时候，同时也看到了 doctest。 Python 内置的 “文档测试”（doctest）模块可以直接提取注释中的代码并执行测试. class Dict(dict): \"\"\"\" 这一段就是文档测试 Simple dict but also support access as x.y style. &gt;&gt;&gt; d1 = Dict() &gt;&gt;&gt; d1['x'] = 100 &gt;&gt;&gt; d1.x 100 &gt;&gt;&gt; d1.y = 200 &gt;&gt;&gt; d1['y'] 200 &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3') &gt;&gt;&gt; d2.c '3' &gt;&gt;&gt; d2['empty'] Traceback (most recent call last): ... KeyError: 'empty' &gt;&gt;&gt; d2.empty Traceback (most recent call last): ... AttributeError: 'Dict' object has no attribute 'empty' \"\"\" def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key) def __setattr__(self, key, value): self[key] = valueif __name__ == '__main__': import doctest doctest.testmod()将其中一个函数注释，运行让它报错 # IO 编程 程序和运行时的数据在内存中驻留 涉及到数据交换的地方，通常是磁盘、网络等，就需要 IO 接口 通常，程序完成 IO 操作会有 Input 和 Output 两个数据流 Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。 在 IO 编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把 100M 的数据写入磁盘，CPU 输出 100M 的数据只需要 0.01 秒，可是磁盘要接收这 100M 数据可能需要 10 秒，怎么办呢？有两种办法： # 同步 IO 第一种是 CPU 等着，也就是程序暂停执行后续代码，等 100M 的数据在 10 秒后写入磁盘，再接着往下执行，这种模式称为同步 IO； # 异步 IO 另一种方法是 CPU 不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步 IO。 如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步 IO 的复杂度远远高于同步 IO。 # 文件读写 # 读文件 open（） 传入文件名，标示符 参数：'rb' 二进制 encoding='gbk' 字符编码 f = open('/Users/michael/test.txt', 'r')# read () 一次读取全部内容 f.read()'Hello, world!'# f.close（）关闭文件 简化方法 # with open('filepath', 'r') as f: print(f.read()) Python 引入了 with 语句来自动帮我们调用 close() 方法，并且不必调用 f.close() 方法 with open('/path/to/file', 'r') as f: print(f.read())如果文件很小， read() 一次性读取最方便； 如果不能确定文件大小，反复调用 read(size) 比较保险； 如果是配置文件，调用 readlines() 最方便 for line in f.readlines(): print(line.strip()) # 把末尾的 '\\n' 删掉file 和缓存时 = 是 file-like Object 对象，不要求从特定类继承，只要写个 read() 方法就行 # f.write () 写文件 f = open('/Users/michael/test.txt', 'w')f.write('Hello, world!')f.close()或 with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!')使用 with 语句操作文件 IO 是个好习惯 # StringIO 和 BytesIO # StringIO StringIO 顾名思义就是在内存中读写 str from io import StringIO f = StringIO()f.write('hello')getvalue() 方法用于获得写入后的 str from io import StringIO&gt;&gt;&gt; f = StringIO('Hello!\\nHi!\\nGoodbye!')&gt;&gt;&gt; while True:... s = f.readline()... if s == '':... break... print(s.strip())# BytesIO 操作二进制数据，就需要使用 BytesIO &gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'# os 模块 # os.name 操作系统类型 # os.uname () 详细系统信息 # os.enciron 环境变量 要获取某个环境变量的值，可以调用 os.environ.get('key') # 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath('.')'/Users/michael'# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')'/Users/michael/testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')通过 os.path.join() 函数，这样可以正确处理不同操作系统的路径分隔符 # os.path.join( ) 连接路径 # os.path.split() 拆分路径 # os.path.splitext() 文件扩展名 # 对文件重命名:&gt;&gt;&gt; os.rename('test.txt', 'test.py')# 删掉文件:&gt;&gt;&gt; os.remove('test.py')shutil 模块提供了 copyfile() 的函数，它们可以看做是 os 模块的补充 最后看看如何利用 Python 的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码： &gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)] ['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...] 要列出所有的 .py 文件，也只需一行代码： &gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py'] ['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py'] # 序列化 pickle 模块 变量从内存中变成可存储或传输的过程称之为序列化，Python 中叫 pickling 变量内容从序列化的对象重新读到内存里称之为反序列化，即 unpickling # pickle.dumps () 对象 -》字节 [序列化] pickle.dumps() 方法把任意对象序列化成一个 bytes pickle.dumps() 方法把任意对象序列化成一个 bytes , 并写入文件中 import pickled=dict(name='ruan',age=34,freand='woman')# print(pickle.dumps(d))f = open('timezone.txt', 'wb')pickle.dump(d, f)f.close()# pickle.load () 字节 -》对象【反序列化】 import picklef=open(r'C:\\Users\\yangs\\PycharmProjects\\python_study\\fun\\timezone.txt','rb')d=pickle.load(f)f.close()print(d) # json 模块 json 模块的 dumps() 和 loads() 函数是定义得非常好的接口的典范。 # json.dumps (python 对象) python 对象 -》json 对象 dumps() 方法返回一个 str ，内容就是标准的 JSON # json.loads (json 对象) json 对象 -》python 对象 json.``dump (obj,&nbsp;fp,&nbsp;,&nbsp;skipkeys=False,&nbsp;ensure_ascii=True,&nbsp;check_circular=True,&nbsp;allow_nan=True,&nbsp;cls=None,&nbsp;indent=None,&nbsp;separators=None,&nbsp;default=None,&nbsp;sort_keys=False,&nbsp;kw)* # 类变为字典并序列化 json.dumps(s, default=lambda obj: obj.__dict__)# 进程和线程 Python 的标准库提供了两个模块： _thread 和 threading ， _thread 是低级模块， threading 是高级模块 线程是最小的执行单元，而进程由至少一个线程组成 操作系统轮流让各个任务交替执行 真正的并行执行多任务只能在多核 CPU 上实现 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程 Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个 “子任务”，我们把进程内的这些 “子任务” 称为线程（Thread） 多进程模式； 多线程模式； 多进程 + 多线程模式。 # 多进程 Unix/Linux 操作系统提供了一个 fork() 系统调用，普通的函数调用，调用一次，返回一次，但是 fork() 调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 创建子进程 from multiprocessing import Processimport osdef run_pro(name): print('开始运行子进程%s，%s'%(name,os.getpid()))if __name__ == '__main__': print('开始运行进程%s' % (os.getpid())) p=Process(target=run_pro,args=('test',)) p.start() p.join() print('end') # 启动大量子进程 pool 进程池 import time, threading# 新线程执行的代码:def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name)# 模块总结 # doctest 文档测试 # os.path 文件路径 # pickle 序列化 # json document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Django详细介绍todolist实例","slug":"computer-science/python/django/course-1/Django详细介绍todolist实例","date":"2022-01-05T02:41:40.000Z","updated":"2023-11-30T09:56:16.674Z","comments":true,"path":"computer-science/python/django/course-1/Django详细介绍todolist实例/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/Django%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8Dtodolist%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"# 开发环境 python3.7 django win10（64 位） # 什么是框架 通俗的说，框架是实现某种功能的半成品，提供了一些常用的工具类和一些基础通用化的组件，可以供开发人员在此基础上，更高效的满足各自的业务需求。 # 为什么要使用框架 一个优秀的的框架，它相当于是一个模板代码库，很多基础性的功能，底层功能操作都已经帮我们实现了，我们只需要专心的实现所需要的业务逻辑就可以了。这样，就大大提高了我们的开发效率，所以技术的发展，多数情况下是为了满足业务的需求。 简单，快捷，高效，响应，兼容 # 什么是 django 我们都知道，Django 是基于 Python 的 Web 开发框架。 百度百科介绍： Django 是一个开放源代码的 Web 应用框架，由 Python 写成。采用了 MTV 的框架模式，即模型 M，视图 V 和模版 T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是 CMS（内容管理系统）软件。并于 2005 年 7 月在 BSD 许可证下发布。 这套框架是以比利时的吉普赛爵士吉他手 Django Reinhardt 来命名的。 有一家劳伦斯的出版社，说白了就想新浪。这种网站会涉及到什么问题呢我们来看一下： 只需进行数据库替换，采用此模板样式不变，那网站的开发速率提高 # django 目的和用途 django 的主要目的是简便，快速的开发数据库驱动的网站，他强调代码复用。 多个组件看依方便的以 “插件” 形式服务整个框架 所有的 web 框架的意义都在于： 搭建框架应用 免去不同 web 应用相同代码的部分重复编写，只需关心应用核心的业务实现 }}} }}} # django 的特点 对比 Flask 框架，Django 原生提供了众多的功能组件，让开发更便捷 提供项目工程管理的自动脚手工具（脚手架工具） 数据库 ORM 支持（对象关系映射）[外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-GygyZD04-1632645131208)(assets/image-20210921214755-gc5rj3l.png)]【不会 sql 语句也可以实现】 模板【replace，可以通过变量将模板和数据打通。使用数据替换模板变量，达到动态展示效果】 表单【表单获取直接转化成对象处理】 admin 管理站点【自动生成后台】 文件管理 认证权限 session 机制 缓存 如果 Django 类似于精装修的房子，自带豪华家具、非常齐全功能强大的家电，什么都有了，拎包入住即可，十分方便。重量级框架，快捷。 而 Flask 类似于毛坯房，自己想把房子装修成什么样自己找材料，买家具自己装。材料和家具种类非常丰富，并且都是现成免费的，直接拿过去用即可。轻量级，灵活。 # MVT 设计模式 前端客户端发起请求，请求可能是用户点击浏览器发起的，app，ajax 请求或是爬虫程序， 服务器：接受和解析 http 请求报文，他的服务对象是 http 请求 框架：后端服务框架，服务器解析成字典格式 视图：定义数据处理方法：index（）然后经处理完的结果变成响应对象，发送给服务器 中间层：装饰器 作用：在不添加源代码的情况下增加功能 #补充知识点# ((20210923102902-68l094i)) WSGI 只是一个 PythonWeb 服务器网关接口协议，或者说是一份标准，用来描述 Server 与 Framework 之间的通信接口。 这样，一些符合 WSGI 标准的 Framework 如 Flask、Django、web.py 等等就可以与同样符合 WSGI 标准的 Server 库进行无缝对接。 只要你的 Framework 符合 WSGi 规范，那么在以后有了效率更高的 Server 的时候，你可以毫不费力地将代码迁移过去。 #场景 #：开发了几个应用后，发现每个应用都完成了从监听网络端口到建立连接、解析请求的参数、进行回应、发送 Response 数据包等等一系列的工作，每次都要在获取请求、解析请求、发送请求这些一成不变的步骤上花费大量时间，不如写个 Server 模块，把这些功能单独实现，以后再有新的需求，只需要考虑 Framework 部分即可，这样就可以避免 “重复造轮子” 了。当自己写好了一套 server 程序，隔壁老王听说你写了个 Server 程序很牛掰，想要借用一下你的代码。你本着开源精神将 Server 模块分享给他，可是，老王拿到代码一看就傻眼了 —— 天啊，你的 Server 部分的数据接口、函数调用方式和他自己写的 Framework 完全不搭，改动起来难度颇大，还不如自己再写一个 Server 来得方便。应该整一套接口规范出来，让老王在编写自己的 Framework 的时候就按照你设计的规范来写，这样写出来的程序才能够互相 “契合”，便于调试和使用。就是 WSGI（Python Web Server Gateway） # MVC 程序设计模式：MVC，核心思想 **：分工，解耦 **，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容 M 全拼为 Model，主要封装对数据库的访问，对数据库中数据进行增删改查操作 V 全拼为 View，用于封装结果，生成页面展示的 html C 全拼 Controller，用于接收请求，处理业务逻辑，与 Model 和 View 进行交互，返回结果 # MVT 原理就是 mvc 不过自己将名字改了 M 全拼为 Model，与 MVC 中的 M 功能相同，主要封装对数据库的访问，对数据库中数据进行增删改查操作 V 全拼为 View，与 MVC 中的 C 功能相同，用于接收请求，处理业务逻辑，与 Model 和 View 进行交互，返回结果 T 全拼 Template，与 MVC 中的 V 功能相同，用于封装结果，负责封装构造要返回的 html ((20210924115549-5h51jh6)) # 虚拟环境 # 什么场景需要用虚拟环境 比如两个项目在并行，然后用到的 python 和 django 版本不一样 解释器一样包都可能不一样 # 虚拟环境效果 [ ((20210923111014-udk4aum)) # 实战 # 搭建环境 默认会下载最新版本 pip install django # 创建工程 进入想要创建的项目目录下 再命令行中输入 django-admin startproject todo 查看文件 采用 pycharm 打开项目 然后进入项目中 cd todo 尝试启动服务器 在开发阶段，未来能够快速预览到开发效果 django 提供了一个纯 python 编写的轻量级 web 服务器，仅在开发阶段使用。 python manage.py runserver 这样这是成功 python manage.py migrate # 创建管理员账号 python manage.py createsuperuser 重新启动服务器： 登陆刚注册号的账号密码 进入数据管理页面 http://localhost:8000/admin 终止服务器， Ctrl+C # 创建子应用 python manage.py startapp tasks 查看目录中的结构 # 配置 app 路径 然计算机找到创建的 app 在添加 'tasks' 查找定位到 app 的路径 跟项目路径： 之前 django2.x BASE_DIR =as.path.dirname(os.path.dirname(os.path.abspath(__file__))) 引入 path 之后 BASE_DIR = Path(__file__).resolve().parent.parent C:\\Users\\yangs\\Desktop\\ 新建文件夹 \\todo\\todo\\settings.py # 创建视图函数 再 app tasks 中创建视图函数 view index from django.shortcuts import render from django.http import HttpResponse ## Create your views here. def index(request): return HttpResponse('hello djangho') # 创建 urls 路由 # 配置项目 urls \"\"\"todo URL Configuration The `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/3.2/topics/http/urls/ Examples: Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: path('', views.home, name='home') Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: path('', Home.as_view(), name='home') Including another URLconf 1. Import the include() function: from django.urls import include, path 2. Add a URL to urlpatterns: path('blog/', include('blog.urls')) \"\"\" from django.contrib import admin from django.urls import path,include urlpatterns = [ path('admin/', admin.site.urls), path('',include('tasks.urls')) ] # 重启服务器 重新启动服务器 python manage.py runserver # 创建模板 创建文件夹 templates 中再创建 tasks 文件夹中创建 list.html [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-Yhxl9wbo-1632645131300)(assets/clipboard-20210921230301-1lv02wo-20210924095934-379n9oy.png)] &lt;h3&gt;TODO&lt;/h3&gt;# 修改视图 修改 app tasks 中的 views from django.shortcuts import render from django.http import HttpResponse # Create your views here. def index(request): return render(request,'tasks/list.html') 此时出现 别着急看看错误提示 # 配置模板默认路径 显示找不到 list.html 文件，所以我们将从配置 setting 中设置 \"\"\" Django settings for todo project. Generated by 'django-admin startproject' using Django 3.2.6. For more information on this file, see https://docs.djangoproject.com/en/3.2/topics/settings/ For the full list of settings and their values, see https://docs.djangoproject.com/en/3.2/ref/settings/ \"\"\" import os from pathlib import Path # Build paths inside the project like this: BASE_DIR / 'subdir'. BASE_DIR = Path(__file__).resolve().parent.parent # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/ # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = 'django-insecure-+(9j8^8xt6(5aa79o^bp8g8#t#lpuif3u424yx55bz=yrk@)d%' # SECURITY WARNING: don't run with debug turned on in production! DEBUG = True ALLOWED_HOSTS = [] # Application definition INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'tasks', ] MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] ROOT_URLCONF = 'todo.urls' TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], #连接成模板目录 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] WSGI_APPLICATION = 'todo.wsgi.application' # Database # https://docs.djangoproject.com/en/3.2/ref/settings/#databases DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': BASE_DIR / 'db.sqlite3', } } # Password validation # https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ { 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', }, { 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', }, { 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', }, { 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', }, ] # Internationalization # https://docs.djangoproject.com/en/3.2/topics/i18n/ LANGUAGE_CODE = 'en-us' TIME_ZONE = 'UTC' USE_I18N = True USE_L10N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/3.2/howto/static-files/ STATIC_URL = '/static/' # Default primary key field type # https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField' 此时刷新一下： # 创建模型 之后我们来创建 model 文件 from django.db import models # Create your models here. class Task(models.Model): title=models.CharField(max_length=200) complete=models.BooleanField(default=False) create=models.DateTimeField(auto_now_add=True) def __str__(self): return self.title 再命令行中输入： # 更新数据库 python manage.py makemigrations python manage.py migrate 将数据库进行更新 # 启动服务器： python manage.py runserver 访问 8000:/admin [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-KLguiQfn-1632645131322)(assets/clipboard-20210921230301-svzfg5q-20210924095934-vw2uo7h.png)]\" /&gt; 没有发现新建的 model # 用户和 model 进行关联 需要将用户和 model 进行关联 在 app tasks 中 admin 中 from django.contrib import admin from .models import * # Register your models here. admin.site.register(Task) 重新刷新页面 其中新创建的模块 # 添加数据库数据 添加数据并在数据库中查看数据： &lt;br /&gt; 现在我们想要将数据库中的数据显示在 views 中 将 models 中映射的数据放在 view 中展示出来 # 展示数据 # 修改 view 在 app tasks 中 view 修改 from django.shortcuts import render from django.http import HttpResponse from .models import * # Create your views here. def index(request): tasks=Task.objects.all() context={'tasks',tasks} return render(request,'tasks/list.html',context) # 修改 html 将数据传入模板当中 list.html &lt;h3&gt;TO DO&lt;/h3&gt;在 app tasks 中创建 form 文件 # 创建 form from django import forms from django.forms import ModelForm from .models import * class TaskForm(forms.ModelForm): class Meta: model=Task fields='__all__' # 修改 view 在 view 中更改： from django.shortcuts import render from django.http import HttpResponse from .models import * from .forms import * # Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) &lt;br /&gt; # 更改模板文件： &lt;h3&gt;TO DO&lt;/h3&gt; &lt;form&gt; {{form}} &lt;input type=\"submit\" name=\"create Task\"&gt; &lt;/form&gt; {% for task in tasks %} {{task.title}} {% endfor %} 查看页面： # 添加数据 # 修改模板 html 页面： &lt;h3&gt;TO DO&lt;/h3&gt; &lt;form method=\"POST\" action=\"/\"&gt; {{form}} &lt;input type=\"submit\" name=\"create Task\"&gt; &lt;/form&gt; {% for task in tasks %} {{task.title}} {% endfor %} &lt;br /&gt; &lt;br /&gt; from django.shortcuts import render,redirect from django.http import HttpResponse from .models import * from .forms import * # Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() if request.method=='POST': form=TaskForm(request.POST) if form.is_valid(): form.save() return redirect('/') context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) 启动发现： 输入数据点击提交 此时我们设置一下 list,html # 修改 html &lt;h3&gt;TO DO&lt;/h3&gt; &lt;form method=\"POST\" action=\"/\"&gt; #csrf_token #数据发送django自带保护机制 {{form}} &lt;input type=\"submit\" name=\"create Task\"&gt; &lt;/form&gt; {% for task in tasks %} {{task.title}} {% endfor %} 在页面上测试添加 成功，现在我们来编写 # 修改页面 先在模板下创建 update_task.html 页面 # 修改 html &lt;h3&gt;Update Task&lt;/h3&gt; &lt;form&gt; &lt;input type=\"submit\" name=\"Update Task\"&gt; &lt;/form&gt; # 修改 view 在 views 页面中进行修改： from django.shortcuts import render,redirect from django.http import HttpResponse from .models import * from .forms import * # Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() if request.method=='POST': form=TaskForm(request.POST) if form.is_valid(): form.save() return redirect('/') context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) def updateTask(request,pk): task=Task.objects.all(id=pk) return render(request,'tasks/update_task.html') &lt;br /&gt; # 修改 url 修改 app task 中的 urls from django.urls import pathfrom . import viewsapp_name = 'tasks'urlpatterns = [ path('', views.index, name='list'), path('update_task/&lt;str:pk&gt;',views.updateTask,name='update_task'),] 接着我们需要在修改页面写入响应的数据和输入框 from django.shortcuts import render,redirect from django.http import HttpResponse from .models import * from .forms import * # Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() if request.method=='POST': form=TaskForm(request.POST) if form.is_valid(): form.save() return redirect('/') context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) def updateTask(request,pk): task=Task.objects.get(id=pk) form=TaskForm(instance=task) context={'form':form} return render(request,'tasks/update_task.html',context=context) # 修改 html 修改模板 update_task 页面： &lt;h3&gt;Update Task&lt;/h3&gt;&lt;form&gt; &lt;input type=\"submit\" name=\"Update Task\"&gt;&lt;/form&gt;页面显示 &lt;br /&gt; 这里只是显示出来还不能修改 修改页面 &lt;h3&gt;Update Task&lt;/h3&gt; &lt;form method=\"post\" action=\"\"&gt; {{form}} &lt;input type=\"submit\" name=\"Update Task\"&gt; &lt;/form&gt; # 修改 view 文件： from django.shortcuts import render,redirect from django.http import HttpResponse from .models import * from .forms import * # Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() if request.method=='POST': form=TaskForm(request.POST) if form.is_valid(): form.save() return redirect('/') context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) def updateTask(request,pk): task=Task.objects.get(id=pk) form=TaskForm(instance=task) if request.method=='POST': form = TaskForm(request.POST, instance=task) if form.is_valid(): form.save() return redirect('/') context={'form':form} return render(request,'tasks/update_task.html',context=context) &lt;br /&gt; 修改功能实现 # 删除功能 开始删除功能 # 新建 html 创建删除模板 &lt;p&gt;Are you sure want to delete \"{{item}}\" ?&lt;/p&gt; &lt;a href=\"`{% url 'tasks:list'%}`\"&gt;Cancel&lt;/a&gt; # 修改 views from django.shortcuts import render,redirect from django.http import HttpResponse from .models import * from .forms import * #Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() if request.method=='POST': form=TaskForm(request.POST) if form.is_valid(): form.save() return redirect('/') context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) def updateTask(request,pk): task=Task.objects.get(id=pk) form=TaskForm(instance=task) if request.method=='POST': form = TaskForm(request.POST, instance=task) if form.is_valid(): form.save() return redirect('/') context={'form':form} return render(request,'tasks/update_task.html',context=context) def deleteTask(request,pk): return render(request,'tasks/delete.html') # 修改 url 文件 from django.urls import path from . import views app_name = 'tasks' urlpatterns = [ path('', views.index, name='list'), path('update_task/&lt;str:pk&gt;',views.updateTask,name='update_task'), path('delete/&lt;str:pk&gt;', views.deleteTask, name='delete_task'), ] # 再次修改 view 文件 from django.shortcuts import render,redirect from django.http import HttpResponse from .models import * from .forms import * Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() if request.method=='POST': form=TaskForm(request.POST) if form.is_valid(): form.save() return redirect('/') context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) def updateTask(request,pk): task=Task.objects.get(id=pk) form=TaskForm(instance=task) if request.method=='POST': form = TaskForm(request.POST, instance=task) if form.is_valid(): form.save() return redirect('/') context={'form':form} return render(request,'tasks/update_task.html',context=context) def deleteTask(request,pk): item=Task.objects.get(id=pk) context={'item':item} return render(request,'tasks/delete.html',context)&lt;br /&gt; # 查看页面 &lt;br /&gt; # 修改 html 删除页面 &lt;p&gt;Are you sure want to delete \"{{item}}\" ?&lt;/p&gt; &lt;a href=\"`{% url 'tasks:list' %}`\"&gt;Cancel&lt;/a&gt; &lt;form method=\"POST\" action=\"\"&gt; &lt;input type=\"submit\" name=\"Confirm\"&gt; &lt;/form&gt; &lt;br /&gt; 页面展示 # 修改 views 文件 from django.shortcuts import render,redirect from django.http import HttpResponse from .models import * from .forms import * # Create your views here. def index(request): tasks=Task.objects.all() form=TaskForm() if request.method=='POST': form=TaskForm(request.POST) if form.is_valid(): form.save() return redirect('/') context={'tasks':tasks,'form':form} return render(request,'tasks/list.html',context) def updateTask(request,pk): task=Task.objects.get(id=pk) form=TaskForm(instance=task) if request.method=='POST': form = TaskForm(request.POST, instance=task) if form.is_valid(): form.save() return redirect('/') context={'form':form} return render(request,'tasks/update_task.html',context=context) def deleteTask(request,pk): item=Task.objects.get(id=pk) if request.method=='POST': item.delete() return redirect('/') context={'item':item} return render(request,'tasks/delete.html',context=context) 页面展示可以成功删除： # 修改一下 list 的 html 页面： &lt;h3&gt;TO DO&lt;/h3&gt; &lt;form method=\"POST\" action=\"/\"&gt; {{form}} &lt;input type=\"submit\" name=\"create Task\"&gt; &lt;/form&gt; `{% for task in tasks %}` Update Delete {% if 'task.complete==True' %} {{task}} {% else %} {{task}} {% endif %} `{% endfor %}` # 完成的项目 &lt;br /&gt; &lt;br /&gt; 最终效果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"看创业新闻感悟","slug":"records/live-record/new-idea/看创业新闻感悟","date":"2021-09-08T09:37:41.000Z","updated":"2023-11-30T09:56:16.708Z","comments":true,"path":"records/live-record/new-idea/看创业新闻感悟/","link":"","permalink":"https://ppxpython.github.io/records/live-record/new-idea/%E7%9C%8B%E5%88%9B%E4%B8%9A%E6%96%B0%E9%97%BB%E6%84%9F%E6%82%9F/","excerpt":"","text":"# 5g 时代新生行业； 5g 时代的到来必然会替代一些重复性的体力工作，但同时也会诞生出新的产业和工作。所以我们不用太过忧心工作问题。 而且 5g 发展是一个阶段性的发展，而不是突然人们就进入 5g 时代，需要过度时期。 5g 创业是一个较大的长期投资，相较于短期收益，5g 是一个比较砸钱的投资，需要长期投入资金而且短期内很难看到收益。投资有风险创业需谨慎。 # ofo 小黄车摩拜单车的转型 在新闻中听说 ofo 单车欠缺资金链多年，但好像从未倒闭。甚至时至今日，还在去上班的路上发现。有小黄车，但相较于支付宝的用户小黄车的使用集群很少；听到 2018 年北京总部大楼已空空如也的小心我并不惊讶，让我仿佛想到了诺基亚的发展。想要独占市场，不想有第三方接入打兆品牌效应固然是没有问题，但支付宝的用户集群和快捷程度。作为一个用户打工人每天共享单车会选择哈罗单车 我认为导致 ofo 小黄车失败几点原因： 时机； 2014 在刚开始创业时，正值创业大潮，4 个喜欢骑行的年轻人创建了 ofo，提出了” 只连接车，不生产车 “的理念。抓住这个时机很重要；但之后又有两个时间节点，一个是 2017 年初 ofo 和摩拜已经大规模在中国投入单车市场，ofo 还完成了 d 轮融资。此时资本想要将这两个市场巨头进行合并但 ofo 拒绝了；不敢保障对于这个确定是错误还是正确的，但对于企业是一个选择性的转机；还有一个节点是 2018 年在摩拜单车已经选择离开市场，行业出现大的变动，热钱不再涌入，带助力的小蓝车杀入市场。但 ofo 仍然想自己发展走出世界。这个决定可以用一意孤行形容了。 创始人理想与投资人形成冲突； 2018 年有大量投资人进行谈判但创始人都认为还可以更好，长时间以往导致融资失败。 公关处理； 对于融资失败大量新闻出现，未及时处理公关事件，导致大量用户进行退款，这算是压死骆驼的最后一稻草。 用户意识； 刚兴起共享单车大潮时，大量用户的心理，出钱借用。出现大面积人为破坏的共享单车、将共享单车进行搬入家中以及后来共享单车出现在咸鱼市场上售卖等现象。这个时代环境所致人为不能变动。 # 脱发衍生出来的产业 之前脱发行业大多用户均是 40 来岁的中年男性，近几年随着生活压力和年轻人熬夜，脱发产品的用户集群已经驱于年轻化。现有统计第一大用户集群仍然是中年男性，但位居第二居然是 90 后的年轻人，数据有点吓人。据统计 2014 年在脱发产品市场占比仅仅只有 0.07%，2017 年的时候已经到达了 12% 左右。可见市场用户的火热程度，平均中国 6 个人中就有一个有脱发症状。2020-2025 将是火速发展的几年。 脱发产业将衍生出来的几个新方向： 脱发洗发水，洗发水中填入脱发字样的销量会比其他关键字的销量好很多； 生发产品的推出； 养发产品 假发产品 生发药物 - 医疗 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"心得记录","slug":"records","permalink":"https://ppxpython.github.io/categories/records/"},{"name":"生活记录","slug":"records/live-record","permalink":"https://ppxpython.github.io/categories/records/live-record/"},{"name":"新创意点","slug":"records/live-record/new-idea","permalink":"https://ppxpython.github.io/categories/records/live-record/new-idea/"}],"tags":[{"name":"创业","slug":"创业","permalink":"https://ppxpython.github.io/tags/%E5%88%9B%E4%B8%9A/"}]},{"title":"看阮一峰博客的感悟","slug":"records/live-record/live-feel/看阮一峰博客的感悟","date":"2021-08-20T10:55:46.000Z","updated":"2023-11-30T09:56:16.705Z","comments":true,"path":"records/live-record/live-feel/看阮一峰博客的感悟/","link":"","permalink":"https://ppxpython.github.io/records/live-record/live-feel/%E7%9C%8B%E9%98%AE%E4%B8%80%E5%B3%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%84%9F%E6%82%9F/","excerpt":"","text":"偶然间发现 在学习 shell 编程中发现阮一峰老师的教程，看了一下他的网络日志。感受到震撼，一个经济专业的人居然对计算机的了解程度如此之深。而且每每读完他的文章都收获颇多，他的文章不会像纯技术文章一样，但是参杂着自己的见解。之下是几点我的收获感悟： 坚持写博客； 阮一峰老师明确的说他写博客是为了自己，坚持写了 17 年上千片的文章。虽然有很多大牛动说要写博客，但真正做到并且坚持下去的人少之又少。虽然对于有些知识可能了解上有偏差导致网上人们对他褒贬不一。但他经过考证，有的坚持自己的见解有的虚心接收错误。但一直再坚持写作，曾在一遍文章中还写到一开始没想到会有那么多人看，坚持写作完全就是为了一方面让自己更有逻辑，文字表达更好一些另一方面为了学习的时候有产出有自己的思考。我也是所以之后很长一段时间我会坚持好好写博客的，没有必要强硬要求自己要每日一更但是学习后需要有产出。 原来成长都是探索的过程； 在如今教育大环境下，很多中国式教育出来的人才都会考试但对于深度思考很欠缺。我之前很长一段时间就是认为我是一个没有特别想法的人。总认为思维上的差异想要改变难于上青天，如今我已慢慢发现或是改变虽然没有精明思绪，但近几年我听到很多的是我觉得你是一个很有想法的人。未曾想到阮一峰先生这样的大牛人也曾说自己是一个没有想法的人，然后随着思考和阅读才慢慢建立起牛人思想。所以呀，我也在往这方面发展，因为始终相信思维决定一个人。 技术文章可以 “不那么技术”； 现在很多大佬的文章都很技术性，一句话让人思考半天。但阮一峰的文章采用了很多经济学思维。随心编写的文章也不错，没必要必须按照专业术语有时候增加自己的而一些看法，可以让自己思维更发散一些。 多看书； 这三个字应该是伴随着你的前半生，但做到的人并不多。看到阮一峰看过的书籍相当于一个小图书馆了。特别是国外的一些文献，我们不得不承认的是很多计算机技术国外发展更快速一些，之前一直觉得英语不好不喜欢阅读英文文献，但现在其实有很多中文翻译。应该好好利用网络资源阅读。这里的多看书不止是技术相关的书籍还有很多其他书籍。纵向发展是技术深度但纵观全局你会发现大佬不仅仅是纵向有深度，横向也有广度。除了技术很多方面金融，经济很多领域都有了解。 多多写出自己的想法； 这样也是锻炼自己想法的一个过程，一方面可以增强写作，一方面可以锻炼逻辑，还可以树立自己的想法。何乐而不为。 多看论文，期刊； 无论是国内还是国外，通过阮一峰老师打开了新大陆一样，看到了很多大佬的博客笔记。自己在有一些新想法的时候也会收集相关的论文进行学习。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"心得记录","slug":"records","permalink":"https://ppxpython.github.io/categories/records/"},{"name":"生活记录","slug":"records/live-record","permalink":"https://ppxpython.github.io/categories/records/live-record/"},{"name":"生活感悟","slug":"records/live-record/live-feel","permalink":"https://ppxpython.github.io/categories/records/live-record/live-feel/"}],"tags":[]},{"title":"win10笔记本插上耳机没声音设置","slug":"computer/win/win10/win10笔记本插上耳机没声音设置","date":"2021-07-03T04:32:10.000Z","updated":"2023-11-30T09:56:16.693Z","comments":true,"path":"computer/win/win10/win10笔记本插上耳机没声音设置/","link":"","permalink":"https://ppxpython.github.io/computer/win/win10/win10%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8F%92%E4%B8%8A%E8%80%B3%E6%9C%BA%E6%B2%A1%E5%A3%B0%E9%9F%B3%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"win10 笔记本插上耳机没有声音 前言 一、禁用插孔设置 二、检查驱动 三、重置扬声器 (文章目录) # 前言 # 一、禁用插孔设置 1 点击电脑左下方的 “开始” 图标，找到 “控制面板” 选项进入。 2 然后在控制面板的页面中找到 “硬件与声音”，点击进入。 3 然后找到下方的 “Realtek 高清晰音频管理器”，点击进入。 4 进入 Realtek 高清晰音频管理器界面后，点击禁用插孔设置的图标，如下图所示。 5 勾选 “禁用前面板插孔检测”，点击确定。 # 二、检查驱动 1 找到电脑桌面上的” 计算机 “，单击鼠标右键，选择” 属性 “。 2 然后在属性的页面中，选择 “设备管理器”，点击进入。 3 检查音频驱动，点击下图中选中的部分，查看相应的驱动是否有感叹号之类的符号，如果有，重装驱动，然后重启。 # 三、重置扬声器 1 打开控制面板，找到 “硬件与声音”，点击进入。 2 在硬件与声音的页面中，选择声音中的 “更改系统声音”。 3 然后选择 “声音”，重新选择 “声音方案” 为 “windows 默认”，点击确定，然后重启电脑即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"电脑配置","slug":"computer/win","permalink":"https://ppxpython.github.io/categories/computer/win/"},{"name":"win10","slug":"computer/win/win10","permalink":"https://ppxpython.github.io/categories/computer/win/win10/"}],"tags":[]},{"title":"win10专业版激活","slug":"computer/win/win10/win10专业版激活","date":"2021-07-03T03:59:02.000Z","updated":"2023-11-30T09:56:16.692Z","comments":true,"path":"computer/win/win10/win10专业版激活/","link":"","permalink":"https://ppxpython.github.io/computer/win/win10/win10%E4%B8%93%E4%B8%9A%E7%89%88%E6%BF%80%E6%B4%BB/","excerpt":"","text":"前言 一、激活win10专业版 1.激活方法 win10专业版用户请依次输入： win10企业版用户请依次输入： win10家庭版用户依次输入： 专业版采用步骤： (文章目录) # 前言 相关 win10 的一些常用操作 # 一、激活 win10 专业版 # 1. 激活方法 系统安装完毕后，首先以管理员身份打开 CMD 命令行窗口，按下 Win+X，选择命令提示符 (管理员)。 说明：kms.xspace.in 是 kms 服务器地址，可能会失效，如果激活失败，可以自行搜索 kms 服务器地址，将 kms.xspace.in 替换成新的地址即可，比如换成 kms.03k.org，参考可用的 kms 激活服务器有哪些 # win10 专业版用户请依次输入： 1 打开 cmd slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GXslmgr /skms kms.03k.orgslmgr /ato# win10 企业版用户请依次输入： slmgr /ipk NPPR9-FWDCX-D2C8J-H872K-2YT43slmgr /skms kms.03k.orgslmgr /ato# win10 家庭版用户依次输入： slmgr /ipk TX9XD-98N7V-6WMQ6-BX7FG-H8Q99slmgr /skms kms.03k.orgslmgr /ato# 专业版采用步骤： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"电脑配置","slug":"computer/win","permalink":"https://ppxpython.github.io/categories/computer/win/"},{"name":"win10","slug":"computer/win/win10","permalink":"https://ppxpython.github.io/categories/computer/win/win10/"}],"tags":[]},{"title":"01钉钉小程序","slug":"computer-science/DDapp/ddapp-study1/01钉钉小程序","date":"2021-05-13T08:39:51.000Z","updated":"2023-11-30T09:56:16.639Z","comments":true,"path":"computer-science/DDapp/ddapp-study1/01钉钉小程序/","link":"","permalink":"https://ppxpython.github.io/computer-science/DDapp/ddapp-study1/01%E9%92%89%E9%92%89%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"# 钉钉小程序学习记录 学习记录 钉钉小程序学习记录 前言 一、钉钉小程序 二、使用步骤 1.搭建应用环境 (文章目录) &lt;/font&gt; &lt;hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\"&gt; # 前言 小程序开发优点 &lt;hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\"&gt; 1 轻量 便捷 2 开发成本低 3 用户集群大 4 封装好的小程序语言，语法简单 由于开发时，发现钉钉小程序教程较少，因此在开发过程中作为纪录。适用于小白。 # 一、钉钉小程序 采用钉钉小程序的原因： 1 钉钉作为一中国企业管理而生的企业应用，用户集群大 2 钉钉拥有完整的企业组织架构，无需其他应用人员导入 3 钉钉提供丰富的 API 接口供开发者使用 4 拥有监控平台更好管控 API 和数据的调用，实现实时监控，及时发现问题 # 二、使用步骤 # 1. 搭建应用环境 本次将钉钉小程序作为前端 下载工具： 1 java 2 小程序开发者工具为开发工具小程序开发者工具下载地址 此外钉钉开发者，提供接口调试工具，方便开发者调用 API 调参。 钉钉小程序在线调参工具地址 登陆钉钉后台钉钉后台 创建一个钉钉组织或者成为钉钉组织管理员 2. 在弹出的创建应用页面中填写基本信息，然后单击确定创建。 应用类型：选择小程序。 开发方式：选择企业自助开发。 应用创建完成后，在基础信息页面，复制应用的 AppKey 和 AppSecret 备用。 5. 单击开发管理进入开发管理页面，然后单击修改，并根据以下内容配置开发信息。 服务器出口 IP：输入调用钉钉服务端 API 时使用的 IP 即企业服务器的公网 IP，多个 IP 请以英文逗号 \",\" 隔开，支持带一个 * 号通配符的 IP 格式。 本教程设置为本机的公网 IP：30.40.xx.xx。 PC 端首页地址（可选）：输入在 PC 端钉钉工作台上打开本应用的地址。链接地址必须以 http 或 https 开头。 本教程设置为：https://ding-doc.dingtalk.com/。 管理后台地址（可选）：输入组织管理员在钉钉管理后台访问该应用的地址。 6 单击人员管理，然后单击添加人员添加开发人员。 单击安全中心，然后单击添加添加一个 HTTP 安全域名。 当小程序的前端与服务端需要进行网络通信时，需要设置安全域名。小程序前端只能通过已设置的安全域名（或 IP）与服务端进行网络通信。当安全域名更新时，需要在小程序开发工具重新打包上传版本，设置的域名才会生效。 安全域名是后端服务部署的服务器的公网 IP 或域名，本教程输入 127.0.0.1。 单击权限管理进入权限管理页面，然后根据以下配置添加接口调用权限。 权限范围选择全部员工，然后选择通讯录管理。 选择通讯录部门信息读权限和通讯录部门成员读权限，然后单击申请权限。 之后可以在小程序开发者工具中创建一个简单的 demo 创建好后的目录 模拟器效果： 1 app.js 全文逻辑 用来设置全局变量，以及页面配置 配置路由，创建一个新的页面必须，在这配置相对路径 页面导航栏的设置 存放照片 页面，主要在这编写代码 每个页面由这几个组成 公共资源存放 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"钉钉小程序","slug":"computer-science/DDapp","permalink":"https://ppxpython.github.io/categories/computer-science/DDapp/"},{"name":"钉钉小程序学习","slug":"computer-science/DDapp/ddapp-study1","permalink":"https://ppxpython.github.io/categories/computer-science/DDapp/ddapp-study1/"}],"tags":[{"name":"钉钉小程序","slug":"钉钉小程序","permalink":"https://ppxpython.github.io/tags/%E9%92%89%E9%92%89%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"用hexo搭建一个自己的博客","slug":"records/live-record/live-blog/用hexo搭建一个自己的博客","date":"2020-10-22T08:51:04.000Z","updated":"2023-11-30T09:56:16.704Z","comments":true,"path":"records/live-record/live-blog/用hexo搭建一个自己的博客/","link":"","permalink":"https://ppxpython.github.io/records/live-record/live-blog/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"# 系列文章目录 系列文章目录 前言 一、Hexo是什么？ 二、安装Hexo 1.安装node.JS 1.下载安装包 2、安装 3、配置npm在安装全局模块时的路径和缓存cache的路径 4.测试 5.安装已完成 2.npm配置 三、开始搭建Hexo 1.创建本地hexo博客 2.github中博客 3.gitee中博客 3.更改主题 总结 (文章目录) # 前言 分享搭建 hexo 个人博客的过程 参考文档链接在 总结模块中 # 一、Hexo 是什么？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的 markdown 文件，按照指定的主题解析成静态网页。 # 二、安装 Hexo 安装 Hexo 钱需要一些环境依赖，接下来我们就来一步一步安装 # 1. 安装 node.JS # 1. 下载安装包 Node.js 官方网站下载：https://nodejs.org/en/node.js 官网 选择操作系统对应的包： 下载完成，安装包如下： # 2、安装 打开安装，傻瓜式下一步即可： 选择安装位置，我这里装在 D 盘下： 安装成功，文件夹结构如下，并在上面安装过程中已自动配置了环境变量和安装好了 npm 包，此时可以执行 node -v 和 npm -v 分别查看 node 和 npm 的版本号： # 3、配置 npm 在安装全局模块时的路径和缓存 cache 的路径 因为在执行例如 npm install webpack -g 等命令全局安装的时候，默认会将模块安装在 C:\\Users\\ 用户名 \\AppData\\Roaming 路径下的 npm 和 npm_cache 中，不方便管理且占用 C 盘空间，如下图所示： 所以这里配置自定义的全局模块安装目录，在 node.js 安装目录下新建两个文件夹 node_global 和 node_cache，然后在 cmd 命令下执行如下两个命令： npm config set prefix \"D:\\Program Files\\nodejs\\node_global\" npm config set cache \"D:\\Program Files\\nodejs\\node_cache\" 执行成功。然后在环境变量 -&gt; 系统变量中新建一个变量名为 “NODE_PATH” ， 值为 “D:\\Program Files\\nodejs\\node_modules” ，如下图： 最后编辑用户变量里的 Path，将相应 npm 的路径改为： D:\\Program Files\\nodejs\\node_global ，如下： 更改前： 更改后： 配置完成。 # 4. 测试 安装完成后可以使用 cmd（win+r 然后输入 cmd 进入）测试下是否安装成功。 方法：在 cmd 下输入 node -v ，出现下图版本提示就是完成了 NodeJS 的安装。 # 5. 安装已完成 常规 NodeJS 的搭建到现在为止已经完成了。 # 2.npm 配置 6、npm 配置 npm 作为一个 NodeJS 的模块管理，很有必要列出一些： ①、模块路径、cache 路径 先配置 npm 的全局模块的存放路径以及 cache 的路径， 例如希望将以上两个文件夹放在 NodeJS 的主目录下，便在 NodeJs 下建立 \"node_global\" 及 \"node_cache\" 两个文件夹。如下图 ②、使用 cmd 命令进行配置 启动 cmd，输入 npm config set prefix \"H:\\nodejs\\node_global\"npm config set cache \"H:\\nodejs\\node_cache\"如果不进行这一步设置，npm 的全局安装包，将不会在 node 安装文件夹里。 如果这个步骤出现错误，如：operation not permitted, mkdir 'C:\\Program Files\\nodejs'，请使用管理员身份打开 cmd 命令行。 ③、测试 现在我们来装个模块试试， 在 cmd 命令行里面，输入 “ npm install express -g ”（“-g” 这个参数意思是装到 global 目录下，也就是上面说设置的 “H:\\nodejs\\node_global” 里面。）。 ④、查看环境变量 ⑤、配置 node_path 进入环境变量对话框，在系统变量下新建 \"NODE_PATH\"，输入” H:\\nodejs\\node_global\\node_modules“ 。（ps：这一步相当关键。） 2014.4.19 新增：由于改变了 module 的默认地址，所以上面的用户变量都要跟着改变一下（用户变量 \"PATH\" 修改为 “H:\\nodejs\\node_global\\”），要不使用 module 的时候会导致输入命令出现 “xxx 不是内部或外部命令，也不是可运行的程序或批处理文件” 这个错误。 8、安装淘宝 npm（cnpm） (1) 输入以下命令 npm install -g cnpm --registry = https：//registry.npm.taobao.org(2) 添加系统变量 path 的内容 因为 cnpm 会被安装到 H:nodejs\\node_global 下，而系统变量 path 并未包含该路径。在系统变量 path 下添加该路径即可正常使用 cnpm。 (3) 输入 cnpm -v 命令，查看结果 测试 cnpm cnpm -v # 三、开始搭建 Hexo # 1. 创建本地 hexo 博客 cnpm install -g hexo-cli全局安装框架 验证 hexo -v 安装完成、 创建项目目录空文件夹 testblog 初始化 hexo hexo init需要等待一段时间 初始化成功 dir查看生成的文件 启动 hexo hexo s 启动成功 先断开 创建我的第一篇博客文章： hexo n \"我的第一篇博客文章\" 查看文章 cd source/_posts/dir 编写博客内容 回退目录 cd..cd.. 清理博客 hexo clean 生成博客 hexo g 重新启动 hexo s 新文章生成： # 2.github 中博客 github 创建一个仓库 用户名.github.io 一定要是这样的格式否则会报错 config.yml 中修改 deploy: type: 'git' repo: https://github.com/ppxpython/ppxpython.github.io.git branch: master hexo clean hexo g hexo d 刷新查看仓库 打开网址： https://ppxpython.github.io/ # 3.gitee 中博客 在 gitee 上创建一个仓库 安装工具 cnpm install --save hexo-deployer-git dir查看 需要设置 config.yml 文件 打开文件到最下面更改 # Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: 'git' repo: https://gitee.com/ppxpython/testblog.git bronch: master 没有引号都没关系 部署远端 hexo d 成功 刷新 gitee 显示代码： 点击： 显示： 启动成功： 网页： 发现没有样式，不要着急，更改配置文件： url: https://ppxpython.gitee.io/testblog hexo clean hexo d 在 gitee 上查看更新 # 3. 更改主题 下载主题： 选择自己喜欢的主题 git clone https://github.com/ShanaMaid/hexo-theme-shana.git themes/ShanaMaid 修改配置文件 hexo clean本地查看 hexo s 效果： http://localhost:4000/easyblog/ hexo d部署上去 在 gitee 上更新一下 部署成功，点击网址，查看我的博客 最后附上 我的博客： https://ppxpython.github.io/ # 总结 参照的链接这里附上： Node.js 安装链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"心得记录","slug":"records","permalink":"https://ppxpython.github.io/categories/records/"},{"name":"生活记录","slug":"records/live-record","permalink":"https://ppxpython.github.io/categories/records/live-record/"},{"name":"个人博客","slug":"records/live-record/live-blog","permalink":"https://ppxpython.github.io/categories/records/live-record/live-blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://ppxpython.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"01postman学习","slug":"software-test/test-tools/api-testing2/postman/01postman学习","date":"2020-10-20T01:00:40.000Z","updated":"2023-11-30T09:56:16.710Z","comments":true,"path":"software-test/test-tools/api-testing2/postman/01postman学习/","link":"","permalink":"https://ppxpython.github.io/software-test/test-tools/api-testing2/postman/01postman%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"# 系列文章目录 系列文章目录 前言 一、postman是什么？ 二、 接口是什么？ 三、 接口测试和接口测试的目的 1.什么是接口测试 2.为什么要进行接口测试 3.接口测试重点 4.接口测试分类 四、postman进行接口测试 1.HTTP知识 2.增加断言 3.编写一个测试实例 4.sandbox 5.请求方法 6.cookie 7.鉴权 （1）什么是鉴权 （2）鉴权方式 8.cllection容器 集合概述 Collection 常用API 9. 变量 10. 环境变量方法1实例 11.全局变量方法二实例 12.运行collection 13.运行collection实例生成HTML测试报告 14.postman导出python脚本 5、postman中断言和抓包 1.测试断言 2.postman中充当代理进行app抓包 总结 (文章目录) # 前言 本文为视频学习的截图记录， 用途：以方便以后学习翻阅 主要以图片的形式展现 这里附上视频链接：postman 学习 # 一、postman 是什么？ postman 是一个 HTTP 客户端，用于发送请求和接收响应，是专门用于测试 API 的工具 # 二、 接口是什么？ IT 行业从 WWW 万维网时代 的 C/S、B/S 架构，到移动互联网时代的大前端时代，发展到云计算时代以 IaaS（基础架构即服务），PaaS（平台即服务），SaaS（软件即服务）为代表的云端架构，如今更是进入到万物互联的物联网时代，网络连接着我们生活的方方面面，而承载这些连接的连接点，就是网络接口，接口是不同网络应用之间联系、交互、相互作用的入口和桥梁。 如下图，是接口在软件系统中所处位置的示意图： # 三、 接口测试和接口测试的目的 # 1. 什么是接口测试 百度百科中： 接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。 接口测试是测试系统组件间接口的一种测试， 主要用于测试系统与外部其他系统之间的接口， 以及系统内部各个子模块之间的接口。 # 2. 为什么要进行接口测试 现在很多系统前后端架构是分离的，因为不同端（前段，后端）的工作进度不一样，所以我们要针对最开始出来的接口，以及需要调用其他公司的（银行，支付宝，微信，qq 等）一些接口进行接口测试及验证数据，从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前端太容易了）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。在这种情况下就需要从接口层面进行验证。前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。 如今系统越来越复杂，传统的靠前端测试已经大大降低了效率，而且现在我们都推崇测试前移也叫 测试左移，希望测试能更早的介入测试，那接口测试就是一种及早介入的方式。例如传统测试，你是不是得等前后端都完成你才能进行测试，才能进行自动化代码编写。 而如果是接口测试，只需要前后端定义好接口，那这时自动化就可以介入编写接口 自动化测试代码，手工测试只需要后端代码完成就可以介入测试后端逻辑而不用等待前端工作完成。 简单概括： ①. 越底层发现 bug，它的修复成本是越低的。 ②. 前端随便变，接口测好了，后端不用变，前后端是两拨人开发的。 ③. 检查系统的安全性、稳定性，前端传参不可信，比如京东购物，前端价格不可能传入 - 1 元，但是通过接口可以传入 - 1 元。 ④. 如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，接口测试可以提供这种情况下的解决方案。 ⑤. 接口测试相对容易实现自动化持续集成，且相对 UI 自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。 ⑥. 现在很多系统前后端架构是分离的，从安全层面来说： (1)、只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。 (2)、前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。 # 3. 接口测试重点 测试的重点是 检查接口参数传递的正确性 检查 接口功能实现的正确性 检查输出结果的正确性 检查各种异常情况的容错处理的完整性和合理性 保证系统的正确和稳定为核心，重要性主要体现为以下几个方面： （1）能够提早发现 bug，符合质量控制前移的理念。 （2）接口测试低成本高效益，因为接口测试可以自动化并且是持续集成的。 （3）接口测试从用户的角度对系统接口进行全面检测。实际项目中，接口测试会覆盖一定程度的业务逻辑 # 4. 接口测试分类 针对软件接口的分类一般有如下几种情况： 系统与系统之间的调用 如微信向用户提供统一的对外接口，程序员调用接口完成基于微信的小程序等； 同一系统内部上层服务对下层服务的调用 如一个软件程序一般分为表示层，业务层和数据层，表示层调用业务层的接口来完成自己的工作，而业务层又会调用数据层的接口来实现相应的业务等。 # 四、postman 进行接口测试 # 1.HTTP 知识 HTTP 是超文本传输协议，其定义了客户端与服务器端之间文本传输的规范。HTTP 默认使用 80 端口，这个端口指的是服务端的端口，而客户端使用的端口是动态分配的。当我们没有指定端口访问时，浏览器会默认帮我们添加 80 端口。 需要注意的是，现在大多数访问都使用了 HTTPS 协议，而 HTTPS 的默认端口为 443，如果使用 80 端口访问 HTTPS 协议的服务器可能会被拒绝。 HTTP 请求 / 响应的步骤： 客户端连接到 Web 服务器 -&gt; 发送 Http 请求 -&gt; 服务器接受请求并返回 HTTP 响应 -&gt; 释放连接 TCP 连接 -&gt; 客户端浏览器解析 HTML 内容 1、客户端连接到 Web 服务器 一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP 套接字连接。例如，http://www.baidu.com 2、发送 HTTP 请求 通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。 3、服务器接受请求并返回 HTTP 响应 Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。 4、释放连接 TCP 连接 若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP 连接；若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求； 5、客户端浏览器解析 HTML 内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。 GET 和 POST 请求： 如果是 get 请求的话，直接在浏览器里输入就行了，只要在浏览器里面直接能请求到的，都是 get 请求，如果是 post 的请求的话，就不行了，就得借助工具来发送。 GET 请求和 POST 请求的区别： 1、GET 使用 URL 或 Cookie 传参。而 POST 将数据放在 BODY 中。 2、GET 的 URL 会有长度上的限制，则 POST 的数据则可以非常大。 3、POST 比 GET 安全，因为数据在地址栏上不可见。 4、一般 get 请求用来获取数据，Post 请求用来发送数据。 2)、http 状态码 每发出一个 http 请求之后，都会有一个响应，http 本身会有一个状态码，来标示这个请求是否成功，常见的状态码有以下几种： 1、200 2 开头的都表示这个请求发送成功，最常见的就是 200，就代表这个请求是 ok 的，服务器也返回了。 2、300 3 开头的代表重定向，最常见的是 302，把这个请求重定向到别的地方了， 3、400 400 代表客户端发送的请求有语法错误，401 代表访问的页面没有授权，403 表示没有权限访问这个页面，404 代表没有这个页面 4、500 5 开头的代表服务器有异常，500 代表服务器内部异常，504 代表服务器端超时，没返回结果 常见的几种状态码： 200： OK 当您的操作将在响应正文中返回数据时，出现此结果。 201： 资源成功创建和更新 204： No Content 当您的操作成功，但不在响应正文中返回数据时，出现此结果。 301： 表示要从这个接口重定向到另外的接口（出现较多） 304： Not Modified（重定向） 当测试实体自上次检索以来是否被修改时，出现此结果。 400： 本来 api 必须要的参数但没有提供时，会出现 401： 需要登录才能访问的接口，未登录时会报 401 404： Not Found（客户端错误） 当资源不存在时，出现此结果。 405： Method Not Allowed（客户端错误）由于方法和资源组合不正确而出现此错误。 例如，您不能对一个实体集合使用 DELETE 或 PATCH。 412： Precondition Failed 客户端错误 413： Payload Too Large（客户端错误） 当请求长度过长时，出现此结果。 501： Not Implemented（服务器错误） 当未实施某个请求的操作时，出现此结果。 503： Service Unavailable（服务器错误） 当 Web API 服务不可用时，出现此结果。 # 2. 增加断言 一般断言时在 http 响应体中断言处理 # 3. 编写一个测试实例 测试目标 url： 测试目标 url 1. 输入网址： 2. 增加判断状态码和数据是否是 10 条的断言 代码： pm.test(\"状态码为200\", function () { pm.response.to.have.status(200);});pm.test(\"返回的数据为10\", function () { var jsonData = pm.response.json(); jsonData.length === 10 }); 返回的结果： # 4.sandbox postman 学习文档：https://learning.postman.com/docs/getting-started/introduction/ # 5. 请求方法 HTTP/1.1 协议中共定义了八种方法（有时也叫 “动作”），来表明 Request-URL 指定的资源不同的操作方式 HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。 HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法 1、OPTIONS 返回服务器针对特定资源所支持的 HTTP 请求方法，也可以利用向 web 服务器发送‘*’的请求来测试服务器的功能性 2、HEAD 向服务器索与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。 3、GET 向特定的资源发出请求。注意：GET 方法不应当被用于产生 “副作用” 的操作中，例如在 Web Application 中，其中一个原因是 GET 可能会被网络蜘蛛等随意访问。Loadrunner 中对应 get 请求函数：web_link 和 web_url 4、POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和 / 或已有资源的修改。 Loadrunner 中对应 POST 请求函数：web_submit_data,web_submit_form 5、PUT 向指定资源位置上传其最新内容 6、DELETE 请求服务器删除 Request-URL 所标识的资源 7、TRACE 回显服务器收到的请求，主要用于测试或诊断 8、CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 注意： 1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码 405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码 501（Not Implemented）。 2）HTTP 服务器至少应该实现 GET 和 HEAD/POST 方法，其他方法都是可选的，此外除上述方法，特定的 HTTP 服务器支持扩展自定义的方法。 # 6.cookie Cookie 的诞生 由于 HTTP 协议是无状态的，而服务器端的业务必须是要有状态的。Cookie 诞生的最初目的是为了存储 web 中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。目前最新的规范是 RFC 6265，它是一个由浏览器服务器共同协作实现的规范。 Cookie 的处理分为： 服务器像客户端发送 cookie 浏览器将 cookie 保存 之后每次 http 请求浏览器都会将 cookie 发送给服务器端 服务器端的发送与解析 发送 cookie 服务器端像客户端发送 Cookie 是通过 HTTP 响应报文实现的，在 Set-Cookie 中设置需要像客户端发送的 cookie，cookie 格式如下： Set-Cookie: \"name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure\" 其中 name=value 是必选项，其它都是可选项。Cookie 的主要构成如下： name: 一个唯一确定的 cookie 名称。通常来讲 cookie 的名称是不区分大小写的。 value: 存储在 cookie 中的字符串值。最好为 cookie 的 name 和 value 进行 url 编码 domain: cookie 对于哪个域是有效的。所有向该域发送的请求中都会包含这个 cookie 信息。这个值可以包含子域 (如： yq.aliyun.com)，也可以不包含它 (如：.aliyun.com，则对于 aliyun.com 的所有子域都有效). path: 表示这个 cookie 影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送 cookie。 expires: 失效时间，表示 cookie 何时应该被删除的时间戳 (也就是，何时应该停止向服务器发送这个 cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有 cookie；不过也可以自己设置删除时间。这个值是 GMT 时间格式，如果客户端和服务器端时间不一致，使用 expires 就会存在偏差。 max-age: 与 expires 作用相同，用来告诉浏览器此 cookie 多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age 的优先级高于 expires。 HttpOnly: 告知浏览器不允许通过脚本 document.cookie 去更改这个值，同样这个值在 document.cookie 中也不可见。但在 http 请求张仍然会携带这个 cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。 secure: 安全标志，指定后，只有在使用 SSL 链接时候才能发送到服务器，如果是 http 链接则不会传递该信息。就算设置了 secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放 cookie 就对了服务器端设置。 # 7. 鉴权 # （1）什么是鉴权 鉴权（authentication）是指验证用户是否拥有访问系统的权利。传统的鉴权是通过密码来验证的。这种方式的前提是，每个获得密码的用户都已经被授权。在建立用户时，就为此用户分配一个密码，用户的密码可以由管理员指定，也可以由用户自行申请。这种方式的弱点十分明显：一旦密码被偷或用户遗失密码，情况就会十分麻烦，需要管理员对用户密码进行重新修改，而修改密码之前还要人工验证用户的合法身份。 为了克服这种鉴权方式的缺点，需要一个更加可靠的鉴权方式。目前的主流鉴权方式是利用认证授权来验证数字签名的正确与否。 逻辑上，授权发生在鉴权之后，而实际上，这两者常常是一个过程。 # （2）鉴权方式 我们常用的鉴权有四种： 1、HTTP Basic Authentication 2、session-cookie 3、Token 验证 4、OAuth (开放授权) 一般涉及到的都是 Token 有一些 api 在访问之前必须进行登录 一般测试人员在测试的时候只需要： 1. 获取 token（抓包，直接查看） 2. 设置 headers # 8.cllection 容器 # 集合概述 集合：集合是 java 中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有什么区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储任意类型数据。集合存储的都是引用数据类型。如果想存储基本类型数据需要存储对应的包装类型。 集合常用类的继承体系 Collection： 单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 java.util.List 和 java.util.Set。其中，List 的特点是元素有序、元素可重复。Set 的特点是元素不可重复。List 接口的主要实现类有 java.util.ArrayList 和 java.util.LinkedList，Set 接口的主要实现类有 java.util.HashSet 和 java.util.LinkedHashSet。 一张图来描述集合常用类的继承体系 集合本身是一个工具，它存放在 java.util 包中。在 Collection 接口定义着单列集合框架中最最共性的内容。 # Collection 常用 API Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合 (List 和 Set) 通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear(): 清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中 # 9. 变量 # 10. 环境变量方法 1 实例 实列： 接口文档： 接口文档 测试 url 打开 postman name=python，将 name 设置为全局变量时爆红，先要设置环境变量 点击 添加环境变量 变量改变颜色，编程橘黄色，send 后的结果 # 11. 全局变量方法二实例 环境变量是与 环境相关的 全局变量是独立于环境的 1. 先取消环境变量 点击 出现： 开始编辑 完成 注意：当环境变量和全局变量中对同一个个变量名进行不同的赋值时，环境变量的值可以覆盖到全局变量的值 # 12. 运行 collection # 13. 运行 collection 实例生成 HTML 测试报告 创建 collection 再创建一个 request 请求 点击运行 按钮在命令行中运行 跳转到网页： https://www.npmjs.com/package/newman 安装 newman npm install -g newman 在命令行中下载 newman 检验 newman 是否安装成功 重新回到 postman 导出到本地文件： 是一打开 cmder 或者 cmd 跳转到导出的目录下： 运行 # 14.postman 导出 python 脚本 首先安装 Python（这里已经安装） 查看 python 版本 pip 下载 requests 库（之前已经下载过）： 在 postman 中点击 Code 选择： 点击右上角复制： 创建一个 py 文件在 pycharm 中打开 import requestsimport unittestclass v2exAPITestCase(unittest.TestCase): def test_node_api(self): url = \"https://www.v2ex.com/api/nodes/show.json?name=python\" payload = {} querystring ={\"name\" :\"python\"} headers = { 'Cookie': '__cfduid=d333f7a16684a741d353302599a54b2921603071821' } response = requests.request(\"GET\", url, headers=headers, data=payload).json() self.assertEqual(response['name'], querystring['name']) # print(response.text.encode('utf8'))if __name__ == '__main__': unittest.main()运行成功 重新修改加入数据驱动 修改后的测试代码为： import requestsimport unittestclass v2exAPITestCase(unittest.TestCase): def test_node_api(self): url = \"https://www.v2ex.com/api/nodes/show.json?name=python\" payload = {} headers = { 'Cookie': '__cfduid=d333f7a16684a741d353302599a54b2921603071821' } # querystring ={\"name\" :\"python\"} for node_name in ['php','python','qna']: response = requests.request(\"GET\", url, headers=headers, params={'name': node_name}).json() self.assertEqual(response['name'], node_name)if __name__ == '__main__': unittest.main()运行成功 # 5、postman 中断言和抓包 # 1. 测试断言 断言：实际结果和期望结果的比对的过程 比对数据：状态码，返回数据，响应头，响应时间 在 test 中编写 js 进行断言 tm.response 是指相应对象 首先创建一个管理文件夹（集合） 存放一个项目中的所有接口测试便于管理 在 test 中编写断言 结果是绿色的表示通过 结果是红色的表示不通过 需要保存 js 代码是 Ctrl+S 键 输入请求名 选择存放接口的管理文件 # 2.postman 中充当代理进行 app 抓包 电脑 ——》postman——》手机 如何在 postman 中设置代理 postman 中 点击代理显示代理设置： 填写端口号 选择抓取到的包存放在哪个管理文件夹中 之后在手机上设置 端口号一定一致 服务器是电脑的 IP 设置之后在手机端操作会在 postman 中增加 requests 点击雷达代理的图案关闭代理 抓包是为了查看数据 # 总结 参考链接附上 postman 为什么要进行接口测试 postman 基础 http 请求方式 cookie collection 集合 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"软件测试","slug":"software-test","permalink":"https://ppxpython.github.io/categories/software-test/"},{"name":"软件测试工具学习","slug":"software-test/test-tools","permalink":"https://ppxpython.github.io/categories/software-test/test-tools/"},{"name":"接口测试工具","slug":"software-test/test-tools/api-testing2","permalink":"https://ppxpython.github.io/categories/software-test/test-tools/api-testing2/"},{"name":"Postman","slug":"software-test/test-tools/api-testing2/postman","permalink":"https://ppxpython.github.io/categories/software-test/test-tools/api-testing2/postman/"}],"tags":[{"name":"Postman","slug":"Postman","permalink":"https://ppxpython.github.io/tags/Postman/"}]},{"title":"08Springboot-- 依赖错误NoClassDefFoundError","slug":"computer-science/java/springboot/springboot-error1/08Springboot-依赖错误NoClassDefFoundError","date":"2020-10-05T09:17:21.000Z","updated":"2023-11-30T09:56:16.644Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/08Springboot-依赖错误NoClassDefFoundError/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/08Springboot-%E4%BE%9D%E8%B5%96%E9%94%99%E8%AF%AFNoClassDefFoundError/","excerpt":"","text":"# 项目场景： 前后端启动成功没有错误，但在登录是出现错误 # 问题描述： 前后端启动成功没有错误，但在登录是出现 后端呢 SpringBoot 报出错误 ERROR c.e.c.f.w.e.GlobalExceptionHandler - [handleException,83] - Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter# 原因分析： JDK 版本号是： 今天在使用 JDK 13.0 环境下使用 IDEA 时候出现了这个错误，错误日志如下： 我是采用了增加依赖解决的 故障原因： JAXB API 是 java EE 的 API，因此在 java SE 9.0 中不再包含这个 Jar 包。 java 9 中引入了模块的概念，默认情况下，Java SE 中将不再包含 java EE 的 Jar 包 而在 java 6/7 / 8 时关于这个 API 都是捆绑在一起的 # 解决方案： # 解决方案一： 降低 JDK 版本到 JDK 8 # 解决方案二:（亲测可行） 手动加入这些依赖 Jar 包 &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"07Springboot--  导包运行报错IllegalStateException","slug":"computer-science/java/springboot/springboot-error1/07Springboot-导包运行报错IllegalStateException","date":"2020-10-05T09:12:30.000Z","updated":"2023-11-30T09:56:16.644Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/07Springboot-导包运行报错IllegalStateException/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/07Springboot-%E5%AF%BC%E5%8C%85%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99IllegalStateException/","excerpt":"","text":"# 项目场景： 运行 IDEA 时出现错误 # 问题描述： java.lang.IllegalStateException: Error processing condition on org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration.propertySourcesPlaceholderConfigurer # 原因分析： 依赖 # 解决方案： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;!-- &lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt;在 pom.xml 文件中将 scope 注释 再加上 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"06Springboot-- 导包错误","slug":"computer-science/java/springboot/springboot-error1/06Springboot-导包错误","date":"2020-10-05T09:06:52.000Z","updated":"2023-11-30T09:56:16.644Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/06Springboot-导包错误/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/06Springboot-%E5%AF%BC%E5%8C%85%E9%94%99%E8%AF%AF/","excerpt":"","text":"# 项目场景： 运行 IDEA 时出现错误 # 问题描述： Cannot resolve org.apache.tomcat.embed:tomcat-embed-core:9.0.36 # 原因分析： 刚刚想学习 springboot 的缓冲机制 在新建项目的时候发现了这么一个错误 这两个都在指明 tomcat9.0.36 无法下载成功 但是你之前运行其他的 spring boot 项目是 web 依赖的 tomcat 是可以运行的 这个时候你就会联想到是版本的问题了吧 # 解决方案： 所以我们可以打开一个之前可以运行的 springboot 项目 找到右边的 maven，点击 你会发现你的 tomcat 的版本是其他 我这里是 9.0.35， 所以这个时候嘛 我们打开之前无法使用的 springboot 项目 打开它的 pox.xml &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt;只需添加成 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;tomcat.version&gt;你的tomcat版本号&lt;/tomcat.version&gt; &lt;/properties&gt;然后点击左边的 maven 再 install 就 ok 了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"05Springboot--数据库拼写错误BindingException: Invalid bound statement ","slug":"computer-science/java/springboot/springboot-error1/05Springboot-数据库拼写错误BindingException-Invalid-bound-statement","date":"2020-10-05T09:04:01.000Z","updated":"2023-11-30T09:56:16.643Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/05Springboot-数据库拼写错误BindingException-Invalid-bound-statement/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/05Springboot-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AFBindingException-Invalid-bound-statement/","excerpt":"","text":"# 项目场景： 运行 IDEA 时出现错误 # 问题描述： org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.example.mysportjava.dao.UserDao.getUserByMassage # 原因分析： 映射文件拼写错误 # 解决方案： 1 问题实质: dao 层 (又叫 mapper 接口) 跟 mapper.xml 文件没有映射 2 问题原因：出现这种映射问题的原因分为低级原因和更低级原因两种 更低级原因: (1) dao 层的方法和 mapper.xml 中的方法不一样； (2) mapper 中的 namespace resultParameter 和对应的 dao 层 entity 层不一样 (3) 拼写错误 如漏写 少写 多写.... 上述这些原因都会导致两者不能映射 这些检查和修正的工作自己来吧不会的百度就行 低级原因: spring 配置文件中关于 mybatis 的与 xml 文件路径寻找相关的配置没有写 导致调用 dao 层方法时，没有寻找 dao.xml 文件的正确路径 结果 dao 迷路了 从而两者无法映射 3 解决思路：把 dao.xml (或 mapper.xml) 路径配置写好！！！！ 既然出发点 (dao) 已经确定，目的地 (dao.xml/mapper.xml) 也确定了 想到到达就必须画一条到 dao.xml 的路 4 解决步骤: (1) 打开 spring-context.xml 配置文件 (2) 找到 class 为 org.mybatis.spring.SqlSessionFactoryBean 这个 bean (3) 找到 name 为 mapperLocations 的 property (4) 在 list 标签中添加一个 value 例如: &lt;value&gt;classpath:/info/mappings/**/*.xml&lt;/value&gt; 重启，问题解决！！！ 注:classpath 是配置好的类路径 要想知道表示什么 最简单的方式是参考其他 list 看一眼比对项目结构就了然了 我的博客，欢迎点击光顾 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"05Springboot--出现BindingException","slug":"computer-science/java/springboot/springboot-error1/05Springboot-出现BindingException","date":"2020-10-05T09:00:28.000Z","updated":"2023-11-30T09:56:16.642Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/05Springboot-出现BindingException/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/05Springboot-%E5%87%BA%E7%8E%B0BindingException/","excerpt":"","text":"# 项目场景： IDEA 在启动时出现错误 # 问题描述： 2020-09-21 21:08:06.650 ERROR 23480 --- [nio-9000-exec-3] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.example.mysportjava.dao.UserDao.getUserByMassage] with root causeorg.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.example.mysportjava.dao.UserDao.getUserByMa # 原因分析： 多出空格 # 解决方案： 我的博客，欢迎点击光顾 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"04Springboot-- 数据库错误","slug":"computer-science/java/springboot/springboot-error1/04Springboot-数据库错误","date":"2020-10-05T08:57:24.000Z","updated":"2023-11-30T09:56:16.641Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/04Springboot-数据库错误/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/04Springboot-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF/","excerpt":"","text":"# 项目场景： IDEA 在启动时出现错误 # 问题描述： Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.2020-09-21 21:01:19.269 ERROR 25820 --- [ main] o.s.boot.SpringApplication : Application run failed# 原因分析： 注释 # 解决方案： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"02Springboot启动类错误","slug":"computer-science/java/springboot/springboot-error1/02Springboot启动类错误","date":"2020-10-05T08:53:47.000Z","updated":"2023-11-30T09:56:16.640Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/02Springboot启动类错误/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/02Springboot%E5%90%AF%E5%8A%A8%E7%B1%BB%E9%94%99%E8%AF%AF/","excerpt":"","text":"# 项目场景： IDEA 在启动时出现错误 # 问题描述： # 原因分析： # 解决方案： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"Springboot--01错误记录","slug":"computer-science/java/springboot/springboot-error1/Springboot-01错误记录","date":"2020-10-05T08:46:35.000Z","updated":"2023-11-30T09:56:16.645Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/Springboot-01错误记录/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/Springboot-01%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"问题 1： Identify and stop the process that's listening on port 8080 or configure this application to listen on another port. 问题 2 二、解决方式： 1. 检查自己写的注解是否错了，并没有。 2. 在网上查找解决方式：如下所示： 步骤一： 在 springboot 的配置文件添加，mybatis 的配置如下所示： mybatis: typeAliasesPackage: com.xxx.xxx.dao.entity mapperLocations: classpath:mapper/*.xml步骤二： ①将接口与对应的实现类放在与 application 启动类的同一个目录或者他的子目录下，这样注解可以被扫描到，这是最省事的办法。（没测试） ②或者在启动类上加上 @MapperScan 或者 @ComponentScan 注解，手动指定 application 类要扫描哪些包下的注解，如下所示： @SpringBootApplication@ComponentScan(basePackages = {\"com.xxx.xxx.dao\"}) ③或者在接口上添加@Mapper注解。@Mapperpublic interface UserMapper {}问题 3： 原因： 修改了 mapper 类的名称对应要修改路径 问题 4： 添加数据时未添加外键 添加 sql 输入外键 unit_ID 问题 5: Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.2020-09-12 14:40:39.211 ERROR 60268 --- [ main] o.s.boot.SpringApplication : Application run failed常见注释错误，查看代码中的 @注释 问题 6: 问题 7： 在测试的时候报出 415 更改一下请求头 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"03VUE---拦截路径挂载的问题","slug":"computer-science/vue/vue-error1/03VUE-拦截路径挂载的问题","date":"2020-10-05T08:25:40.000Z","updated":"2023-11-30T09:56:16.681Z","comments":true,"path":"computer-science/vue/vue-error1/03VUE-拦截路径挂载的问题/","link":"","permalink":"https://ppxpython.github.io/computer-science/vue/vue-error1/03VUE-%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"# 项目场景： vscode 中没有报错，但在网页的控制台中出现错误 # 问题描述： vscode 中没有报错，但在网页的控制台中 # 原因分析： 拦截路径挂载的问题 # 解决方案： 在上面添加 // 出现问题时使用 const originalPush=VueRouter.prototype.push VueRouter.prototype.push=function push(location,onResolve,onReject){ if(onResolve || onReject) return originalPush.call(this,location,onResolve,onReject) return originalPush.call(this,location).catch(err =&gt; err) } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Vue","slug":"computer-science/vue","permalink":"https://ppxpython.github.io/categories/computer-science/vue/"},{"name":"前端Vue中常见问题集合","slug":"computer-science/vue/vue-error1","permalink":"https://ppxpython.github.io/categories/computer-science/vue/vue-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"02VUE---没有引入依赖包","slug":"computer-science/vue/vue-error1/02VUE-没有引入依赖包","date":"2020-10-05T08:22:04.000Z","updated":"2023-11-30T09:56:16.681Z","comments":true,"path":"computer-science/vue/vue-error1/02VUE-没有引入依赖包/","link":"","permalink":"https://ppxpython.github.io/computer-science/vue/vue-error1/02VUE-%E6%B2%A1%E6%9C%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%8C%85/","excerpt":"","text":"# 项目场景： 在运行 vscode 时，出现错误 # 问题描述： # 原因分析： 没有引入依赖包 npm # 解决方案： 输入 npm install即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Vue","slug":"computer-science/vue","permalink":"https://ppxpython.github.io/categories/computer-science/vue/"},{"name":"前端Vue中常见问题集合","slug":"computer-science/vue/vue-error1","permalink":"https://ppxpython.github.io/categories/computer-science/vue/vue-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"01web开发需要了解的技术2020-09-02","slug":"computer-science/vue/vue-study1/01web开发需要了解的技术2020-09-02","date":"2020-10-05T08:09:30.000Z","updated":"2023-11-30T09:56:16.682Z","comments":true,"path":"computer-science/vue/vue-study1/01web开发需要了解的技术2020-09-02/","link":"","permalink":"https://ppxpython.github.io/computer-science/vue/vue-study1/01web%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E6%8A%80%E6%9C%AF2020-09-02/","excerpt":"","text":"日期：2020——09——02 IT 人：小海豚 学习内容： 大数据 oop（面向对象的编程） ood（面向对象的设计） web 开发： Html Js（JavaScript）面向对象语言 Css 前端框架： Vue（js 库与后端的一套接口），jquery，react 组件库： Element UI（界面） 常与（VUE 框架一起） Easy UI（界面） 工具： 测试集成在开发过程中 移动布局 webscocket 协议 Git 测试 / 调试工具 firebug，postmon 后端： java，python,C#,mysql (构建) 后端框架 jsp/selvlet ssm 框架（spring，struts，mybatis） Spring boost：最新框架 前端后端公共技术 svn/git 工具 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Vue","slug":"computer-science/vue","permalink":"https://ppxpython.github.io/categories/computer-science/vue/"},{"name":"初学Vue框架","slug":"computer-science/vue/vue-study1","permalink":"https://ppxpython.github.io/categories/computer-science/vue/vue-study1/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://ppxpython.github.io/tags/VUE/"}]},{"title":"08django---的装换器","slug":"computer-science/python/django/course-1/08django-的装换器","date":"2020-10-05T08:04:50.000Z","updated":"2023-11-30T09:56:16.669Z","comments":true,"path":"computer-science/python/django/course-1/08django-的装换器/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/08django-%E7%9A%84%E8%A3%85%E6%8D%A2%E5%99%A8/","excerpt":"","text":"日期：20019——10——07 IT 人：小海豚 学习内容： 装换器 https://news.163.com/19/0405/08/EC017RFK0001899O.html https://news.163.com/19/0405/08/EC01HSST000189FH.html 在 app bookapp 的 urls 中 ​ 注意：&lt;html&gt; 表示可以是任何字母 在 app bookapp 的 views 中写入 ​ 在项目的 urls 中修改以下 ​ 在浏览器中输入网址 http://127.0.0.1:8000/19/0405/08/EC01HSST000189FH.html ​ 地址装唤器装换 字符串 ——》变量接收 ——》传递 path 中的 &lt;html&gt; 变量 ——》在 app bookapp 中的 index 函数的 html 变量接收到 ——》在 format 中输出地址信息 第二个地址 在浏览器中输入 http://127.0.0.1:8000/19/0405/08/EC017RFK0001899O.html ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"07django--path的语法","slug":"computer-science/python/django/course-1/07django-path的语法","date":"2020-10-05T08:02:33.000Z","updated":"2023-11-30T09:56:16.669Z","comments":true,"path":"computer-science/python/django/course-1/07django-path的语法/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/07django-path%E7%9A%84%E8%AF%AD%E6%B3%95/","excerpt":"","text":"日期：2019——10——06 IT 人：小海豚 学习内容： Path 的语法 从 django2.1 以后用 path 之前用的是 url 标准语法 Path (route,view,name=None,**kwargs) Route: 端口以后 url 的地址，到 / 结束，表示路径 View: 表示路径匹配成功后，需要调用的视图，必须是个函数如果是 class 的话，必须要用 as_view () 函数装换为函数 name： 表示别名 **kwargs： 表示一个字典 前面两个是必选项 创建的 newwebsite002 是之前的，查看 06django 教程 在之前的 views 不变 ​ 在之前创建的 app book 的 urls 中 ​ 打开项目所在地址 cmd 开启服务器 ​ 成功 ​ 证明服务器已经跑起来了 继续刷新 ​ 修改 app bookapp 中的 urls ​ 在输入网址查看 http://127.0.0.1:8000/index ​ 输入 http://127.0.0.1:8000/index/web/ 查看 ​ 也可以写成多分级目录 修改 app bookapp 中的 urls 注释 #path ('',views.index,name='index'), ​ 在浏览器中执行 http://127.0.0.1:8000/index/web/a/b/c/index.html/ ​ 成功 注意：当出现路径相同时，会自动匹配第一个之后机就默认不匹配了 ​ 结果一直是： ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"06django--url的讲解","slug":"computer-science/python/django/course-1/06django-url的讲解","date":"2020-10-05T07:57:17.000Z","updated":"2023-11-30T09:56:16.667Z","comments":true,"path":"computer-science/python/django/course-1/06django-url的讲解/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/06django-url%E7%9A%84%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"日期：2019——09——28 IT 人：小海豚 学习内容： 统一资源定位器 协议 protocol：http，https，ftp 域名 hostname + 端口 port 路径 path 参数 parmeters 查询 query 描点 fragment django 中配置 urls 创建一个 newwebsite002 的 django 文件和 book 的 app 命令行输入 django-admin startproject newwebsite002cd newwebsite002ptrhon manage.py startapp book ​ 显示出 ​ 在浏览器中检查 开启服务器 ​ 成功 ​ 在 setting 中配置注册 app book 添加 'book', ​ 在 app views 视图中写入两个函数 ​ 在 app book 中创建一个 urls 文件 进行配置 ​ 在 app book urls 中编码 ​ 在项目中做个映射 在项目 newwebsite002 的 urls 中编码 ​ 成功 ​ 切换网址后 ​ 表示成功 注意：在 path 语句中在路径中要加上 / document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"05django--mvt介绍","slug":"computer-science/python/django/course-1/05django-mvt介绍","date":"2020-10-05T07:50:40.000Z","updated":"2023-11-30T09:56:16.665Z","comments":true,"path":"computer-science/python/django/course-1/05django-mvt介绍/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/05django-mvt%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"日期：20019——09——27 IT 人：小海豚 学习内容： django 的设计模式 Models 作用 封装数据库， 对数据库进行访问， 对数据进行增删改查， Views 作用 进行业务逻辑的处理， teplates 作用 模板，主要进行展示，前端 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"04django--整体讲解","slug":"computer-science/python/django/course-1/04django-整体讲解","date":"2020-10-05T07:48:26.000Z","updated":"2023-11-30T09:56:16.664Z","comments":true,"path":"computer-science/python/django/course-1/04django-整体讲解/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/04django-%E6%95%B4%E4%BD%93%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"日期：2019——09——27 IT 人：小海豚 学习内容： 导包的文件 ​ 一般都不用但不能够删除 ​ settings 配置文件 urls 统一资源编译器 wsgi 网管接口 app 中 News 大部分功能在 app news 中完成 Mingrations ​ 数据库映射时使用，一般不修改 ​ admin 管理文件 apps 定义 app 名字 models 模型写数据库 tests 测试文件 urls 配置 app 的 urls，和项目的 urls 进行交互 views 视图文件 Bd.sqlite3 默认使用的数据库 Manage.py 项目管理文件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"03django--带有模板的html文件百度","slug":"computer-science/python/django/course-1/03django-带有模板的html文件百度","date":"2020-10-05T07:44:36.000Z","updated":"2023-11-30T09:56:16.663Z","comments":true,"path":"computer-science/python/django/course-1/03django-带有模板的html文件百度/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/03django-%E5%B8%A6%E6%9C%89%E6%A8%A1%E6%9D%BF%E7%9A%84html%E6%96%87%E4%BB%B6%E7%99%BE%E5%BA%A6/","excerpt":"","text":"日期：2019——09——27 IT 人：小海豚 学习内容： 启动服务器 在上一次创建的 app news 中创建一个 模板文件 叫 在创建一个 html 文件 叫 baidu 把百度拉入模板文件中，生成目录 打开浏览器搜索百度 复制全部源代码 在 html 中使用 baidu 修改视图 app news 中的 views 效果生成 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"语言教程网址","slug":"工具教程网址","date":"2020-09-29T07:35:50.000Z","updated":"2023-11-30T09:56:16.710Z","comments":true,"path":"工具教程网址/","link":"","permalink":"https://ppxpython.github.io/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B%E7%BD%91%E5%9D%80/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"官网教程","slug":"官网教程","permalink":"https://ppxpython.github.io/tags/%E5%AE%98%E7%BD%91%E6%95%99%E7%A8%8B/"}]},{"title":"01Springboot启动时端口被占用","slug":"computer-science/java/springboot/springboot-error1/01Springboot启动时端口被占用","date":"2020-09-28T04:02:42.000Z","updated":"2023-11-30T09:56:16.640Z","comments":true,"path":"computer-science/java/springboot/springboot-error1/01Springboot启动时端口被占用/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-error1/01Springboot%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/","excerpt":"","text":"# 项目场景： Springboot 在启动时出现端口 8888 被占用 # 问题描述： Springboot 在启动时出现端口被占用 错误提示：Description:Web server failed to start. Port 8888 was already in use.Action:Identify and stop the process that's listening on port 8888 or configure this application to listen on another port.Disconnected from the target VM, address: '127.0.0.1:54879', transport: 'socket'[ERROR] Command execution failed.Command execution failed. # 原因分析： 由于之前开启 vue 项目启动，再启动后端时会报错。 # 解决方案： netstat -aon|findstr \"9000\"查看端口号运行进程taskkill /pid 进程号 -f` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"01Springboot小白详细的安装教程","slug":"computer-science/java/springboot/springboot-study1/01Springboot小白详细的安装教程","date":"2020-09-28T02:51:35.000Z","updated":"2023-11-30T09:56:16.655Z","comments":true,"path":"computer-science/java/springboot/springboot-study1/01Springboot小白详细的安装教程/","link":"","permalink":"https://ppxpython.github.io/computer-science/java/springboot/springboot-study1/01Springboot%E5%B0%8F%E7%99%BD%E8%AF%A6%E7%BB%86%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"&lt;hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\"&gt; # 前言 初学 Springboot 的小白刚安装了 IDEA 分享一下安装教程吧 &lt;hr style=\"border:solid; width:100px; height:1px;\" color=#000000 size=1\"&gt; # 一、IDEA 是什么？ IDEA 全称 IntelliJ IDEA，是 java 编程语言开发的集成环境。IntelliJ 在业界被公认为最好的 java 开发工具，尤其在智能代码助手、代码自动提示、重构、JavaEE 支持、各类版本工具 (git、svn 等)、JUnit、CVS 整合、代码分析、 创新的 GUI 设计等方面的功能可以说是超常的。IDEA 是 JetBrains 公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持 HTML，CSS，PHP，MySQL，Python 等。免费版只支持 Java,Kotlin 等少数语言。 附上百度百科网址： 百度百科了解 IDEA IDEA 官网：IDEA 官网 # 二、安装步骤 教程采用了微信公众号：软件安装管家 很强大，可以安装各种软件 # 1. 安装 SpringBoot # 2. 安装 maven 安装 maven maven 下载官网地址：maven 下载官网地址 解压后 配置环境变量 成功 进入 Springboot 官网中 Springboot 官网：Springboot 官网 创建项目网址： 创建项目网址 添加架包 用 idea 打开制定架包 开启框架，开始代码 # 总结 安装完成，开始代码之旅吧 如有问题请在下方评论学习，共同进步 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"小白学SpringBoot框架","slug":"computer-science/java/springboot/springboot-study1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-study1/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ppxpython.github.io/tags/SpringBoot/"}]},{"title":"01vue标签指令","slug":"computer-science/vue/vue-study1/01vue标签指令","date":"2020-09-28T00:56:11.000Z","updated":"2023-11-30T09:56:16.681Z","comments":true,"path":"computer-science/vue/vue-study1/01vue标签指令/","link":"","permalink":"https://ppxpython.github.io/computer-science/vue/vue-study1/01vue%E6%A0%87%E7%AD%BE%E6%8C%87%E4%BB%A4/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Vue","slug":"computer-science/vue","permalink":"https://ppxpython.github.io/categories/computer-science/vue/"},{"name":"初学Vue框架","slug":"computer-science/vue/vue-study1","permalink":"https://ppxpython.github.io/categories/computer-science/vue/vue-study1/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://ppxpython.github.io/tags/VUE/"}]},{"title":"01Django中出现OperationalError问题","slug":"computer-science/python/django/django-error1/01Django中出现OperationalError问题","date":"2020-09-28T00:47:08.000Z","updated":"2023-11-30T09:56:16.675Z","comments":true,"path":"computer-science/python/django/django-error1/01Django中出现OperationalError问题/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/django-error1/01Django%E4%B8%AD%E5%87%BA%E7%8E%B0OperationalError%E9%97%AE%E9%A2%98/","excerpt":"","text":"# 项目场景： Django 中连接数据库时出现错误，采用了一个大牛的博客解决的，这里附上链接 https://blog.csdn.net/Wathet_blue/article/details/105401717?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242 # 问题描述： 出现错误！OperationalError: (1366, “Incorrect string value: ‘\\xE4\\xB9\\x8B\\xE7\\xBE\\x8E’ for column ‘name’ at row 1”) # 原因分析： 数据库的编码规则没有使用 utf8，而在存储数据时添加了中文数据，导致报错。 # 解决方案： 删除数据库 (有数据先备份) drop database [database_name];指定编码重建数据库 或者 修改数据库编码后重建数据库 create database [database_name] default character set utf8 collate utf8_general_ci;show variables like 'character%'; // 查看mysql的编码 set character_set_client=utf8; // 设置客户端的编码为utf8 set character_set_connection=utf8; set character_set_database=utf8; set character_set_results=utf8; set character_set_server=utf8; set character_set_system=utf8; create database [database_name]; // 新创建数据库使用的编码规则是utf8重新迁移数据库 python manage.py makemigrations python manage.py migrate document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"前端Django中常见的错误集合","slug":"computer-science/python/django/django-error1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/django-error1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"01vue运行出错Cannot find module 'stylus'","slug":"computer-science/vue/vue-error1/01vue中包导入出错code-ENOLOCAL","date":"2020-09-27T23:08:53.000Z","updated":"2023-11-30T09:56:16.680Z","comments":true,"path":"computer-science/vue/vue-error1/01vue中包导入出错code-ENOLOCAL/","link":"","permalink":"https://ppxpython.github.io/computer-science/vue/vue-error1/01vue%E4%B8%AD%E5%8C%85%E5%AF%BC%E5%85%A5%E5%87%BA%E9%94%99code-ENOLOCAL/","excerpt":"","text":"# 项目场景： 本人小白记录在初学 vue 中的一些小问题，在使用 npm run serve 运行 vue 项目时，出现错误 &lt;hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\"&gt; # 问题描述： 出现错误 # 原因分析： 没有引入相关依赖 # 解决方案： 需要执行 npm install引入相关依赖即可解决问题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Vue","slug":"computer-science/vue","permalink":"https://ppxpython.github.io/categories/computer-science/vue/"},{"name":"前端Vue中常见问题集合","slug":"computer-science/vue/vue-error1","permalink":"https://ppxpython.github.io/categories/computer-science/vue/vue-error1/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"}]},{"title":"02django带app的网站创建","slug":"computer-science/python/django/course-1/02django带app的网站创建","date":"2020-09-27T08:27:27.000Z","updated":"2023-11-30T09:56:16.663Z","comments":true,"path":"computer-science/python/django/course-1/02django带app的网站创建/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/02django%E5%B8%A6app%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%9B%E5%BB%BA/","excerpt":"","text":"python 前端框架 标题import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (\"Hello\" + \"world.\");pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploy 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 有基类 SHAPE ，派生类 CIRCLE ，声明如下变量： SHAPE shape1,*p1;CIRCLE circle1,*q1;下列哪些项是 “派生类对象替换基类对象”。 p1=&amp;circle1; q1=&amp;shape1; shape1=circle1; circle1=shape1; ✔️ 令基类对象的指针指向派生类对象 ❌ 派生类指针指向基类的引用 ✔️ 派生类对象给基类对象赋值 ❌ 基类对象给派生类对象赋值 下列叙述正确的是 。 虚函数只能定义成无参函数 虚函数不能有返回值 能定义虚构造函数 A、B、C 都不对 如果定义 int e=8; double f=6.4, g=8.9; ，则表达式 f+int (e/3*int (f+g)/2)%4 的值为 9.4。 注意运算顺序和数据类型 8.4 😘 💍 🎶 python primary info ✔️success warning 💔danger document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"01django-hello world简单例子","slug":"computer-science/python/django/course-1/01django-hello-world简单例子","date":"2020-09-27T08:23:25.000Z","updated":"2023-11-30T09:56:16.662Z","comments":true,"path":"computer-science/python/django/course-1/01django-hello-world简单例子/","link":"","permalink":"https://ppxpython.github.io/computer-science/python/django/course-1/01django-hello-world%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/","excerpt":"","text":"python 前端框架 # 01django-hello world 简单例子 加粗样式 日期：2019——09——26 IT 人： 小海豚 学习内容： 创建一个新的 django 文件 命令： hdjango—admin startproject mywebsite创建文件 开启服务器 hPython manage.py runserver启动服务器 成功 创建一个 views 文件 Python 的 在其中编辑 在 url 中修改 在浏览器中进行刷新 注意：服务器要开启 h Python manage.py runserve 原文出自[易百教程] 转载请保留原文链接: https://www.yiibai.com/geek/detail/1184 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"}]},{"title":"我的第一篇博客文章","slug":"records/live-record/live-blog/我的第一篇博客文章","date":"2020-09-26T15:29:07.000Z","updated":"2023-11-30T09:56:16.703Z","comments":true,"path":"records/live-record/live-blog/我的第一篇博客文章/","link":"","permalink":"https://ppxpython.github.io/records/live-record/live-blog/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"你好！ 这是你第一次使用 Markdown 编辑器 所展示的欢迎页。如果你想学习如何使用 Markdown 编辑器，可以仔细阅读这篇文章，了解一下 Markdown 的基本语法知识。 # 新的改变 我们对 Markdown 编辑器进行了一些功能拓展与语法支持，除了标准的 Markdown 编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX 数学公式 语法； 增加了支持甘特图的 mermaid 语法[1] 功能； 增加了 多屏幕编辑 Markdown 文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 # 功能快捷键 撤销：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Z&lt;/kbd&gt; 重做：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Y&lt;/kbd&gt; 加粗：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;B&lt;/kbd&gt; 斜体：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;I&lt;/kbd&gt; 标题：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;H&lt;/kbd&gt; 无序列表：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;U&lt;/kbd&gt; 有序列表：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;O&lt;/kbd&gt; 检查列表：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;C&lt;/kbd&gt; 插入代码：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;K&lt;/kbd&gt; 插入链接：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;L&lt;/kbd&gt; 插入图片：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;Shift&lt;/kbd&gt; + &lt;kbd&gt;G&lt;/kbd&gt; 查找：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;F&lt;/kbd&gt; 替换：&lt;kbd&gt;Ctrl/Command&lt;/kbd&gt; + &lt;kbd&gt;G&lt;/kbd&gt; # 合理的创建标题，有助于目录的生成 直接输入 1 次 &lt;kbd&gt;#&lt;/kbd&gt;，并按下 &lt; kbd&gt;space&lt;/kbd &gt; 后，将生成 1 级标题。 输入 2 次 &lt;kbd&gt;#&lt;/kbd&gt;，并按下 &lt; kbd&gt;space&lt;/kbd &gt; 后，将生成 2 级标题。 以此类推，我们支持 6 级标题。有助于使用 TOC 语法后生成一个完美的目录。 # 如何改变文本的样式 强调文本 强调文本 加粗文本 加粗文本 标记文本 删除文本 引用文本 H2O is 是液体。 210 运算结果是 1024. # 插入链接与图片 链接: link. 图片: 带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30) 居中的图片: 居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30) 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 # 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片 . // An highlighted blockvar foo = 'bar';# 生成一个适合你的列表 项目 项目 项目 项目 1 项目 2 项目 3 计划任务 完成任务 # 创建一个表格 一个简单的表格是这么创建的： 项目 Value 电脑 $1600 手机 $12 导管 $1 # 设定内容居中、居左、居右 使用 :---------: 居中 使用 :---------- 居左 使用 ----------: 居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 # SmartyPants SmartyPants 将 ASCII 标点字符转换为 “智能” 印刷标点 HTML 实体。例如： TYPE ASCII HTML Single backticks 'Isn't this fun?' 'Isn't this fun?' Quotes \"Isn't this fun?\" \"Isn't this fun?\" Dashes -- is en-dash, --- is em-dash -- is en-dash, --- is em-dash # 创建一个自定义列表 Markdown Text-to-HTML conversion tool Authors John Luke # 如何创建一个注脚 一个具有注脚的文本。[2] # 注释也是必不可少的 Markdown 将文本转换为 HTML。 # KaTeX 数学公式 您可以使用渲染 LaTeX 数学表达式 KaTeX: Gamma 公式展示 Γ(n)=(n−1)!∀n∈N\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb NΓ(n)=(n−1)!∀n∈N 是通过欧拉积分 Γ(z)=∫0∞tz−1e−tdt .\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. Γ(z)=∫0∞​tz−1e−tdt. 你可以找到更多关于的信息 LaTeX 数学表达式 here. # 新的甘特图功能，丰富你的文章 2014-01-072014-01-092014-01-112014-01-132014-01-152014-01-172014-01-192014-01-21已完成 进行中 计划一 计划二 现有任务Adding GANTT diagram functionality to mermaid 关于 甘特图 语法，参考 这儿， # UML 图表 可以使用 UML 图表进行渲染。 Mermaid. 例如下面产生的一个序列图： 张三李四王五你好！李四, 最近怎么样?你最近怎么样，王五？我很好，谢谢!我很好，谢谢!李四想了很长时间, 文字太长了不适合放在一行.打量着王五...很好... 王五, 你怎么样?张三李四王五这将产生一个流程图。: 链接长方形圆圆角长方形菱形 关于 Mermaid 语法，参考 这儿， # FLowchart 流程图 我们依旧会支持 flowchart 的流程图： TimeoutError: Navigation timeout of 30000 ms exceeded 关于 Flowchart 流程图 语法，参考 这儿. # 导出与导入 # 导出 如果你想尝试使用此编辑器，你可以在此篇文章任意编辑。当你完成了一篇文章的写作，在上方工具栏找到 文章导出 ，生成一个.md 文件或者.html 文件进行本地保存。 # 导入 如果你想加载一篇你写过的.md 文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入， 继续你的创作。 mermaid 语法说明 ↩︎ 注脚的解释 ↩︎ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"心得记录","slug":"records","permalink":"https://ppxpython.github.io/categories/records/"},{"name":"生活记录","slug":"records/live-record","permalink":"https://ppxpython.github.io/categories/records/live-record/"},{"name":"个人博客","slug":"records/live-record/live-blog","permalink":"https://ppxpython.github.io/categories/records/live-record/live-blog/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://ppxpython.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"电脑","slug":"computer","permalink":"https://ppxpython.github.io/categories/computer/"},{"name":"软件配置","slug":"computer/app","permalink":"https://ppxpython.github.io/categories/computer/app/"},{"name":"安装教程","slug":"computer/app/install","permalink":"https://ppxpython.github.io/categories/computer/app/install/"},{"name":"计算机基础","slug":"computer/计算机基础","permalink":"https://ppxpython.github.io/categories/computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"网络基础","slug":"computer/计算机基础/networking","permalink":"https://ppxpython.github.io/categories/computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/networking/"},{"name":"计算机科学","slug":"computer-science","permalink":"https://ppxpython.github.io/categories/computer-science/"},{"name":"Python","slug":"computer-science/python","permalink":"https://ppxpython.github.io/categories/computer-science/python/"},{"name":"Django框架","slug":"computer-science/python/django","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/"},{"name":"零基础学Django框架","slug":"computer-science/python/django/course-1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/course-1/"},{"name":"心得记录","slug":"records","permalink":"https://ppxpython.github.io/categories/records/"},{"name":"生活记录","slug":"records/live-record","permalink":"https://ppxpython.github.io/categories/records/live-record/"},{"name":"新创意点","slug":"records/live-record/new-idea","permalink":"https://ppxpython.github.io/categories/records/live-record/new-idea/"},{"name":"生活感悟","slug":"records/live-record/live-feel","permalink":"https://ppxpython.github.io/categories/records/live-record/live-feel/"},{"name":"电脑配置","slug":"computer/win","permalink":"https://ppxpython.github.io/categories/computer/win/"},{"name":"win10","slug":"computer/win/win10","permalink":"https://ppxpython.github.io/categories/computer/win/win10/"},{"name":"钉钉小程序","slug":"computer-science/DDapp","permalink":"https://ppxpython.github.io/categories/computer-science/DDapp/"},{"name":"钉钉小程序学习","slug":"computer-science/DDapp/ddapp-study1","permalink":"https://ppxpython.github.io/categories/computer-science/DDapp/ddapp-study1/"},{"name":"个人博客","slug":"records/live-record/live-blog","permalink":"https://ppxpython.github.io/categories/records/live-record/live-blog/"},{"name":"软件测试","slug":"software-test","permalink":"https://ppxpython.github.io/categories/software-test/"},{"name":"软件测试工具学习","slug":"software-test/test-tools","permalink":"https://ppxpython.github.io/categories/software-test/test-tools/"},{"name":"接口测试工具","slug":"software-test/test-tools/api-testing2","permalink":"https://ppxpython.github.io/categories/software-test/test-tools/api-testing2/"},{"name":"Postman","slug":"software-test/test-tools/api-testing2/postman","permalink":"https://ppxpython.github.io/categories/software-test/test-tools/api-testing2/postman/"},{"name":"Java","slug":"computer-science/java","permalink":"https://ppxpython.github.io/categories/computer-science/java/"},{"name":"SpringBoot框架","slug":"computer-science/java/springboot","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/"},{"name":"SpringBoot框架常见错误集合","slug":"computer-science/java/springboot/springboot-error1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-error1/"},{"name":"Vue","slug":"computer-science/vue","permalink":"https://ppxpython.github.io/categories/computer-science/vue/"},{"name":"前端Vue中常见问题集合","slug":"computer-science/vue/vue-error1","permalink":"https://ppxpython.github.io/categories/computer-science/vue/vue-error1/"},{"name":"初学Vue框架","slug":"computer-science/vue/vue-study1","permalink":"https://ppxpython.github.io/categories/computer-science/vue/vue-study1/"},{"name":"小白学SpringBoot框架","slug":"computer-science/java/springboot/springboot-study1","permalink":"https://ppxpython.github.io/categories/computer-science/java/springboot/springboot-study1/"},{"name":"前端Django中常见的错误集合","slug":"computer-science/python/django/django-error1","permalink":"https://ppxpython.github.io/categories/computer-science/python/django/django-error1/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ppxpython.github.io/tags/Django/"},{"name":"创业","slug":"创业","permalink":"https://ppxpython.github.io/tags/%E5%88%9B%E4%B8%9A/"},{"name":"钉钉小程序","slug":"钉钉小程序","permalink":"https://ppxpython.github.io/tags/%E9%92%89%E9%92%89%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://ppxpython.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Postman","slug":"Postman","permalink":"https://ppxpython.github.io/tags/Postman/"},{"name":"Error","slug":"Error","permalink":"https://ppxpython.github.io/tags/Error/"},{"name":"VUE","slug":"VUE","permalink":"https://ppxpython.github.io/tags/VUE/"},{"name":"官网教程","slug":"官网教程","permalink":"https://ppxpython.github.io/tags/%E5%AE%98%E7%BD%91%E6%95%99%E7%A8%8B/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ppxpython.github.io/tags/SpringBoot/"},{"name":"博客","slug":"博客","permalink":"https://ppxpython.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}